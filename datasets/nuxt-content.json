[
  {
    "title": "Basic Usage - Nuxt Content V1",
    "url": "https://content.nuxt.com/v1/examples/basic",
    "html": "Examples\n\nBasic Usage\n\nLive example of basic usage of Nuxt Content on CodeSandbox.\n\nAdvanced\n\nLearn advanced usage of @nuxt/content module.\n\nTailwindCSS\n\nLive example of Nuxt Content with TailwindCSS Typography plugin on CodeSandbox."
  },
  {
    "title": "Docs Theme - Nuxt Content V1",
    "url": "https://content.nuxt.com/v1/examples/docs-theme",
    "html": "Examples\n\nDocs Theme\n\nLive example of Nuxt Content docs theme on CodeSandbox.\n\nTailwindCSS\n\nLive example of Nuxt Content with TailwindCSS Typography plugin on CodeSandbox.\n\nSnippets\n\nLearn how to implement @nuxt/content into your app with these code snippets."
  },
  {
    "title": "Integrations - Nuxt Content V1",
    "url": "https://content.nuxt.com/v1/community/integrations/",
    "html": "Community\n\nIntegrations\n\nLearn how to use @nuxt/content with other modules.\n\n@nuxtjs/feed\n\nIn the case of articles, the content can be used to generate news feeds using @nuxtjs/feed module.\n\nTo use $content inside the feed option, you need to add @nuxt/content before @nuxtjs/feed in the modules property.\n\nYou can access your feed on: baseUrl + baseLinkFeedArticles + file\n\nFor RSS: https://mywebsite.com/feed/articles/rss.xml\n\nFor JSON: https://mywebsite.com/feed/articles/feed.json\n\nExample 1\n\nexport default {\n\n  modules: [\n\n    '@nuxt/content',\n\n    '@nuxtjs/feed'\n\n  ],\n\n\n\n  feed () {\n\n    const baseUrlArticles = 'https://mywebsite.com/articles'\n\n    const baseLinkFeedArticles = '/feed/articles'\n\n    const feedFormats = {\n\n      rss: { type: 'rss2', file: 'rss.xml' },\n\n      json: { type: 'json1', file: 'feed.json' },\n\n    }\n\n    const { $content } = require('@nuxt/content')\n\n\n\n    const createFeedArticles = async function (feed) {\n\n      feed.options = {\n\n        title: 'My Blog',\n\n        description: 'I write about technology',\n\n        link: baseUrlArticles,\n\n      }\n\n      const articles = await $content('articles').fetch()\n\n\n\n      articles.forEach((article) => {\n\n        const url = `${baseUrlArticles}/${article.slug}`\n\n\n\n        feed.addItem({\n\n          title: article.title,\n\n          id: url,\n\n          link: url,\n\n          date: article.published,\n\n          description: article.summary,\n\n          content: article.summary,\n\n          author: article.authors,\n\n        })\n\n      })\n\n    }\n\n\n\n    return Object.values(feedFormats).map(({ file, type }) => ({\n\n      path: `${baseLinkFeedArticles}/${file}`,\n\n      type: type,\n\n      create: createFeedArticles,\n\n    }))\n\n  }\n\n}\n\n\nThe above approach works well for some use cases. However, if you use npm run generate then this approach will produce an error.\n\nOr, if you want to include the body of the article as content (including any content from components if you mix your Vue components and your markdown) then you'll need to approach this differently.\n\nOne possible way to do this uses the @nuxtjs/feed documented approach and will work well with npm run generate and will use the existing Nuxt process to include the content. Here's how to do it.\n\nFirst, use the array based approach for declaring your feeds as shown in the @nuxtjs/feed documentation. The feed array consists of objects with 5 possible values.\n\nThe path which is the path from your domain to the feed document.\nA function that will generate the feed content.\nThe cacheTime which as the name suggests determines when the feed will be refreshed.\nThe type which determines which type of rss feed you intend to output.\nThe data which is supplied as arguments to the function (the args property in the example below)\nmodules: [    \n\n    '@nuxt/content',\n\n    '@nuxtjs/feed'    \n\n  ],\n\n\n\n  feed: [\n\n    {\n\n      path: '/feed.xml',\n\n      async create(feed, args) => {  \n\n        // create the feed\n\n      },\n\n      cacheTime: 1000 * 60 * 15,\n\n      type: 'rss2',\n\n      data: [ 'some', 'info' ]\n\n    },\n\n    {\n\n      path: '/feed.json',\n\n      async create(feed, args) => {  \n\n        // create the feed\n\n      },\n\n      cacheTime: 1000 * 60 * 15,\n\n      type: 'json1',\n\n      data: [ 'other', 'info' ]\n\n    }\n\n  ],\n\n\nYou can make the best use of the nuxt/content api by declaring your create function separately and then supplying it to the feed array object. The create function can be declared at the top of the nuxt.config.js file, or separately in another directory and exported. The create function runs after the Nuxt process has compiled the markdown and Vue components into HTML. This allows us to pull in that content and supply it to the feed.\n\nExample 2\n\n// this example declares the function at the top of the nuxt.config.js file\n\nconst fs = require('fs').promises;\n\nconst path = require('path');\n\n\n\nlet posts = [];\n\n\n\nconst constructFeedItem = async (post, dir, hostname) => {  \n\n  //note the path used here, we are using a dummy page with an empty layout in order to not send that data along with our other content\n\n  const filePath = path.join(__dirname, `dist/rss/${post.slug}/index.html`); \n\n  const content = await fs.readFile(filePath, 'utf8');\n\n  const url = `${hostname}/${dir}/${post.slug}`;\n\n  return {\n\n    title: post.title,\n\n    id: url,\n\n    link: url,\n\n    description: post.description,\n\n    content: content\n\n  }\n\n} \n\n\n\nconst create = async (feed, args) => {\n\n  const [filePath, ext] = args;  \n\n  const hostname = process.NODE_ENV === 'production' ? 'https://my-production-domain.com' : 'http://localhost:3000';\n\n  feed.options = {\n\n    title: \"My Blog\",\n\n    description: \"Blog Stuff!\",\n\n    link: `${hostname}/feed.${ext}`\n\n  }\n\n  const { $content } = require('@nuxt/content')\n\n  if (posts === null || posts.length === 0)\n\n    posts = await $content(filePath).fetch();\n\n\n\n  for (const post of posts) {\n\n    const feedItem = await constructFeedItem(post, filePath, hostname);\n\n    feed.addItem(feedItem);\n\n  }\n\n  return feed;\n\n}\n\n\n\nexport default {\n\n...\n\n  modules: [    \n\n    '@nuxt/content',\n\n    '@nuxtjs/feed'    \n\n  ],\n\n  feed: [\n\n    {\n\n      path: '/feed.xml',\n\n      create,\n\n      cacheTime: 1000 * 60 * 15,\n\n      type: 'rss2',\n\n      data: [ 'blog', 'xml' ]\n\n    },\n\n  ],  \n\n...\n\n}\n\n\nThere are at least two drawbacks to this approach:\n\nSince you're reading in the entire generated page you may pick up undesired content such as from the header and footer. One way to deal with this is to create a dummy page using an empty layout so that only the content you want included in the rss feed is used.\nrss2 and XML work well because the HTML is automatically encoded. However, json1 and json may need additional work so that the content can be transmitted.\n\nRemember also that if you are not using mixed content in your markdown (so if you are using markdown only), then it is far easier to only include the markdown. You can retrieve the markdown using this hook in your nuxt.config.js:\n\nExample 3\n\nexport default {\n\n...\n\n  hooks: {\n\n    'content:file:beforeInsert': (document) => {\n\n      if (document.extension === '.md') {      \n\n        document.bodyPlainText = document.text;\n\n      }\n\n    },\n\n  },\n\n...\n\n}\n\n\nAnd then in your create function:\n\n\n\nconst constructFeedItem = (post, dir, hostname) => {  \n\n  const url = `${hostname}/${dir}/${post.slug}`;\n\n  return {\n\n    title: post.title,\n\n    id: url,\n\n    link: url,\n\n    description: post.description,\n\n    content: post.bodyPlainText\n\n  }\n\n} \n\n\n\nconst create = async (feed, args) => {\n\n  const [filePath, ext] = args;  \n\n  const hostname = process.NODE_ENV === 'production' ? 'https://my-production-domain.com' : 'http://localhost:3000';\n\n  feed.options = {\n\n    title: \"My Blog\",\n\n    description: \"Blog Stuff!\",\n\n    link: `${hostname}/feed.${ext}`\n\n  }\n\n  const { $content } = require('@nuxt/content')\n\n  if (posts === null || posts.length === 0)\n\n    posts = await $content(filePath).fetch();\n\n\n\n  for (const post of posts) {\n\n    const feedItem = await constructFeedItem(post, filePath, hostname);\n\n    feed.addItem(feedItem);\n\n  }\n\n  return feed;\n\n}\n\n\nRetrieving just the markdown works great if you're using the feed to integrate with dev.to or medium since both of these sites use markdown in their editors.\n\n@nuxtjs/sitemap\n\nYou may want to generate a sitemap that includes links to all of your posts. You can do this similarly to how you generated the feed.\n\nExample 1\n\nThe sitemap module should always be declared last so that routes created by other modules can be included. After declaring the module you must configure the sitemap by adding the sitemap configuration object to the nuxt.config.js. You must supply the hostname, and you can optionally include any routes that are dynamically generated from nuxt content. The routes property accepts an async function that returns an array of URLs.\n\nconst createSitemapRoutes = async () => {\n\n  let routes = [];\n\n  const { $content } = require('@nuxt/content')\n\n  if (posts === null || posts.length === 0)\n\n    posts = await $content('blog').fetch();\n\n  for (const post of posts) {\n\n    routes.push(`blog/${post.slug}`);\n\n  }\n\n  return routes;\n\n}\n\n\n\nexport default {\n\n...\n\n  modules: [\n\n    '@nuxt/content',\n\n    '@nuxtjs/sitemap'\n\n  ],\n\n  sitemap: {\n\n    hostname: 'https://my-domain-name.com',\n\n    gzip: true,\n\n    routes: createSitemapRoutes\n\n  },\n\n...\n\n}\n\nForestry CMS\n\nYou can integrate Nuxt Content with Forestry in a few steps.\n\nWe recommend to take a look at this tutorial made by Pascal CauhÃ©pÃ©\nðŸ‘‰ Â https://nuxt-content-and-forestry.netlify.app\n\nÂ "
  },
  {
    "title": "TailwindCSS - Nuxt Content V1",
    "url": "https://content.nuxt.com/v1/examples/tailwindcss-typography",
    "html": "Examples\n\nTailwindCSS\n\nLive example of Nuxt Content with TailwindCSS Typography plugin on CodeSandbox.\n\nBasic Usage\n\nLive example of basic usage of Nuxt Content on CodeSandbox.\n\nDocs Theme\n\nLive example of Nuxt Content docs theme on CodeSandbox."
  },
  {
    "title": "Snippets - Nuxt Content V1",
    "url": "https://content.nuxt.com/v1/community/snippets/",
    "html": "Community\n\nSnippets\n\nLearn how to implement @nuxt/content into your app with these code snippets.\n\nUsage\nasyncData\nexport default {\n\n  async asyncData({ $content, params }) {\n\n    const article = await $content('articles', params.slug).fetch()\n\n\n\n    return {\n\n      article\n\n    }\n\n  }\n\n}\n\nhead\n\nAdd dynamic metas based on title and description defined in the front-matter:\n\nexport default {\n\n  async asyncData({ $content, params }) {\n\n    const article = await $content('articles', params.slug).fetch()\n\n\n\n    return {\n\n      article\n\n    }\n\n  },\n\n  head() {\n\n    return {\n\n      title: this.article.title,\n\n      meta: [\n\n        { hid: 'description', name: 'description', content: this.article.description },\n\n        // Open Graph\n\n        { hid: 'og:title', property: 'og:title', content: this.article.title },\n\n        { hid: 'og:description', property: 'og:description', content: this.article.description },\n\n        // Twitter Card\n\n        { hid: 'twitter:title', name: 'twitter:title', content: this.article.title },\n\n        { hid: 'twitter:description', name: 'twitter:description', content: this.article.description }\n\n      ]\n\n    }\n\n  }\n\n}\n\nFeatures\nSearch\n\nAdd a search input component by using watch:\n\n<template>\n\n  <div>\n\n    <input v-model=\"query\" type=\"search\" autocomplete=\"off\" />\n\n\n\n    <ul v-if=\"articles.length\">\n\n      <li v-for=\"article of articles\" :key=\"article.slug\">\n\n        <NuxtLink :to=\"{ name: 'blog-slug', params: { slug: article.slug } }\">{{ article.title }}</NuxtLink>\n\n      </li>\n\n    </ul>\n\n  </div>\n\n</template>\n\n\n\n<script>\n\nexport default {\n\n  data () {\n\n    return {\n\n      query: '',\n\n      articles: []\n\n    }\n\n  },\n\n  watch: {\n\n    async query (query) {\n\n      if (!query) {\n\n        this.articles = []\n\n        return\n\n      }\n\n\n\n      this.articles = await this.$content('articles')\n\n        .only(['title', 'slug'])\n\n        .sortBy('createdAt', 'asc')\n\n        .limit(12)\n\n        .search(query)\n\n        .fetch()\n\n    }\n\n  }\n\n}\n\n</script>\n\n\nCheck out the search documentation\n\nPrev and Next\n\nAdd previous and next links using the surround method:\n\n<template>\n\n  <div>\n\n    <NuxtLink v-if=\"prev\" :to=\"{ name: 'blog-slug', params: { slug: prev.slug } }\">\n\n      {{ prev.title }}\n\n    </NuxtLink>\n\n\n\n    <NuxtLink v-if=\"next\" :to=\"{ name: 'blog-slug', params: { slug: next.slug } }\">\n\n      {{ next.title }}\n\n    </NuxtLink>\n\n  </div>\n\n</template>\n\n\n\n<script>\n\nexport default {\n\n  async asyncData({ $content, params }) {\n\n    const [prev, next] = await $content('articles')\n\n      .only(['title', 'slug'])\n\n      .sortBy('createdAt', 'asc')\n\n      .surround(params.slug)\n\n      .fetch()\n\n\n\n    return {\n\n      prev,\n\n      next\n\n    }\n\n  }\n\n}\n\n</script>\n\n\nIf more than one document has the same slug, you should set path as the first argument of the surround method, instead of slug. This is because Nuxt Content finds previous and next documents based on the one that matched first.\n\nFor example, if you sort documents according to position, the lower-positioned document will be always used for calculation, even when the current page is showing the higer-positioned document.\n\nCheck out the surround documentation\n\nCase-Insensitive Sorting\n\nIt is needed to work around Nuxt Content's case-sensitive sorting, to add extra properties to documents, whose value is lower-cased.\n\nnuxt.config.js\nexport default {\n\n  hooks: {\n\n    'content:file:beforeInsert': (document) => {\n\n      if (document.extension === '.md') {\n\n        Object.entries(document).forEach(([key, value]) => {\n\n          const _key = `case_insensitive__${key}`; // prefix is arbitrary\n\n\n\n          if (!document[_key] && typeof value === 'string') {\n\n            document[_key] = value.toLocaleLowerCase();\n\n          }\n\n        });\n\n      }\n\n    }\n\n  }\n\n};\n\n\nThen, call sortBy method with the extra prop's key by which to sort.\n\nexport default {\n\n  async asyncData({ $content, params }) {\n\n    const articles = await $content('articles', params.slug)\n\n      .sortBy('case_insensitive__title', 'asc') // Set prefixed prop\n\n      .fetch()\n\n\n\n    return {\n\n      articles\n\n    }\n\n  }\n\n}\n\n\nCheck out the sortBy documentation\n\nTable of contents\n\nAdd a table of contents by looping over our array of toc and use the id to link to it and the text to show the title. We can use the depth to style the titles differently:\n\n<template>\n\n  <ul>\n\n    <li\n\n      v-for=\"link of article.toc\"\n\n      :key=\"link.id\"\n\n      :class=\"{ 'toc2': link.depth === 2, 'toc3': link.depth === 3 }\"\n\n    >\n\n      <NuxtLink :to=\"`#${link.id}`\">{{ link.text }}</NuxtLink>\n\n    </li>\n\n  </ul>\n\n</template>\n\n\n\n<script>\n\nexport default {\n\n  async asyncData({ $content, params }) {\n\n    const article = await $content('articles', params.slug)\n\n      .fetch()\n\n\n\n    return {\n\n      article\n\n    }\n\n  }\n\n}\n\n</script>\n\n\nCheck out the Table of contents documentation\n\nDynamic routing\n\nLet's say you want to create an app with routes following the content/ file structure. You can do so by creating a pages/_.vue component:\n\npages/_.vue\n<script>\n\nexport default {\n\n  async asyncData ({ $content, app, params, error }) {\n\n    const path = `/${params.pathMatch || 'index'}`\n\n    const [article] = await $content({ deep: true }).where({ path }).fetch()\n\n\n\n    if (!article) {\n\n      return error({ statusCode: 404, message: 'Article not found' })\n\n    }\n\n\n\n    return {\n\n      article\n\n    }\n\n  }\n\n}\n\n</script>\n\n\nThis way, if you go the /themes/docs route, it will display the content/themes/docs.md file. If you need an index page for your directories, you need to create a file with the same name as the directory:\n\ncontent/\n\n  themes/\n\n    docs.md\n\n  themes.md\n\n\nDon't forget to prefix your calls with the current locale if you're using nuxt-i18n.\n\nCustom Highlighter\nHighlight.js\nnuxt.config.js\nimport highlightjs from 'highlight.js'\n\n\n\nconst wrap = (code, lang) => `<pre><code class=\"hljs ${lang}\">${code}</code></pre>`\n\n\n\nexport default {\n\n  // Complete themes: https://github.com/highlightjs/highlight.js/tree/main/src/styles\n\n  css: ['highlight.js/styles/nord.css'],\n\n\n\n  modules: ['@nuxt/content'],\n\n\n\n  content: {\n\n    markdown: {\n\n      highlighter(rawCode, lang) {\n\n        if (!lang) {\n\n          return wrap(highlightjs.highlightAuto(rawCode).value, lang)\n\n        }\n\n        return wrap(highlightjs.highlight(rawCode, { language: lang }).value, lang)\n\n      }\n\n    }\n\n  }\n\n}\n\nShiki\n\nShiki is syntax highlighter that uses TexMate grammar and colors the tokens with VS Code themes. It will generate HTML that looks like exactly your code in VS Code.\n\nYou don't need to add custom styling, because Shiki will inline it in the HTML.\n\nnuxt.config.js\nimport shiki from 'shiki'\n\n\n\nexport default {\n\n  modules: ['@nuxt/content'],\n\n\n\n  content: {\n\n    markdown: {\n\n      async highlighter() {\n\n        const highlighter = await shiki.getHighlighter({\n\n          // Complete themes: https://github.com/shikijs/shiki/tree/main/packages/shiki/themes\n\n          theme: 'nord'\n\n        })\n\n        return (rawCode, lang) => {\n\n          return highlighter.codeToHtml(rawCode, lang)\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\nShiki Twoslash\n\nTwoslash is a markup format for TypeScript code. Internally, Twoslash uses the TypeScript compiler to generate rich highlight info.\n\nTo get a better idea of how Twoslash works, you can go over to the Official TypeScript Documentation and hover over some code examples there.\n\nYou can achieve the same result by using Shiki Twoslash. This package is also the one that powers the Official TypeScript Documentation.\n\nnuxt.config.js\nimport {\n\n  createShikiHighlighter,\n\n  runTwoSlash,\n\n  renderCodeToHTML\n\n} from 'shiki-twoslash'\n\n\n\nexport default {\n\n  modules: ['@nuxt/content'],\n\n\n\n  content: {\n\n    markdown: {\n\n      async highlighter() {\n\n        const highlighter = await createShikiHighlighter({\n\n          // Complete themes: https://github.com/shikijs/shiki/tree/main/packages/shiki/themes\n\n          theme: 'nord'\n\n        })\n\n        return (rawCode, lang) => {\n\n          const twoslashResults = runTwoSlash(rawCode, lang)\n\n          return renderCodeToHTML(\n\n            twoslashResults.code,\n\n            lang,\n\n            ['twoslash'],\n\n            {},\n\n            highlighter,\n\n            twoslashResults\n\n          )\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\nRemark Plugin\n\nNuxt Content uses remark under the hood to process markdown documents. Creating remark plugins is a way to manipulate documents and add new features.\n\nList all contributors\n\nLet's say you want to list all contributors of the project in a document. You can create a plugin that fetches all contributors and injects them into the document data.\n\nCreate the plugin. This plugin fetches the contributors if fetchContributors is set to true\n~~/plugins/contributors.js\nconst fetch = require('node-fetch')\n\n\n\nmodule.exports = function () {\n\n  return async (tree, { data }) => {\n\n    if (data.fetchContributors) {\n\n      const contributors = await fetch(\n\n        'https://api.github.com/repos/nuxt/content/contributors'\n\n      ).then(res => res.json())\n\n      .then(res => res.map(({ login }) => login))\n\n\n\n      data.$contributors = [...new Set(contributors)]\n\n    }\n\n    return tree\n\n  }\n\n}\n\nRegister plugin in Nuxt config\nnuxt.config.js\nexport default {\n\n  contents: {\n\n    markdown: {\n\n      remarkPlugins: [\n\n        '~~/plugins/contributors.js'\n\n      ]\n\n    }\n\n  }\n\n}\n\nCreate a simple component to show contributors\n~~/components/List.vue\n<template>\n\n  <ul>\n\n    <li v-for=\"(item, i) in items\" :key=\"i\">\n\n      {{ item }}\n\n    </li>\n\n  </ul>\n\n</template>\n\n\n\n<script>\n\nexport default {\n\n  props: {\n\n    items: {\n\n      type: Array,\n\n      default: () => []\n\n    }\n\n  }\n\n}\n\nFinally use the components and mark the document to fetch the contributors\ndocument.md\n---\n\ntitle: Nuxt Content\n\nfetchContributors: true\n\n---\n\n\n\n## Contributors\n\n\n\n<list :items=\"$contributors\"></list>\n\n\nDocs Theme\n\nLive example of Nuxt Content docs theme on CodeSandbox.\n\nIntegrations\n\nLearn how to use @nuxt/content with other modules."
  },
  {
    "title": "Advanced - Nuxt Content V1",
    "url": "https://content.nuxt.com/v1/getting-started/advanced/",
    "html": "Getting Started\n\nAdvanced\n\nLearn advanced usage of @nuxt/content module.\n\nProgrammatic Usage\n\n$content is accessible from @nuxt/content.\n\nBeware that you can access it only after the module has been loaded by Nuxt. require('@nuxt/content') should happen in hooks or internal Nuxt methods.\n\nexport default {\n\n  modules: [\n\n    '@nuxt/content'\n\n  ],\n\n  generate: {\n\n    async ready () {\n\n      const { $content } = require('@nuxt/content')\n\n      const files = await $content().only(['slug']).fetch()\n\n      console.log(files)\n\n    }\n\n  }\n\n}\n\nStatic Site Generation\n\nSince Nuxt 2.14+, nuxt generate has a crawler feature integrated which will crawl all your links and generate your routes based on those links. Therefore you do not need to do anything in order for your dynamic routes to be crawled.\n\nAlso, nuxt generate will automagically skip webpack build step when no code has been changed and use the previous build using cache. The content module integrates with this feature to ignore changes inside the content/ folder. In other terms, when changing the content of your site and deploying, the build will be skipped.\n\nLearn more in this article.\n\nWhen using Nuxt <= 2.12, you might need to specify the dynamic routes with generate.routes\n\nExample\n\nnuxt.config.js\nexport default {\n\n  modules: [\n\n    '@nuxt/content'\n\n  ],\n\n  generate: {\n\n    async routes () {\n\n      const { $content } = require('@nuxt/content')\n\n      const files = await $content({ deep: true }).only(['path']).fetch()\n\n\n\n      return files.map(file => file.path === '/index' ? '/' : file.path)\n\n    }\n\n  }\n\n}\n\n\nRecommended to use Nuxt 2.14+ with nuxt generate because it's awesome!\n\nHooks\n\nThe module adds some hooks you can use:\n\ncontent:file:beforeParse\n\nAllows you to modify the contents of a file before it is handled by the parsers.\n\nArguments:\n\nfile\nType: object\nProperties:\npath: string\nextension: string (ex: .md)\ndata: string\n\nExample\n\nChanging all appearances of react to vue in all Markdown files:\n\nnuxt.config.js\nhooks: {\n\n  'content:file:beforeParse': (file) => {\n\n    if (file.extension !== '.md') return\n\n    file.data = file.data.replace(/react/g, 'vue')\n\n  }\n\n}\n\ncontent:file:beforeInsert\n\nAllows you to add data to a document before it is stored.\n\nArguments:\n\ndocument\nType: object\nProperties:\nSee writing content\ndatabase\nType: object\nProperties:\nSee type definition\n\nExample\n\nWhen building a blog, you can use file:beforeInsert to add readingTime to a document using reading-time.\n\ntext is the body content of a markdown file before it is transformed to JSON AST. You can use at this point, but it is not returned by the API.\n\nnuxt.config.js\nexport default {\n\n  modules: [,\n\n    '@nuxt/content'\n\n  ],\n\n  hooks: {\n\n    'content:file:beforeInsert': (document) => {\n\n      if (document.extension === '.md') {\n\n        const { time } = require('reading-time')(document.text)\n\n\n\n        document.readingTime = time\n\n      }\n\n    }\n\n  }\n\n}\n\n\nExample\n\nYou might want to parse markdown inside a .json file. You can access the parsers from the database object:\n\nnuxt.config.js\nexport default {\n\n  modules: [,\n\n    '@nuxt/content'\n\n  ],\n\n  hooks: {\n\n    'content:file:beforeInsert': async (document, database) => {\n\n      if (document.extension === '.json' && document.body) {\n\n        const data = await database.markdown.toJSON(document.body)\n\n\n\n        Object.assign(document, data)\n\n      }\n\n    }\n\n  }\n\n}\n\ncontent:options\n\nExtend the content options, useful for modules that wants to read content options when normalized and apply updated to it.\n\nArguments:\n\noptions\nType: object\nProperties:\nSee configuration\n\nExample\n\nnuxt.config.js\nexport default {\n\n  modules: [,\n\n    '@nuxt/content'\n\n  ],\n\n  hooks: {\n\n    'content:options': (options) => {\n\n      console.log('Content options:', options)\n\n    }\n\n  }\n\n}\n\nHandling Hot Reload\n\nWhen you are in development mode, the module will automatically call nuxtServerInit store action (if defined) and $nuxt.refresh() to refresh the current page.\n\nIn case you want to listen to the event to do something more, you can listen on content:update event on client-side using $nuxt.$on('content:update'):\n\nplugins/update.client.js\nexport default function ({ store }) {\n\n  // Only in development\n\n  if (process.dev) {\n\n    window.onNuxtReady(($nuxt) => {\n\n      $nuxt.$on('content:update', ({ event, path }) => {\n\n        // Refresh the store categories\n\n        store.dispatch('fetchCategories')\n\n      })\n\n    })\n\n  }\n\n}\n\n\nAnd then add your plugin in your nuxt.config.js:\n\nnuxt.config.js\nexport default {\n\n  plugins: [\n\n    '@/plugins/update.client.js'\n\n  ]\n\n}\n\n\nNow everytime you will update a file in your content/ directory, it will also dispatch the fetchCategories method. This documentation uses it actually. You can learn more by looking at plugins/init.js.\n\nAPI Endpoint\n\nThis module exposes an API endpoint in development so you can easily see the JSON of each directory or file, it is available on http://localhost:3000/_content/. The prefix is _content by default and can be configured with the apiPrefix property.\n\nExample\n\n-| content/\n\n---| articles/\n\n------| hello-world.md\n\n---| index.md\n\n---| settings.json\n\n\nWill expose on localhost:3000:\n\n/_content/articles: list the files in content/articles/\n/_content/articles/hello-world: get hello-world.md as JSON\n/_content/index: get index.md as JSON\n/_content/settings: get settings.json as JSON\n/_content: list index and settings\n\nThe endpoint is accessible on GET and POST request, so you can use query params: http://localhost:3000/_content/articles?only=title&only=description&limit=10.\n\nSince v1.4.0, this endpoint also supports where in query params:\n\nAll the keys that don't belong to any of the default ones will be applied to where\n\nhttp://localhost:3000/_content/articles?author=...\n\nYou can use $operators with _:\n\nhttp://localhost:3000/_content/articles?author_regex=...\n\nThis module uses LokiJS under the hood. You can check here for query examples.\n\nYou can use nested properties:\n\nhttp://localhost:3000/_content/products?categories.slug_contains=top\n\nYou can learn more about that endpoint in lib/middleware.js.\n\nConfiguration\n\nYou can configure @nuxt/content with the content property in your nuxt.config.js.\n\nBasic Usage\n\nLive example of basic usage of Nuxt Content on CodeSandbox."
  },
  {
    "title": "Displaying content - Nuxt Content V1",
    "url": "https://content.nuxt.com/v1/getting-started/displaying",
    "html": "Getting Started\n\nDisplaying content\n\nYou can use `<nuxt-content>` component directly in your template to display your Markdown.\n\nThis section is only for Markdown files.\nComponent\nPage Body\n\nYou can use <nuxt-content> component directly in your template to display the page body:\n\n<template>\n\n  <article>\n\n    <h1>{{ page.title }}</h1>\n\n    <nuxt-content :document=\"page\" />\n\n  </article>\n\n</template>\n\n\n\n<script>\n\nexport default {\n\n  async asyncData ({ $content }) {\n\n    const page = await $content('home').fetch()\n\n\n\n    return {\n\n      page\n\n    }\n\n  }\n\n}\n\n</script>\n\n\nProps:\n\ndocument:\nType: object\nrequired\ntag:\nType: string\n\nLearn more about what you can write in your markdown file in the writing content section.\n\nExcerpt\n\nIf you are utilizing the excerpt feature, you can display the content of your excerpt using the following model:\n\n<template>\n\n  <article>\n\n    <h1>{{ page.title }}</h1>\n\n    <nuxt-content :document=\"{ body: page.excerpt }\" />\n\n  </article>\n\n</template>\n\n\n\n<script>\n\nexport default {\n\n  async asyncData ({ $content }) {\n\n    const page = await $content('home').fetch()\n\n\n\n    return {\n\n      page\n\n    }\n\n  }\n\n}\n\n</script>\n\nRoot Element\n\n<nuxt-content> component will add a div element as the root of the content by default. You can change this by setting the tag prop. Below example will use article as the root element.\n\n<nuxt-content :document=\"doc\" tag=\"article\">\n\nStyle\n\nDepending on what you're using to design your app, you may need to write some style to properly display the markdown.\n\n<nuxt-content> component will automatically add a .nuxt-content class. You can use it to customize your styles:\n\n.nuxt-content h1 {\n\n  /* my custom h1 style */\n\n}\n\n\nYou can find an example in the theme-docs main.css file. You can also take a look at the TailwindCSS Typography plugin to style your markdown content like we do in the @nuxt/content-theme-docs.\n\nLive Editing\n\nAvailable in version >= v1.4.0\n\nIn development, you can edit your content by double-clicking on the <nuxt-content> component. A textarea will allow you to edit the content of the current file and will save it on the file-system.\n\nFetching content\n\nLearn how to fetch your static content with $content in your Nuxt.js project.\n\nConfiguration\n\nYou can configure @nuxt/content with the content property in your nuxt.config.js."
  },
  {
    "title": "Configuration - Nuxt Content V1",
    "url": "https://content.nuxt.com/v1/getting-started/configuration/",
    "html": "Getting Started\n\nConfiguration\n\nYou can configure @nuxt/content with the content property in your nuxt.config.js.\n\nYou can configure @nuxt/content with the content property in your nuxt.config.js.\n\nnuxt.config.js\nexport default {\n\n  content: {\n\n    // My custom configuration\n\n  }\n\n}\n\n\nBefore diving into the individual attributes, please have a look at the default settings of the module.\n\nMerging defaults\n\nYou can define every option either as function or as static value (primitives, objects, arrays, ...). If you use a function, the default value will be provided as the first argument.\n\nIf you don't use a function to define you properties, the module will try to merge them with the default values. This can be handy for markdown.remarkPlugins, markdown.rehypePlugins and so on because the defaults are quite sensible. If you don't want to have the defaults included, just use a function.\n\nProperties\napiPrefix\nType: string\nDefault: '/_content'\n\nRoute that will be used for client-side API calls and SSE.\n\nnuxt.config.js\ncontent: {\n\n  // $content api will be served on localhost:3000/content-api\n\n  apiPrefix: 'content-api'\n\n}\n\ndir\nType: string\nDefault: 'content'\n\nDirectory used for writing content. You can give an absolute path, if relative, it will be resolved with Nuxt srcDir.\n\nnuxt.config.js\ncontent: {\n\n  dir: 'my-content' // read content from my-content/\n\n}\n\nfullTextSearchFields\nType: Array\nDefault: ['title', 'description', 'slug', 'text']\n\nFields that needs to be indexed to be searchable, learn more about search here.\n\ntext is a special key that contains your Markdown before being parsed to AST.\n\nnuxt.config.js\ncontent: {\n\n  // Only search in title and description\n\n  fullTextSearchFields: ['title', 'description']\n\n}\n\nnestedProperties\nType Array\nDefault: []\nVersion: >= v1.3.0\n\nRegister nested properties to handle dot-notation and deep filtering.\n\nnuxt.config.js\ncontent: {\n\n  nestedProperties: ['categories.slug']\n\n}\n\nliveEdit\nType boolean\nDefault: true\nVersion: >= v1.5.0\n\nDisable live edit mode in development:\n\nnuxt.config.js\ncontent: {\n\n  liveEdit: false\n\n}\n\nmarkdown\n\nThis module uses remark and rehype under the hood to compile markdown files into JSON AST that will be stored into the body variable.\n\nThe following explanation is valid for both remarkPlugins and rehypePlugins\n\nTo configure how the module will parse Markdown, you can:\n\nAdd a new plugin to the defaults:\nnuxt.config.js\nexport default {\n\n  content: {\n\n    markdown: {\n\n      remarkPlugins: ['remark-emoji']\n\n    }\n\n  }\n\n}\n\nOverride the default plugins:\nnuxt.config.js\nexport default {\n\n  content: {\n\n    markdown: {\n\n      remarkPlugins: () => ['remark-emoji']\n\n    }\n\n  }\n\n}\n\nUse local plugins\nnuxt.config.js\nexport default {\n\n  content: {\n\n    markdown: {\n\n      remarkPlugins: [\n\n        '~/plugins/my-custom-remark-plugin.js'\n\n      ]\n\n    }\n\n  }\n\n}\n\nProvide options directly in the definition\nnuxt.config.js\nexport default {\n\n  content: {\n\n    markdown: {\n\n      remarkPlugins: [\n\n        ['remark-emoji', { emoticon: true }]\n\n      ]\n\n    }\n\n  }\n\n}\n\nProvide options using the name of the plugin in camelCase\nnuxt.config.js\nexport default {\n\n  content: {\n\n    markdown: {\n\n      // https://github.com/remarkjs/remark-external-links#options\n\n      remarkExternalLinks: {\n\n        target: '_self',\n\n        rel: 'nofollow'\n\n      }\n\n    }\n\n  }\n\n}\n\nWhen adding a new plugin, make sure to install it in your dependencies:\nYarn\nNPM\nyarn add remark-emoji\n\nnuxt.config.js\nexport default {\n\n  content: {\n\n    markdown: {\n\n      remarkPlugins: ['remark-emoji']\n\n    }\n\n  }\n\n}\n\nmarkdown.tocDepth\nType: number\nDefault: 3\nVersion: >= v1.11.0\n\nYou can change maximum heading depth to include in the table of contents.\n\nmarkdown.remarkPlugins\nType: Array\nDefault: ['remark-squeeze-paragraphs', 'remark-slug', 'remark-autolink-headings', 'remark-external-links', 'remark-footnotes']\nVersion: >= v1.4.0\n\nYou can take a look at the list of remark plugins.\n\nmarkdown.rehypePlugins\nType: Array\nDefault: ['rehype-minify-whitespace', 'rehype-sort-attribute-values', 'rehype-sort-attributes', 'rehype-raw']\nVersion: >= v1.4.0\n\nYou can take a look at the list of rehype plugins.\n\nmarkdown.basePlugins\nDeprecated. Use markdown.remarkPlugins as a function instead.\nmarkdown.plugins\nDeprecated. Use markdown.remarkPlugins as an array instead.\nmarkdown.prism.theme\nType: string\nDefault: 'prismjs/themes/prism.css'\n\nThis module handles code highlighting in markdown content using PrismJS.\n\nIt automatically pushes the desired PrismJS theme in your Nuxt.js config, so if you want to use a different theme than the default one, for example prism-themes:\n\nYarn\nNPM\nyarn add prism-themes\n\nnuxt.config.js\ncontent: {\n\n  markdown: {\n\n    prism: {\n\n      theme: 'prism-themes/themes/prism-material-oceanic.css'\n\n    }\n\n  }\n\n}\n\n\nTo disable the inclusion of the theme, set prism to false:\n\nnuxt.config.js\ncontent: {\n\n  markdown: {\n\n    prism: {\n\n      theme: false\n\n    }\n\n  }\n\n}\n\nmarkdown.highlighter\nType: Highlighter | PromisedHighlighter\nVersion: >=1.9.0\n\nYou can change the default code highlighter in markdown content by using this option. As an example, we use highlight.js.\n\nnuxt.config.js\nimport highlightjs from 'highlight.js'\n\n\n\nexport default {\n\n  content: {\n\n    markdown: {\n\n      highlighter(rawCode, lang) {\n\n        const highlightedCode = highlightjs.highlight(rawCode, { language: lang }).value\n\n\n\n        // We need to create a wrapper, because\n\n        // the returned code from highlight.js\n\n        // is only the highlighted code.\n\n        return `<pre><code class=\"hljs ${lang}\">${highlightedCode}</code></pre>`\n\n      }\n\n    }\n\n  }\n\n}\n\n\nWhen markdown.highlighter is defined, it will automatically disable the inclusion of the Prism theme.\n\nDon't forget to add the corresponding style manually if you define markdown.highlighter.\n\nIt returns a string or HAST (Hypertext Abstract Syntax Tree). You can build HAST by passing the 4th argument. It consits of h, node and u.\n\nnuxt.config.js\nimport highlightjs from 'highlight.js'\n\n\n\nexport default {\n\n  content: {\n\n    markdown: {\n\n      highlighter(rawCode, lang, _, { h, node, u }) {\n\n        const highlightedCode = highlightjs.highlight(rawCode, { language: lang }).value\n\n\n\n        // We can use ast helper to create the wrapper\n\n        const childs = []\n\n        childs.push(\n\n          h(node, 'pre', [\n\n            h(node, 'code', { className: ['hljs', lang] }, [\n\n              u('raw', highlightedCode)\n\n            ])\n\n          ])\n\n        )\n\n\n\n        return h(\n\n          node,\n\n          'div',\n\n          { className: 'highlighted-with-highlightjs' },\n\n          childs\n\n        )\n\n      }\n\n    }\n\n  }\n\n}\n\n\nAfter rendering with the nuxt-content component, it will look like this:\n\n<div class=\"highlighted-with-highlightjs\">\n\n  <pre class=\"language-<lang>\">\n\n    <code>\n\n      ...\n\n    </code>\n\n  </pre>\n\n</div>\n\n\nYou can also get the line highlight and file name value from the 3rd argument. Combining them with the HAST, you can pass it to the client.\n\nnuxt.config.js\nimport highlightjs from 'highlight.js'\n\n\n\nexport default {\n\n  content: {\n\n    markdown: {\n\n      highlighter(rawCode, lang, { lineHighlights, fileName }, { h, node, u }) {\n\n        const highlightedCode = highlightjs.highlight(rawCode, { language: lang }).value\n\n\n\n        const childs = []\n\n        const props = {\n\n          className: `language-${lang}`,\n\n          dataLine: lineHighlights,\n\n          dataFileName: fileName\n\n        }\n\n        childs.push(\n\n          h(node, 'pre', [\n\n            h(node, 'code', props, [\n\n              u('raw', highlightedCode)\n\n            ])\n\n          ])\n\n        )\n\n\n\n        return h(\n\n          node,\n\n          'div',\n\n          { className: 'highlighted-with-highlightjs' },\n\n          childs\n\n        )\n\n      }\n\n    }\n\n  }\n\n}\n\n\nThen the returned code will look like this:\n\n<div class=\"highlighted-with-highlightjs\">\n\n  <pre class=\"language-<lang>\" data-line=\"<line>\" data-file-name=\"<file-name>\">\n\n    <code>\n\n      ...\n\n    </code>\n\n  </pre>\n\n</div>\n\n\nYou can learn more about h, node and u from mdast-util-to-hast, Universal Syntax Tree and unist-builder\n\nIf you need to get the highlighter from promised-returned-package/function, you can do it this way:\n\nnuxt.config.js\nimport { getHighlighter } from 'example-highlighter'\n\n\n\nexport default {\n\n  content: {\n\n    markdown: {\n\n      async highlighter() {\n\n        const highlighter = await getHighlighter()\n\n\n\n        return (rawCode, lang) => {\n\n          return highlighter.highlight(rawCode, { language: lang })\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\n\n\nYou can head over to Snippets - Custom Highlighter section to see more example.\n\nyaml\nType: object\nDefault: {}\n\nThis module uses js-yaml to parse .yaml, .yml files. You can check here for options.\n\nNote that we force json: true option.\n\nxml\nType: object\nDefault: {}\n\nThis module uses xml2js to parse .xml files. You can check here for options.\n\ncsv\nType: object\nDefault: {}\n\nThis module uses node-csvtojson to parse csv files. You can check here for options.\n\nextendParser\nType: object\nDefault {}\n\nWith this option you can define your own parsers for other file types. Also you can overwrite the default parser!\n\nTo add your custom parser write a function that gets as an argument the content of the file and returns the extracted data.\n\nExample\n\nnuxt.config.js\nconst parseTxt = file => file.split('\\n').map(line => line.trim())\n\n\n\n// in Config:\n\n\n\n{\n\n  extendParser: {\n\n    '.txt': parseTxt\n\n  }\n\n}\n\neditor\n\nYou can provide a custom editor for editing your markdown files in development. Set the editor option to a path to your editor component. The code of the default editor you can find here.\n\nnuxt.config.js\ncontent: {\n\n  editor: '~/path/to/editor/component.vue'\n\n}\n\n\nYour component should implement the following:\n\nv-model for getting the markdown code.\nprop isEditing is a boolean with the information if the editing is started and the component is shown. (this is optional)\nwhen finished editing your component has to emit endEdit\n\nYou should be aware that you get the full markdown file content so this includes the front-matter. You can use gray-matter to split and join the markdown and the front-matter.\n\nuseCache\nType: boolean\nDefault: false\n\nWhen true, the production server (nuxt start) will use cached version of the content (generated after running nuxt build) instead of parsing files. This improves app startup time, but makes app unaware of any content changes.\n\nDefaults\nnuxt.config.js\nexport default {\n\n  content: {\n\n    editor: '~/.nuxt/content/editor.vue',\n\n    apiPrefix: '_content',\n\n    dir: 'content',\n\n    fullTextSearchFields: ['title', 'description', 'slug', 'text'],\n\n    nestedProperties: [],\n\n    liveEdit: true,\n\n    useCache: false,\n\n    markdown: {\n\n      remarkPlugins: [\n\n        'remark-squeeze-paragraphs',\n\n        'remark-slug',\n\n        'remark-autolink-headings',\n\n        'remark-external-links',\n\n        'remark-footnotes'\n\n      ],\n\n      rehypePlugins: [\n\n        'rehype-minify-whitespace',\n\n        'rehype-sort-attribute-values',\n\n        'rehype-sort-attributes',\n\n        'rehype-raw'\n\n      ],\n\n      prism: {\n\n        theme: 'prismjs/themes/prism.css'\n\n      }\n\n    },\n\n    yaml: {},\n\n    csv: {},\n\n    xml: {},\n\n    extendParser: {}\n\n  }\n\n}\n\n\nDisplaying content\n\nYou can use `<nuxt-content>` component directly in your template to display your Markdown.\n\nAdvanced\n\nLearn advanced usage of @nuxt/content module."
  },
  {
    "title": "Fetching content - Nuxt Content V1",
    "url": "https://content.nuxt.com/v1/getting-started/fetching/",
    "html": "Getting Started\n\nFetching content\n\nLearn how to fetch your static content with $content in your Nuxt.js project.\n\nThis module globally injects $content instance, meaning that you can access it anywhere using this.$content. For plugins, asyncData, nuxtServerInit and Middleware, you can access it from context.$content.\n\nMethods\n$content(path, options?)\npath\nType: string\nDefault: /\noptions\nType: object\nDefault: {}\nVersion: >= v1.3.0\noptions.deep\nType: boolean\nDefault: false\nVersion: >= v1.3.0\nFetch files from subdirectories\noptions.text\nType: boolean\nDefault: false\nVersion: >= v1.4.0\nReturns the original markdown content in a text variable\nReturns a chain sequence\n\nYou can also give multiple arguments: $content('articles', params.slug) will be translated to /articles/${params.slug}\n\npath can be a file or a directory. If path is a file, fetch() will return an object, if it's a directory it will return an Array.\n\nAll the methods below can be chained and return a chain sequence, except fetch which returns a Promise.\n\nonly(keys)\nkeys\nType: Array | string\nrequired\n\nSelect a subset of fields.\n\nconst { title } = await this.$content('article-1').only(['title']).fetch()\n\nwithout(keys)\nkeys\nType: Array | string\nrequired\n\nRemove a subset of fields.\n\nconst { title, ...propsWithoutBody } = await this.$content('article-1').without(['body']).fetch()\n\nwhere(query)\nquery\nType: object\nrequired\n\nFilter results by query.\n\nWhere queries are based on subset of mongo query syntax, it handles for example: $eq, $ne, $gt, $gte, $lt, $lte, $in, ...\n\n// implicit (assumes $eq operator)\n\nconst articles = await this.$content('articles').where({ title: 'Home' }).fetch()\n\n// explicit $eq\n\nconst articles = await this.$content('articles').where({ title: { $eq: 'Home' } }).fetch()\n\n\n\n// $gt\n\nconst articles = await this.$content('articles').where({ age: { $gt: 18 } }).fetch()\n\n// $in\n\nconst articles = await this.$content('articles').where({ name: { $in: ['odin', 'thor'] } }).fetch()\n\n\nIn order to filter in objects and array you need to enable nestedProperties, see configuration.\n\nconst products = await this.$content('products').where({ 'categories.slug': { $contains: 'top' } }).fetch()\n\n\n\nconst products = await this.$content('products').where({ 'categories.slug': { $contains: ['top', 'woman'] } }).fetch()\n\n\nThis module uses LokiJS under the hood, you can check for query examples.\n\nsortBy(key, direction)\nkey\nType: string\nrequired\ndirection\nType: string\nValue: 'asc' or 'desc'\nDefault: 'asc'\n\nSort results by key.\n\nconst articles = await this.$content('articles').sortBy('title').fetch()\n\n\nCan be chained multiple times to sort on multiple fields.\n\nsortBy method does case-sensitive sort, which is currently not configurable.\n\nIf you need case-insensitive sorting, check out this snippet on how to work around it.\n\nlimit(n)\nn\nType: string | number\nrequired\n\nLimit number of results.\n\n// fetch only 5 articles\n\nconst articles = await this.$content('articles').limit(5).fetch()\n\nskip(n)\nn\nType: string | number\nrequired\n\nSkip results.\n\n// fetch the next 5 articles\n\nconst articles = await this.$content('articles').skip(5).limit(5).fetch()\n\nsearch(field, value)\nfield\nType: string\nrequired\nvalue\nType: string\n\nPerforms a full-text search on a field. value is optional, in this case field is the value and search will be performed on all defined full-text search fields.\n\nThe fields you want to search on must be defined in options in order to be indexed, see configuration.\n\nUsing an empty string as parameter will skip the search.\n\n// Search on field title\n\nconst articles = await this.$content('articles').search('title', 'welcome').fetch()\n\n// Search on all pre-defined fields\n\nconst articles = await this.$content('articles').search('welcome').fetch()\n\n// Search will be skipped if the search string is empty\n\nconst articles = await this.$content('articles').search('').fetch()\n\n\nCheck out this snippet on how to implement search into your app\n\nsurround(slugOrPath, options)\nslugOrPath\nType: string\nrequired\noptions\nType: object\nDefault: { before: 1, after: 1}\n\nGet prev and next results around a specific slug or path.\n\nYou will always obtain an array of fixed length filled with the maching document or null.\n\nconst [prev, next] = await this.$content('articles')\n\n  .only(['title', 'path'])\n\n  .sortBy('date')\n\n  .where({ isArchived: false })\n\n  .surround('article-2')\n\n  .fetch()\n\n\n\n// Returns\n\n[\n\n  {\n\n    title: 'Article 1',\n\n    path: 'article-1'\n\n  },\n\n  null // no article-3 here\n\n]\n\n\nsearch, limit and skip are ineffective when using this method.\n\nGetting results based on path is only supported since v1.12.0\n\nCheck out this snippet on how to implement prev and next links into your app\n\nfetch()\nReturns: Promise<object> | Promise<Array>\n\nEnds the chain sequence and collects data.\n\ncatch()\n\nChecks if the .md file exists in content directory or not.\n\nIt should be inserted after the fetch().\n\nExample\nconst articles = await this.$content('articles')\n\n  .only(['title', 'date', 'authors'])\n\n  .sortBy('date', 'asc')\n\n  .limit(5)\n\n  .skip(10)\n\n  .where({\n\n    tags: 'testing',\n\n    isArchived: false,\n\n    date: { $gt: new Date('2020-03-31') },\n\n    rating: { $gte: 3 }\n\n  })\n\n  .search('welcome')\n\n  .fetch()\n\n  .catch((err) => {\n\n     error({ statusCode: 404, message: 'Page not found' })\n\n  })\n\n\nYou can check how to use the Content API in development.\n\nWriting content\n\nLearn how to write your content/, supporting Markdown, YAML, CSV and JSON.\n\nDisplaying content\n\nYou can use `<nuxt-content>` component directly in your template to display your Markdown."
  },
  {
    "title": "Introduction - Nuxt Content V1",
    "url": "https://content.nuxt.com/v1/getting-started/introduction",
    "html": "Getting Started\n\nIntroduction\n\nEmpower your NuxtJS application with the @nuxt/content module: write in a content/ directory and fetch your Markdown, JSON, YAML and CSV files through a MongoDB-like API, acting as a Git-based Headless CMS.\n\nFeatures\nBlazing fast hot reload in development\nVue components in Markdown\nFull-text search\nSupport static site generation with nuxt generate\nPowerful QueryBuilder API (MongoDB like)\nSyntax highlighting to code blocks in markdown files using PrismJS.\nTable of contents generation\nHandles Markdown, CSV, YAML, JSON(5), XML\nExtend with custom parsers\nExtend with hooks\nVideos\n\nDemonstration of using $content and <nuxt-content> to display Markdown pages:\n\nUsing $content() on a directory to list, filter and search content:\n\nTutorial\n\nCreate a blog with Nuxt Content\n\nTestimonials\n\nReally enjoy working with the @nuxt_js content module more and more. Especially from a developer perspective. The api is easy to learn and really powerful. Give it a try if you haven't already.\n\nâ€” Rasmus Langvad (@rlangvad) January 23, 2021\n\nAdding an FAQ to @TurnAudio using @nuxt_js nuxt/content. Really great module for organizing a little bit of content within your static website https://t.co/o2uA9Lvmuu\n\nâ€” Lee Martin (@leemartin) August 3, 2020\n\nWanted to try out @nuxt_js new content theme doc, was a blast!\n\nManaged to hack its interals to extend its Tailwind config with mine hihihi... pic.twitter.com/fuXXOBKXYE\n\nâ€” lihbr (@li_hbr) August 1, 2020\n\nOn an upper @nuxt_js is the most exciting thing in web for me right now, everything they put out is golden. The content module is phenomenal.\n\nâ€” Liam Hall - Three Bears (@wearethreebears) July 31, 2020\n\nI've been working on a new portfolio/blog today with @tailwindcss and @nuxt_js. I'm blown away by Nuxt Content.\n\nâ€” Cameron Baney (@cameronbaney) August 1, 2020\n\nDocs powered by the new @nuxt_js content plugin and stored in @Netlify what a time to be a developer\n\nâ€” Alfonso Bribiesca (@alfonsobries) July 30, 2020\n\nThe new vee-validate v4 documentation is using @nuxt_js content module and so far it is too damn good ðŸ”¥\n\nI like being able to create my own layouts and \"on this page\" and \"menu\" components, in other words, to be in full control ðŸŽ®\n\nâ€” Abdelrahman Awad (@logaretm) July 26, 2020\n\nDecided to build a blog with @nuxt_js content module. I mean, it's rapid and lightning quick to setup. Super nice experience thus far ðŸ‘Œ\n\nâ€” ð–Šð–—ð–‰ (@erd_xyz) July 23, 2020\n\nSitemap\n\nA sitemap file is useful for helping Google to better index your website, ensuring that the content you write can be visible in search results.\n\nInstallation\n\nInstall @nuxt/content in only two steps in your Nuxt project."
  },
  {
    "title": "Writing content - Nuxt Content V1",
    "url": "https://content.nuxt.com/v1/getting-started/writing/#excerpt",
    "html": "Getting Started\n\nWriting content\n\nLearn how to write your content/, supporting Markdown, YAML, CSV and JSON.\n\nFirst of all, create a content/ directory in your project:\n\ncontent/\n\n  articles/\n\n    article-1.md\n\n    article-2.md\n\n  home.md\n\n\nThis module will parse .md, .yaml, .yml, .csv, .json, .json5, .xml files and generate the following properties:\n\ndir\npath\nslug\nextension (ex: .md)\ncreatedAt\nupdatedAt\n\nThe createdAt and updatedAt properties are based on the file's actual created & updated datetime, but you can override them by defining your own createdAt and updatedAt values. This is especially useful if you are migrating your past blog posts where the createdAt can be months or years ago.\n\nMarkdown\n\nThis module converts your .md files into a JSON AST tree structure, stored in a body variable.\n\nMake sure to use the <nuxt-content> component to display the body of your markdown content, see displaying content.\n\nYou can check the basic syntax guide to help you master Markdown\n\nFront Matter\n\nYou can add a YAML front matter block to your markdown files. The front matter must be the first thing in the file and must take the form of valid YAML set between triple-dashed lines. Here is a basic example:\n\n---\n\ntitle: Introduction\n\ndescription: Learn how to use @nuxt/content.\n\n---\n\n\nThese variables will be injected into the document:\n\n{\n\n  body: Object\n\n  excerpt: Object\n\n  title: \"Introduction\"\n\n  description: \"Learn how to use @nuxt/content.\"\n\n  dir: \"/\"\n\n  extension: \".md\"\n\n  path: \"/index\"\n\n  slug: \"index\"\n\n  toc: Array\n\n  createdAt: DateTime\n\n  updatedAt: DateTime\n\n}\n\nExcerpt\n\nContent excerpt or summary can be extracted from the content using <!--more--> as a divider.\n\n---\n\ntitle: Introduction\n\n---\n\n\n\nLearn how to use @nuxt/content.\n\n<!--more-->\n\nFull amount of content beyond the more divider.\n\n\nDescription property will contain the excerpt content unless defined within the Front Matter props.\n\nBe careful to enter <!--more--> exactly; i.e., all lowercase and with no whitespace.\n\nExample variables will be injected into the document:\n\n{\n\n  body: Object\n\n  title: \"Introduction\"\n\n  description: \"Learn how to use @nuxt/content.\"\n\n  dir: \"/\"\n\n  excerpt: Object\n\n  extension: \".md\"\n\n  path: \"/index\"\n\n  slug: \"index\"\n\n  toc: Array\n\n  createdAt: DateTime\n\n  updatedAt: DateTime\n\n}\n\nHeadings\n\nThis module automatically adds an id and a link to each heading.\n\nSay we have the following markdown file:\n\nhome.md\n# Lorem ipsum\n\n## dolorâ€”sitâ€”amet\n\n### consectetur &amp; adipisicing\n\n#### elit\n\n##### elit\n\n\nIt will be transformed to its JSON AST structure, and by using the nuxt-content component, it will render HTML like:\n\n<h1 id=\"lorem-ipsum-\"><a href=\"#lorem-ipsum-\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>Lorem ipsum</h1>\n\n<h2 id=\"dolorsitamet\"><a href=\"#dolorsitamet\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>dolorâ€”sitâ€”amet</h2>\n\n<h3 id=\"consectetur--adipisicing\"><a href=\"#consectetur--adipisicing\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>consectetur &#x26; adipisicing</h3>\n\n<h4 id=\"elit\"><a href=\"#elit\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>elit</h4>\n\n<h5 id=\"elit-1\"><a href=\"#elit-1\" aria-hidden=\"true\" tabindex=\"-1\"><span class=\"icon icon-link\"></span></a>elit</h5>\n\n\nThe links in headings are empty and therefore hidden, so it's up to you to style them. For an example, try hovering one of the headers in these docs.\n\nLinks\n\nLinks are transformed to add valid target and rel attributes using remark-external-links. You can check here to learn how to configure this plugin.\n\nRelative links are also automatically transformed to nuxt-link to provide navigation between page components with enhanced performance through smart prefetching.\n\nHere is an example using external, relative, markdown and html links:\n\n---\n\ntitle: Home\n\n---\n\n\n\n## Links\n\n\n\n<nuxt-link to=\"/articles\">Nuxt Link to Blog</nuxt-link>\n\n\n\n<a href=\"/articles\">Html Link to Blog</a>\n\n\n\n[Markdown Link to Blog](/articles)\n\n\n\n<a href=\"https://v2.nuxt.com\">External link html</a>\n\n\n\n[External Link markdown](https://v2.nuxt.com)\n\nFootnotes\n\nThis module supports extended markdown syntax for footnotes using remark-footnotes. You can check here to learn how to configure this plugin.\n\nHere is an example using footnotes:\n\nHere's a simple footnote,[^1] and here's a longer one.[^bignote]\n\n\n\n[^1]: This is the first footnote.\n\n\n\n[^bignote]: Here's one with multiple paragraphs and code.\n\n\n\n    Indent paragraphs to include them in the footnote.\n\n\n\n    `{ my code }`\n\n\n\n    Add as many paragraphs as you like.\n\n\nYou can check the extended syntax guide for more information about footnotes.\n\nCodeblocks\n\nThis module automatically wraps codeblocks and applies PrismJS classes (see syntax highlighting).\n\nCodeblocks in Markdown are wrapped inside 3 backticks. Optionally, you can define the language of the codeblock to enable specific syntax highlighting.\n\nOriginally markdown did not support filenames or highlighting specific lines inside codeblocks. However, this module allows it with its own custom syntax:\n\nHighlighted line numbers inside curly braces\nFilename inside square brackets\n```js{1,3-5}[server.js]\nconst http = require('http')\nconst bodyParser = require('body-parser')\n\nhttp.createServer((req, res) => {\n  bodyParser.parse(req, (error, body) => {\n    res.end(body)\n  })\n}).listen(3000)\n```\n\n\nAfter rendering with the nuxt-content component, it should look like this (without the filename yet):\n\nserver.js\n<div class=\"nuxt-content-highlight\">\n\n  <span class=\"filename\">server.js</span>\n\n  <pre class=\"language-js\" data-line=\"1,3-5\">\n\n    <code>\n\n      ...\n\n    </code>\n\n  </pre>\n\n</div>\n\n\nLine numbers are added to the pre tag in data-line attribute.\n\nCheck out this comment on how to render prism line numbers.\n\nFilename will be converted to a span with a filename class. It's up to you to style it.\n\nCheck out the main.css file of this documentation for an example on styling filenames.\n\nSyntax highlighting\n\nIt supports by default code highlighting using PrismJS and injects the theme defined in options into your Nuxt.js app, see configuration.\n\nHTML\n\nYou can write HTML in your Markdown:\n\nhome.md\n---\n\ntitle: Home\n\n---\n\n\n\n## HTML\n\n\n\n<p><span class=\"note\">A mix of <em>Markdown</em> and <em>HTML</em>.</span></p>\n\n\nBeware that when placing Markdown inside a component, it must be preceded and followed by an empty line, otherwise the whole block is treated as custom HTML.\n\nThis won't work:\n\n<div class=\"note\">\n\n  *Markdown* and <em>HTML</em>.\n\n</div>\n\n\nBut this will:\n\n<div class=\"note\">\n\n\n\n  *Markdown* and <em>HTML</em>.\n\n\n\n</div>\n\n\nAs will this:\n\n<span class=\"note\">*Markdown* and <em>HTML</em>.</span>\n\nVue components\n\nYou can use global Vue components or locally registered in the page you're displaying your markdown.\n\nAn issue exists with locally registered components and live edit in development, since v1.5.0 you can disable it by setting liveEdit: false (see configuration).\n\nSince @nuxt/content operates under the assumption that all Markdown is provided by the author (and not via third-party user submission), sources are processed in full (tags included), with a couple of caveats from rehype-raw:\n\nYou need to refer to your components and their props by kebab case naming:\nUse <my-component :my-prop=\"myValue\"> instead of <MyComponent :myProp=\"myValue\">\n\nYou cannot use self-closing tags, i.e., this won't work:\n<my-component/>\n\n\nBut this will:\n\n<my-component></my-component>\n\n\nExample\n\nSay we have a Vue component called ExampleMultiselect.vue:\n\nhome.md\nPlease choose a *framework*:\n\n\n\n<example-multiselect :options=\"['Vue', 'React', 'Angular', 'Svelte']\"></example-multiselect>\n\n\nResult\n\nPlease choose a framework:\nNot working on content v2 docs!\n\nYou can also define the options for components in your front matter:\n\nhome.md\n---\n\nmultiselectOptions:\n\n  - VuePress\n\n  - Gridsome\n\n  - Nuxt\n\n---\n\n\n\n<example-multiselect :options=\"multiselectOptions\"></example-multiselect>\n\nNot working on content v2 docs!\n\nThese components will be rendered using the <nuxt-content> component, see displaying content.\n\nTemplates\n\nYou can use template tags for content distribution inside your Vue.js components:\n\n<my-component>\n\n  <template #named-slot>\n\n    <p>Named slot content.</p>\n\n  </template>\n\n</my-component>\n\n\nHowever, you cannot render dynamic content nor use slot props. I.e., this wont work:\n\n<my-component>\n\n  <template #named-slot=\"slotProps\">\n\n    <p>{{ slotProps.someProperty }}</p>\n\n  </template>\n\n</my-component>\n\nGlobal components\n\nSince v1.4.0 and Nuxt v2.13.0, you can now put your components in components/global/ directory so you don't have to import them in your pages.\n\ncomponents/\n\n  global/\n\n    Hello.vue\n\ncontent/\n\n  home.md\n\n\nThen in content/home.md, you can use <hello></hello> component without having to worry about importing it in your page.\n\nTable of contents\n\nWhen fetching a document, we have access to a toc property which is an array of all the titles. Each title has an id so that it is possible to link to, a depth which is the type of heading it is. Only h2 and h3 titles are used for the toc. There is also a text property which is the text of the title.\n\n{\n\n  \"toc\": [{\n\n    \"id\": \"welcome\",\n\n    \"depth\": 2,\n\n    \"text\": \"Welcome!\"\n\n  }]\n\n}\n\n\nTake a look at the right side of this page for an example.\n\nCheck out this snippet on how to implement a table of contents into your app\n\nExample\n\nA file content/home.md:\n\n---\n\ntitle: Home\n\n---\n\n\n\n## Welcome!\n\n\nWill be transformed into:\n\n{\n\n  \"dir\": \"/\",\n\n  \"slug\": \"home\",\n\n  \"path\": \"/home\",\n\n  \"extension\": \".md\",\n\n  \"title\": \"Home\",\n\n  \"toc\": [\n\n    {\n\n      \"id\": \"welcome\",\n\n      \"depth\": 2,\n\n      \"text\": \"Welcome!\"\n\n    }\n\n  ],\n\n  \"body\": {\n\n    \"type\": \"root\",\n\n    \"children\": [\n\n      {\n\n        \"type\": \"element\",\n\n        \"tag\": \"h2\",\n\n        \"props\": {\n\n          \"id\": \"welcome\"\n\n        },\n\n        \"children\": [\n\n          {\n\n            \"type\": \"element\",\n\n            \"tag\": \"a\",\n\n            \"props\": {\n\n              \"ariaHidden\": \"true\",\n\n              \"href\": \"#welcome\",\n\n              \"tabIndex\": -1\n\n            },\n\n            \"children\": [\n\n              {\n\n                \"type\": \"element\",\n\n                \"tag\": \"span\",\n\n                \"props\": {\n\n                  \"className\": [\n\n                    \"icon\",\n\n                    \"icon-link\"\n\n                  ]\n\n                },\n\n                \"children\": []\n\n              }\n\n            ]\n\n          },\n\n          {\n\n            \"type\": \"text\",\n\n            \"value\": \"Welcome!\"\n\n          }\n\n        ]\n\n      }\n\n    ]\n\n  }\n\n}\n\n\nWe internally add a text key with the markdown body that will be used for searching or extending it.\n\nJSON / JSON5\n\nData defined will be injected into the document.\n\nNo body will be generated.\n\nArrays\nv0.10.0+\n\nYou can now use arrays inside your .json files. Objects will be flattened and inserted into the collection. You can fetch your content in the same way as your used to.\n\nSince the slug is by default taken from the path and missing in this case, you have to define it in your objects for this feature to work properly.\n\nCheck out our example with articles and authors.\n\nExample\n\nA file content/home.json:\n\n{\n\n  \"title\": \"Home\",\n\n  \"description\": \"Welcome!\"\n\n}\n\n\nWill be transformed into:\n\n{\n\n  \"dir\": \"/\",\n\n  \"slug\": \"home\",\n\n  \"path\": \"/home\",\n\n  \"extension\": \".json\",\n\n  \"title\": \"Home\",\n\n  \"description\": \"Welcome!\"\n\n}\n\n\nA file content/authors.json:\n\n[\n\n  {\n\n    \"name\": \"SÃ©bastien Chopin\",\n\n    \"slug\": \"atinux\"\n\n  },\n\n  {\n\n    \"name\": \"Krutie Patel\",\n\n    \"slug\": \"krutiepatel\"\n\n  },\n\n  {\n\n    \"name\": \"Sergey Bedritsky\",\n\n    \"slug\": \"sergeybedritsky\"\n\n  }\n\n]\n\n\nWill be transformed into:\n\n[\n\n  {\n\n    \"name\": \"SÃ©bastien Chopin\",\n\n    \"slug\": \"atinux\",\n\n    \"dir\": \"/authors\",\n\n    \"path\": \"/authors/atinux\",\n\n    \"extension\": \".json\"\n\n  },\n\n  {\n\n    \"name\": \"Krutie Patel\",\n\n    \"slug\": \"krutiepatel\",\n\n    \"dir\": \"/authors\",\n\n    \"path\": \"/authors/krutiepatel\",\n\n    \"extension\": \".json\"\n\n  },\n\n  {\n\n    \"name\": \"Sergey Bedritsky\",\n\n    \"slug\": \"sergeybedritsky\",\n\n    \"dir\": \"/authors\",\n\n    \"path\": \"/authors/sergeybedritsky\",\n\n    \"extension\": \".json\"\n\n  }\n\n]\n\nCSV\n\nRows will be assigned to body variable.\n\nExample\n\nA file content/home.csv:\n\ntitle, description\nHome, Welcome!\n\n\nWill be transformed into:\n\n{\n\n  \"dir\": \"/\",\n\n  \"slug\": \"home\",\n\n  \"path\": \"/home\",\n\n  \"extension\": \".csv\",\n\n  \"body\": [\n\n    {\n\n      \"title\": \"Home\",\n\n      \"description\": \"Welcome!\"\n\n    }\n\n  ]\n\n}\n\nXML\n\nXML will be parsed\n\nExample\n\nA file content/home.xml:\n\n<xml>\n\n  <item prop=\"abc\">\n\n    <title>Title</title>\n\n    <description>Hello World</description>\n\n  </item>\n\n</xml>\n\n\nWill be transformed into:\n\n{\n\n  \"dir\": \"/\",\n\n  \"slug\": \"home\",\n\n  \"path\": \"/home\",\n\n  \"extension\": \".xml\",\n\n  \"body\": {\n\n    \"xml\": {\n\n      \"item\": [\n\n        {\n\n          \"$\": {\n\n            \"prop\": \"abc\"\n\n          },\n\n          \"title\": [\n\n            \"Title\"\n\n          ],\n\n          \"description\": [\n\n            \"Hello World\"\n\n          ]\n\n      }\n\n    ]\n\n  }\n\n}\n\nYAML / YML\n\nData defined will be injected into the document.\n\nNo body will be generated.\n\nExample\n\nA file content/home.yaml:\n\ntitle: Home\n\ndescription: Welcome!\n\n\nWill be transformed into:\n\n{\n\n  \"dir\": \"/\",\n\n  \"slug\": \"home\",\n\n  \"path\": \"/home\",\n\n  \"extension\": \".yaml\",\n\n  \"title\": \"Home\",\n\n  \"description\": \"Welcome!\"\n\n}\n\n\nInstallation\n\nInstall @nuxt/content in only two steps in your Nuxt project.\n\nFetching content\n\nLearn how to fetch your static content with $content in your Nuxt.js project."
  },
  {
    "title": "Installation - Nuxt Content V1",
    "url": "https://content.nuxt.com/v1/getting-started/installation/",
    "html": "Getting Started\n\nInstallation\n\nInstall @nuxt/content in only two steps in your Nuxt project.\n\nAdd @nuxt/content dependency to your project:\n\nYarn\nNPM\nyarn add @nuxt/content@^1\n\n\nThen, add @nuxt/content to the modules section of nuxt.config.js:\n\nnuxt.config.js\n{\n\n  modules: [\n\n    '@nuxt/content'\n\n  ],\n\n  content: {\n\n    // Options\n\n  }\n\n}\n\nTypeScript\n\nAdd the types to your \"types\" array in tsconfig.json after the @nuxt/types (Nuxt 2.9.0+) or @nuxt/vue-app entry.\n\ntsconfig.json\n\n{\n\n  \"compilerOptions\": {\n\n    \"types\": [\n\n      \"@nuxt/types\",\n\n      \"@nuxt/content\"\n\n    ]\n\n  }\n\n}\n\n\nWhy?\n\nBecause of the way Nuxt works the $content property on the context has to be merged into the Nuxt Context interface via declaration merging. Adding @nuxt/content to your types will import the types from the package and make TypeScript aware of the additions to the Context interface.\n\nIntroduction\n\nEmpower your NuxtJS application with the @nuxt/content module: write in a content/ directory and fetch your Markdown, JSON, YAML and CSV files through a MongoDB-like API, acting as a Git-based Headless CMS.\n\nWriting content\n\nLearn how to write your content/, supporting Markdown, YAML, CSV and JSON."
  },
  {
    "title": "I am a partial - Nuxt Content",
    "url": "https://content.nuxt.com/_partials/hello-world/",
    "html": "Partials\n\nI am a partial\n\nWith some Hello World text.\n\nI am a partial\n\nWith some Hello World text.\n\nPlay on StackBlitz\nÂ "
  },
  {
    "title": "Hooks - Nuxt Content",
    "url": "https://content.nuxt.com/recipes/hooks",
    "html": "Recipes\n\nHooks\n\nNuxt Content exposes hooks to allow you to modify the content before it is parsed and after it is parsed.\n\nThe module adds some hooks you can use:\n\ncontent:file:* hooks are available in nitro runtime, in order to use them you need to create a custom nitro plugin.\n\nCreate a plugin in the server/plugins/ directory\n\nserver/plugins/content.ts\nexport default defineNitroPlugin((nitroApp) => {\n\n  // ...\n\n})\n\ncontent:file:beforeParse\n\nAllows you to modify the contents of a file before it is handled by the parsers.\n\nArguments:\n\nfile: { _id: string, body: string }\n\nExample:\n\nChanging all occurrences of React to Vue in all Markdown files:\n\nserver/plugins/content.ts\nexport default defineNitroPlugin((nitroApp) => {\n\n  nitroApp.hooks.hook('content:file:beforeParse', (file) => {\n\n    if (file._id.endsWith('.md')) {\n\n      file.body = file.body.replace(/react/g, 'vue')\n\n    }\n\n  })\n\n})\n\ncontent:file:afterParse\n\nAllows you to modify a document after being parsed by parsers.\n\nArguments:\n\nfile: { _id: string, body: any }\n\nExample:\n\nUsing content's first picture as cover image.\n\nserver/plugins/content.ts\nimport { visit } from 'unist-util-visit'\n\n\n\nexport default defineNitroPlugin((nitroApp) => {\n\n  nitroApp.hooks.hook('content:file:afterParse', (file) => {\n\n    if (file._id.endsWith('.md')) {\n\n      visit(file.body, (n: any) => n.tag === 'img', (node) => {\n\n        file.coverImage = node.props.src\n\n      })\n\n    }\n\n  })\n\n})\n\n\nuseContent()\n\nThe useContent() composable gives access to the current page, surrounding pages and global data.\n\nTransformers\n\nTransformers are responsible for parsing and manipulating contents in Nuxt Content."
  },
  {
    "title": "Sitemap - Nuxt Content",
    "url": "https://content.nuxt.com/recipes/sitemap/",
    "html": "Recipes\n\nSitemap\n\nA sitemap file is useful for helping Google to better index your website, ensuring that the content you write can be visible in search results.\n\nNeed a complete Sitemap solution? Check out Nuxt Simple Sitemap, it integrates with Nuxt Content's document-driven mode and frontmatter.\n\nOtherwise, feel free to implement your own with the below guide.\n\nAdd dependencies\n\nThis can be created by utilising the sitemap library, which can be installed as follows:\n\npnpm\nyarn\nnpm\npnpm add sitemap\n\nServer Route\n\nWe will be utilising the server routes available within Nuxt, and to do so you'll need to create the server/ directory within your website's root directly.\n\nOnce this is done, create a routes/ directory inside this, and add a sitemap.xml.ts file, this will translate to /sitemap.xml.\n\nYou'll need to add the following:\n\nserver/routes/sitemap.xml.ts\nimport { serverQueryContent } from '#content/server'\n\nimport { SitemapStream, streamToPromise } from 'sitemap'\n\n\n\nexport default defineEventHandler(async (event) => {\n\n  // Fetch all documents\n\n  const docs = await serverQueryContent(event).find()\n\n  const sitemap = new SitemapStream({\n\n    hostname: 'https://example.com'\n\n  })\n\n\n\n  for (const doc of docs) {\n\n    sitemap.write({\n\n      url: doc._path,\n\n      changefreq: 'monthly'\n\n    })\n\n  }\n\n  sitemap.end()\n\n\n\n  return streamToPromise(sitemap)\n\n})\n\n\nNow, once users go to https://example.com/sitemap.xml, you'll find the generated XML file with all your pages.\n\nWhen using nuxt generate, you may want to pre-render the sitemap since the server route won't be able to run on a static hosting.\n\nYou can do this using the nitro.prerender option in your nuxt.config:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  // ...\n\n  nitro: {\n\n    prerender: {\n\n      routes: ['/sitemap.xml']\n\n    }\n\n  }\n\n})\n\n\nTransformers\n\nTransformers are responsible for parsing and manipulating contents in Nuxt Content.\n\nIntroduction\n\nEmpower your NuxtJS application with the @nuxt/content module: write in a content/ directory and fetch your Markdown, JSON, YAML and CSV files through a MongoDB-like API, acting as a Git-based Headless CMS."
  },
  {
    "title": "Transformers - Nuxt Content",
    "url": "https://content.nuxt.com/recipes/transformers/",
    "html": "Recipes\n\nTransformers\n\nTransformers are responsible for parsing and manipulating contents in Nuxt Content.\n\nNuxt Content has specific transformers for each content type to parse the raw content and prepare it for querying and rendering.\n\nYou can create custom transformers to support new content types or improve functionalities of supported content types.\n\nCreate your transformer. A transformer consists of 4 parts:\nname: Transformer name.\nextensions: List of valid file extensions.\nparse: If provided, this function will be used to parse the raw content.\ntransform: Receives that parsed content and manipulates it.\nmy-transformer.ts\n// filename: my-transformer.ts\n\nimport { defineTransformer } from '@nuxt/content/transformers'\n\n\n\nexport default defineTransformer({\n\n  name: 'my-transformer',\n\n  extensions: ['.names'],\n\n  parse (_id, rawContent) {\n\n    return {\n\n      _id,\n\n      body: rawContent.trim().split('\\n').map(line => line.trim()).sort()\n\n    }\n\n  }\n\n})\n\nDefine simple module to register transformer\nmy-module.mjs\n// filename: my-module.mjs\n\nimport { resolve } from 'path'\n\nimport { defineNuxtModule } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  setup (_options, nuxt) {\n\n    nuxt.options.nitro.externals = nuxt.options.nitro.externals || {}\n\n    nuxt.options.nitro.externals.inline = nuxt.options.nitro.externals.inline || []\n\n    nuxt.options.nitro.externals.inline.push(resolve('./my-module'))\n\n    // @ts-ignore\n\n    nuxt.hook('content:context', (contentContext) => {\n\n      contentContext.transformers.push(resolve('./my-module/my-transformer.ts'))\n\n    })\n\n  }\n\n})\n\nRegister your module\nnuxt.config.ts\n// filename: my-module.mjs\n\nimport { resolve } from 'path'\n\nimport { defineNuxtConfig } from '@nuxt/kit'\n\nimport MyModule from './my-module'\n\n\n\nexport default defineNuxtConfig({\n\n  modules: [\n\n    // always put it before @nuxt/content because the transformers \n\n    // needs to be loaded before transformation occurs\n\n    MyModule,\n\n    '@nuxt/content'\n\n  ]\n\n})\n\n\nThat's it. You can create .names files in content directory. Checkout transformer example.\n\nHooks\n\nNuxt Content exposes hooks to allow you to modify the content before it is parsed and after it is parsed.\n\nSitemap\n\nA sitemap file is useful for helping Google to better index your website, ensuring that the content you write can be visible in search results."
  },
  {
    "title": "useContent() - Nuxt Content",
    "url": "https://content.nuxt.com/document-driven/use-content/",
    "html": "Document Driven\n\nuseContent()\n\nThe useContent() composable gives access to the current page, surrounding pages and global data.\n\nWhen the document driven mode is enabled, useContent() is available everywhere in your app and gives access to a list of refs based on your content.\n\n<script setup lang=\"ts\">\n\nconst {\n\n  // Global references\n\n  globals,\n\n  navigation,\n\n  surround,\n\n  page,\n\n  // Computed properties from `page` key\n\n  excerpt,\n\n  toc,\n\n  type,\n\n  layout,\n\n  // Computed properties from `surround` key\n\n  next,\n\n  prev\n\n} = useContent()\n\n</script>\n\nRendering the page\n\nRendering the current page becomes a bliss with this composable:\n\npages/[...slug].vue\n<script setup lang=\"ts\">\n\nconst { page } = useContent()\n\n</script>\n\n\n\n<template>\n\n  <ContentRenderer :key=\"page._id\" :value=\"page\" />\n\n</template>\n\nPrevious/next page component\nPagePrevNext.vue\n<script setup lang=\"ts\">\n\nconst { prev, next } = useContent()\n\n</script>\n\n\n\n<template>\n\n  <div>\n\n    <NuxtLink v-if=\"prev\" :to=\"prev._path\">{{ prev.title }}</NuxtLink>\n\n    <NuxtLink v-if=\"next\" :to=\"next._path\">{{ next.title }}</NuxtLink>\n\n  </div>\n\n</template>\n\nTable of Contents component\nPageToc.vue\n<script setup lang=\"ts\">\n\nconst { toc } = useContent()\n\n</script>\n\n\n\n<template>\n\n  <div>\n\n    <ul v-if=\"toc && toc.links\">\n\n      <li v-for=\"link in toc.links\" :key=\"link.text\">\n\n        <a :href=\"`#${link.id}`\">\n\n          {{ link.text }}\n\n        </a>\n\n      </li>\n\n    </ul>\n\n  </div>\n\n</template>\n\n\nIntroduction\n\nThe Document-driven mode gives a lot more power to Markdown-based websites.\n\nHooks\n\nNuxt Content exposes hooks to allow you to modify the content before it is parsed and after it is parsed."
  },
  {
    "title": "Introduction - Nuxt Content",
    "url": "https://content.nuxt.com/document-driven/introduction/",
    "html": "Document Driven\n\nIntroduction\n\nThe Document-driven mode gives a lot more power to Markdown-based websites.\n\nNote that this mode is still experimental and may break in the future. We are considering a more stable API for the future leveraging pages/*.md files.\nEnable the mode\nExisting project\n\nAdd the documentDriven option in the nuxt.config:\n\nexport default defineNuxtConfig({\n\n  modules: ['@nuxt/content'],\n\n  content: {\n\n    documentDriven: true\n\n  }\n\n})\n\nFresh project\n\nStart a new project with the document-driven mode enabled:\n\nnpx\npnpm\nnpx nuxi init doc-driven-app -t doc-driven\n\n\nYou can also use an object to configure the behavior of the mode, checkout the configuration section.\n\nCatch-all page\n\nThe document driven mode ships a pre-configured catch-all route.\n\nThis injected Vue page is useful for having a minimal project structure:\n\nmy-project/\n  content/\n    index.md\n  nuxt.config.ts\n  package.json\n  tsconfig.json\n\n\nIt comes with a direct binding between your page's meta data to the OpenGraph tags using the useContentHead() composable, providing effective SEO with no configuration.\n\nPage slots\n\nThe page comes with 2 slot components that you can replace at your project level.\n\nTo do so, you only have to create a component with the same name in your project components/ directory.\n\n<DocumentDrivenNotFound />\n\nThis component will be shown when no page has been found for the current URL.\n\ncomponents/DocumentDrivenNotFound.vue\n<template>\n\n  <h1>Page not found</h1>\n\n</template>\n\n<DocumentDrivenEmpty />\n\nThis component will be shown when there is no content for the current page, but the page exists.\n\ncomponents/DocumentDrivenEmpty.vue\n<template>\n\n  <h1>This page is empty</h1>\n\n</template>\n\nLayout binding\n\nAs the page data is available beforehand, the layout can be defined in the page front-matter:\n\ncontent/blog/hello-world.md\n---\n\nlayout: article\n\n---\n\n\n\nThis page will use the article layout!\n\n\nBy default, it uses the default layout if none is specified.\n\nIf you want to use another layout by default, use the layoutFallbacks option in the nuxt.config:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  content: {\n\n    documentDriven: {\n\n      layoutFallbacks: ['theme'],\n\n    }\n\n  }\n\n})\n\n\nThis option will search for a theme key in globals, then search for a layout key inside that object. If found, that layout key will be used as a fallback.\n\nGlobal variables\n\nQueries are being made from a route middleware and are resolved before your page renders.\n\nThis gives access to the useContent() composable anywhere in your app with the following variables:\n\npage\nsurround\nnavigation\nglobals\n<script setup lang=\"ts\">\n\nconst { navigation, page, surround, globals } = useContent()\n\n\n\nconsole.log(page.value)\n\n</script>\n\nExtend global variables\n\nThis mode gives you a convenient way to access file data globally in your application.\n\nUse the documentDriven.globals key of in your nuxt.config to specify a query:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  content: {\n\n    documentDriven: {\n\n      globals: {\n\n        theme: {\n\n          where: [\n\n            {\n\n              _id: 'content:_theme.yml'\n\n            }\n\n          ],\n\n          without: ['_']\n\n        }\n\n      }\n\n    }\n\n  }\n\n})\n\n\nThis configuration will search for a _theme.yml file in the content/ directory.\n\nIf found, a theme object will be accessible via useContent().globals:\n\nconst { theme } = useContent().globals\n\n\nAny changes to these files will be automatically reflected in the application during development.\n\nDisable or control the page data\n\nUsing special documentDriven meta in your pages, you can disable this feature for specific route or control it's behavior.\n\nDisable document driven\n\nSetting documentDriven to false will disable document driven. This means that exposed refs from useContent() will be undefined.\n\n<script setup lang=\"ts\">\n\ndefinePageMeta({\n\n  documentDriven: false\n\n})\n\n</script>\n\nControl data\n\nTo control document driven data you can pass an object to documentDriven meta key and enable/disable specific parts of it.\n\n<script setup lang=\"ts\">\n\ndefinePageMeta({\n\n  documentDriven: {\n\n    page: true, // Keep page fetching enabled\n\n    surround: false // Disable surround fetching\n\n  }\n\n})\n\n</script>\n\nConfig content\n\nYou can pass custom path/query to page and surround options to config documentDriven content.\n\n<script setup lang=\"ts\">\n\ndefinePageMeta({\n\n  documentDriven: {\n\n    // Simple Path\n\n    page: '/foo',\n\n    // Rich Query\n\n    surround: {\n\n      _path: '/foo/bar'\n\n    }\n\n  }\n\n})\n\n</script>\n\nIf you change page option and leave surround unset, surround option will use the same config and page.\n<script setup lang=\"ts\">\n\ndefinePageMeta({\n\n  documentDriven: {\n\n    page: {\n\n      _path: '/foo/bar'\n\n    },\n\n    // surround will use `{ _path: '/foo/bar' }`\n\n  }\n\n})\n\n</script>\n\n\nProse Components\n\nA list of Prose components currently implemented.\n\nuseContent()\n\nThe useContent() composable gives access to the current page, surrounding pages and global data."
  },
  {
    "title": "Prose Components - Nuxt Content",
    "url": "https://content.nuxt.com/components/prose/",
    "html": "Components\n\nProse Components\n\nA list of Prose components currently implemented.\n\nProse\n\nHere is a list of all the Prose components currently implemented.\n\nTo overwrite a prose component, create a component with the same name in your project components/content/ directory (ex: components/content/ProseA.vue)\n\nProseA\n\n Source\n\nCode\nPreview\n[Link](/components/prose)\n\nProseBlockquote\n\n Source\n\nCode\nPreview\n> Block quote\n\nProseCode\n\n Source\n\nCode\nPreview\n  ```js [file.js]{4-6,7} meta-info=val\n\n  export default () => {\n\n    console.log('Code block')\n\n  }\n\n  ```\n\n\nComponent properties will be:\n\n{\n\n  code: \"export default () => {\\n    console.log('Code block')\\n}\"\n\n  language: \"js\"\n\n  filename: \"file.js\"\n\n  highlights: [4, 5, 6, 7]\n\n  meta: \"meta-info=val\"\n\n}\n\n\nCheck out the highlight options for more about the syntax highlighting.\n\nIf you want to use ] in the filename, you need to escape it with 2 backslashes: \\\\]. This is necessary since JS will automatically escape the backslash in a string so \\] will be resolved as ] breaking our regex.\nProseCodeInline\n\n Source\n\ncode inline.\n\nCode\nPreview\n`code inline`.\n\n\n\n`const codeInline: string = 'highlighted code inline'`\n\nProseH1\n\n Source\n\nCode\nPreview\n# H1 Heading\n\nProseH2\n\n Source\n\nCode\nPreview\n## H2 Heading\n\nProseH3\n\n Source\n\nCode\nPreview\n### H3 Heading\n\nProseH4\n\n Source\n\nCode\nPreview\n#### H4 Heading\n\nProseH5\n\n Source\n\nCode\nPreview\n##### H5 Heading\n\nProseH6\n\n Source\n\nCode\nPreview\n###### H6 Heading\n\nProseHr\n\n Source\n\nCode\nPreview\nDivider under.\n\n\n\n---\n\n\n\nDivider above.\n\nProseImg\n\n Source\n\nCode\nPreview\n![A Cool Image](/social-card.png)\n\nProseUl\n\n Source\n\nCode\nPreview\n- Just\n\n- An\n\n- Unordered\n\n- List\n\nProseLi\n\n Source\n\nCode\nPreview\n- List element\n\nProseOl\n\n Source\n\nCode\nPreview\n1. Foo\n\n2. Bar\n\n3. Baz\n\nProseP\n\n Source\n\nCode\nPreview\nJust a paragraph.\n\nProseStrong\n\n Source\n\nCode\nPreview\n**Just a strong paragraph.**\n\nProseEm\n\n Source\n\nCode\nPreview\n_Just an italic paragraph._\n\nProseTable\n\n Source\n\nCode\nPreview\n| Key | Type      | Description |\n\n| --- | --------- | ----------- |\n\n| 1   | Wonderful | Table       |\n\n| 2   | Wonderful | Data        |\n\n| 3   | Wonderful | Website     |\n\nProseTbody\n\n Source\n\nIncluded in ProseTable example.\n\nProseTd\n\n Source\n\nIncluded in ProseTable example.\n\nProseTh\n\n Source\n\nIncluded in ProseTable example.\n\nProseThead\n\n Source\n\nIncluded in ProseTable example.\n\nProseTr\n\n Source\n\nIncluded in ProseTable example.\n\n<ContentSlot>\n\nThe fastest way to inject Markdown into your Vue components.\n\nIntroduction\n\nThe Document-driven mode gives a lot more power to Markdown-based websites."
  },
  {
    "title": "<ContentSlot> - Nuxt Content",
    "url": "https://content.nuxt.com/components/content-slot/",
    "html": "Components\n\n<ContentSlot>\n\nThe fastest way to inject Markdown into your Vue components.\n\nThe <ContentSlot> component makes it easier to use Markdown syntax in your Vue components.\n\nIt is useful when creating components that you want to use in your Markdown content.\n\nProps\nuse: The slot to bind on, you must provide a use via $slots.{your_slot} in <template>.\nType: Vue slot Function\nExample: $slots.default\nunwrap: Whether to unwrap the content or not. This is useful when you want to extract the content nested in native Markdown syntax. Each specified tag will get removed from AST.\nType: boolean or string\nDefault: false\nExample: 'ul li'\nExample\ncomponents/FancyHeader.vue\n<template>\n\n  <h2 class=\"fancy-header\"><ContentSlot :use=\"$slots.default\" unwrap=\"p\" /></h2>\n\n</template>\n\n\nThen using it in Markdown:\n\ncontent/index.md\n::fancy-header\n\nThat text paragraph will be unwrapped.\n\n::\n\n\nWill result to:\n\n<h2 class=\"fancy-header\">That text paragraph will be unwrapped.</h2>\n\n\n<ContentQuery>\n\nThe fastest way to query and display your content.\n\nProse Components\n\nA list of Prose components currently implemented."
  },
  {
    "title": "<ContentQuery> - Nuxt Content",
    "url": "https://content.nuxt.com/components/content-query/",
    "html": "Components\n\n<ContentQuery>\n\nThe fastest way to query and display your content.\n\nThe <ContenQuery> is a renderless component shortening the access to queryContent().\n\npages/[...slug].vue\n<!-- Similar to <ContentDoc :path=\"$route.path\" /> -->\n\n<template>\n\n  <main>\n\n    <ContentQuery :path=\"$route.path\" find=\"one\" v-slot=\"{ data }\">\n\n      <ContentRenderer :value=\"data\" />\n\n    </ContentQuery>\n\n  </main>\n\n</template>\n\nProps\npath: The path of the content to load from content source.\nType: string\nDefault: undefined\nonly: Select a subset of fields from an array of keys.\nType: string[]\nDefault: undefined\nwithout: Remove a subset of fields from an array of keys.\nType: string[]\nDefault: undefined\nwhere: Filter results with a where clause definition.\nType: { [key: string]: any }\nDefault: undefined\nsort: Sort results with a sort clause definition.\nType: SortParams\nDefault: undefined\nlimit: Limit the amount of results.\nType: number\nDefault: undefined\nskip: Skip an amount of results.\nType: number\nDefault: undefined\nlocale: Filter contents based on a locale.\nType: string\nDefault: undefined\nfind: The type of query to be made.\nType: string\nValues: 'one' or 'surround' or undefined\nDefault: .find() will be used if nothing is specified\nSlots\n\nThe default slot can be used to render the content via v-slot=\"{ data }\" syntax.\n\nThe empty slot can be used to display a default content if the body of the document is empty.\n\nThe not-found slot can be used to display a default content before rendering the document.\n\nWhere clause\npages/about.vue\n<template>\n\n  <main>\n\n    <ContentQuery path=\"/about/authors\" :where=\"{ type: 'csv' }\">\n\n      <template #default=\"{ data }\">\n\n        <ul>\n\n          <li v-for=\"author of data\" :key=\"author.name\">\n\n            {{ author.name }}\n\n          </li>\n\n        </ul>\n\n      </template>\n\n      <template #not-found>\n\n        <p>No authors found.</p>\n\n      </template>\n\n    </ContentQuery>\n\n  </main>\n\n</template>\n\n\n<ContentNavigation>\n\nBuilding complex navigation from your content has never been easier.\n\n<ContentSlot>\n\nThe fastest way to inject Markdown into your Vue components."
  },
  {
    "title": "<ContentNavigation> - Nuxt Content",
    "url": "https://content.nuxt.com/components/content-navigation/",
    "html": "Components\n\n<ContentNavigation>\n\nBuilding complex navigation from your content has never been easier.\n\nThe <ContentNavigation> is a renderless component shortening the access to the navigation.\n\ncomponents/Navbar.vue\n<template>\n\n  <nav>\n\n    <ContentNavigation v-slot=\"{ navigation }\">\n\n      <ul>\n\n        <li v-for=\"link of navigation\" :key=\"link._path\">\n\n          <NuxtLink :to=\"link._path\">{{ link.title }}</NuxtLink>\n\n        </li>\n\n      </ul>\n\n    </ContentNavigation>\n\n  </nav>\n\n</template>\n\nProps\nquery: A query to be passed to fetchContentNavigation().\nType: QueryBuilderParams | QueryBuilder\nDefault: undefined\nSlots\n\nThe default slot can be used to render the content with v-slot=\"{ navigation }\" syntax.\n\nQuery\n\nBy providing the query prop you can customise the content used for navigation.\n\nHere we pass along a QueryBuilder instance.\n\n<script setup>\n\nconst catsQuery = queryContent('cats')\n\n/*\n\n// If you'd prefer to pass along raw `QueryBuilderParams`:\n\nconst catsQuery = {\n\n  where: [\n\n    { _path: /^\\/cats/ },\n\n  ],\n\n}\n\n*/\n\n</script>\n\n\n\n<template>\n\n<ContentNavigation v-slot=\"{ navigation }\" :query=\"catsQuery\">\n\n  <NuxtLink\n\n    v-for=\"link of navigation\"\n\n    :key=\"link._path\"\n\n    :to=\"link._path\"\n\n  >\n\n    {{ link.navTitle || link.title }}\n\n  </NuxtLink>\n\n</ContentNavigation>\n\n</template>\n\n\n<ContentList>\n\nThe fastest way to query your content with a component.\n\n<ContentQuery>\n\nThe fastest way to query and display your content."
  },
  {
    "title": "<ContentList> - Nuxt Content",
    "url": "https://content.nuxt.com/components/content-list/",
    "html": "Components\n\n<ContentList>\n\nThe fastest way to query your content with a component.\n\nThe <ContentList> component fetches a list of documents and allows you to render them by using slots.\n\nThe fetching path defaults to the content root (/).\n\nAn explicit path can be given to the component.\n\npages/index.vue\n<template>\n\n  <main>\n\n    <ContentList path=\"/articles\" v-slot=\"{ list }\">\n\n      <div v-for=\"article in list\" :key=\"article._path\">\n\n        <h2>{{ article.title }}</h2>\n\n        <p>{{ article.description }}</p>\n\n      </div>\n\n    </ContentList>\n\n  </main>\n\n</template>\n\nProps\npath: The path of the content to load from content source.\nType: string\nDefault: '/'\nquery: A query builder params object to be passed to <ContentQuery /> component.\nType: QueryBuilderParams\nDefault: undefined\nSlots\n\ndefault slot can be used to render the content via v-slot=\"{ list }\" syntax:\n\npages/index.vue\n<template>\n\n  <main>\n\n    <ContentList path=\"/articles\" v-slot=\"{ list }\">\n\n      <div v-for=\"article in list\" :key=\"article._path\">\n\n        <h2>{{ article.title }}</h2>\n\n        <p>{{ article.description }}</p>\n\n      </div>\n\n    </ContentList>\n\n  </main>\n\n</template>\n\n\nnot-found slot can be used when no documents are matching the query:\n\npages/index.vue\n<template>\n\n  <main>\n\n    <ContentList path=\"/articles\">\n\n      <template #default=\"{ list }\">\n\n        <!-- ...default slot -->\n\n      </template>\n\n      <template #not-found>\n\n        <p>No articles found.</p>\n\n      </template>\n\n    </ContentList>\n\n  </main>\n\n</template>\n\nQuery example\npages/index.vue\n<script setup lang=\"ts\">\n\nimport type { QueryBuilderParams } from '@nuxt/content/dist/runtime/types'\n\nconst query: QueryBuilderParams = { path: '/articles', where: [{ layout: 'article' }], limit: 5, sort: [{ date: -1 }] }\n\n</script>\n\n\n\n<template>\n\n  <main>\n\n    <ContentList :query=\"query\" v-slot=\"{ list }\">\n\n      <div v-for=\"article in list\" :key=\"article._path\">\n\n        <h2>{{ article.title }}</h2>\n\n        <p>{{ article.description }}</p>\n\n      </div>\n\n    </ContentList>\n\n  </main>\n\n</template>\n\n\n<ContentRenderer>\n\nTakes your component from an AST to a wonderful template.\n\n<ContentNavigation>\n\nBuilding complex navigation from your content has never been easier."
  },
  {
    "title": "<ContentRenderer> - Nuxt Content",
    "url": "https://content.nuxt.com/components/content-renderer/",
    "html": "Components\n\n<ContentRenderer>\n\nTakes your component from an AST to a wonderful template.\n\nThe <ContentRenderer> component renders a document coming from a query with queryContent().\n\nIt will use <ContentRendererMarkdown> component to render .md file types.\n\nOther types will currently be passed to default slot via v-slot=\"{ data }\" or be rendered inside <pre /> tag.\n\nProps\nvalue: The document to render.\nType: ParsedContent\nDefault: {}\ntag: The tag to use for the renderer element if it is used.\nType: string\nDefault: 'div'\nexcerpt: Whether or not to render the excerpt.\nType: boolean\nDefault: false\ncomponents: The map of custom components to use for rendering. This prop will pass to markdown renderer and will not affect other file types.\nType: object\nDefault: {}\ndata: A map of variables to inject into the markdown content for later use in binding variables.\nType: object\nDefault: {}\nSlots\n\nThe default slot can be used to render the content via v-slot=\"{ data }\" syntax.\n\npages/[...slug].vue\n<script setup lang=\"ts\">\n\nconst { data } = await useAsyncData('page-data', () => queryContent('/hello').findOne())\n\n</script>\n\n\n\n<template>\n\n  <main>\n\n    <ContentRenderer :value=\"data\">\n\n      <h1>{{ data.title }}</h1>\n\n      <ContentRendererMarkdown :value=\"data\" />\n\n    </ContentRenderer>\n\n  </main>\n\n</template>\n\n\nThe empty slot can be used to display a default content when the document is empty:\n\npages/[...slug].vue\n<script setup lang=\"ts\">\n\nconst { data } = await useAsyncData('page-data', () => queryContent('/hello').findOne())\n\n</script>\n\n\n\n<template>\n\n  <main>\n\n    <ContentRenderer :value=\"data\">\n\n      <template #empty>\n\n        <p>No content found.</p>\n\n      </template>\n\n    </ContentRenderer>\n\n  </main>\n\n</template>\n\nNote that when you use default slot and <ContentRendererMarkdown> in your template you need to pass components to <ContentRendererMarkdown>.\ncomponents/CustomParagraph.vue\n<template>\n\n  <div>\n\n    <ContentSlot :use=\"$slots.default\" unwrap=\"p\" />\n\n  </div>\n\n</template>\n\ncontent/index.md\n::custom-p\n\nthis is my custom paragraph\n\n::\n\npages/[...slug].vue\n<script setup lang=\"ts\">\n\nimport { CustomParagraph } from '#components';\n\n\n\nconst { data } = await useAsyncData('page-data', () => queryContent('/hello').findOne())\n\n\n\nconst components = {\n\n  'custom-p': CustomParagraph\n\n}\n\n</script>\n\n\n\n<template>\n\n  <main>\n\n    <ContentRenderer :value=\"data\">\n\n      <h1>{{ data.title }}</h1>\n\n      <ContentRendererMarkdown :value=\"data\" :components=\"components\" />\n\n    </ContentRenderer>\n\n  </main>\n\n</template>\n\n\n<ContentDoc>\n\nThe fastest way to query and display your content.\n\n<ContentList>\n\nThe fastest way to query your content with a component."
  },
  {
    "title": "<ContentDoc> - Nuxt Content",
    "url": "https://content.nuxt.com/components/content-doc/",
    "html": "Components\n\n<ContentDoc>\n\nThe fastest way to query and display your content.\n\n<ContentDoc>\n\nThe <ContentDoc> component fetches and renders a single document.\n\nAn explicit path can be passed to the component with the path prop. If not provided, the $route.path will be used.\n\nIt uses <ContentRenderer> and <ContentQuery> under the hood.\n\nProps\ntag: The tag to use for the renderer element (if no default slot is provided).\nType: string\nDefault: 'div'\npath: The path of the content to load from content source.\nType: string\nDefault: $route.path\nexcerpt: Whether or not to render the excerpt.\nType: boolean\nDefault: false\nquery: A query to be passed to queryContent().\nType: QueryBuilderParams\nDefault: undefined\nhead: Toggles the usage of useContentHead.\nType: boolean\nDefault: true\nSlots\n\nThe default slot can be used to render the content via v-slot=\"{ data }\" syntax:\n\npages/dataviz.vue\n<template>\n\n  <main>\n\n    <ContentDoc v-slot=\"{ doc }\">\n\n      <article>\n\n        <h1>{{ doc.title }}</h1>\n\n        <ContentRenderer :value=\"doc\" />\n\n      </article>\n\n    </ContentDoc>\n\n  </main>\n\n</template>\n\n\nThe not-found slot can be used when no document is found:\n\npages/dataviz.vue\n<template>\n\n  <main>\n\n    <ContentDoc>\n\n      <template #not-found>\n\n        <h1>Document not found</h1>\n\n      </template>\n\n    </ContentDoc>\n\n  </main>\n\n</template>\n\n\nThe empty slot can be used to display a default content before rendering the document.\n\npages/dataviz.vue\n<template>\n\n  <main>\n\n    <ContentDoc>\n\n      <template #empty>\n\n        <h1>Document is empty</h1>\n\n      </template>\n\n    </ContentDoc>\n\n  </main>\n\n</template>\n\nExamples\nDefault\npages/[...slug].vue\n<template>\n\n  <main>\n\n    <!-- Similar to <ContentDoc :path=\"$route.path\" /> -->\n\n    <ContentDoc />\n\n  </main>\n\n</template>\n\nExplicit path\napp.vue\n<template>\n\n  <main>\n\n    <ContentDoc path=\"/about\" />\n\n  </main>\n\n</template>\n\n\nsearchContent()\n\nUsed to search in your content directory.\n\n<ContentRenderer>\n\nTakes your component from an AST to a wonderful template."
  },
  {
    "title": "searchContent() - Nuxt Content",
    "url": "https://content.nuxt.com/composables/search-content/",
    "html": "Composables\n\nsearchContent()\n\nUsed to search in your content directory.\n\nsearchContent()\n\nUsed to search in your content directory.\n\nconst input = ref('')\n\nconst results = searchContent(input)\n\nParameters\nKey\tType\tDefault\tDescription\nsearch\tMaybeRefOrGetter<string>\t\tThe search input\noptions\tSearchContentOptions\t{}\tThe options\noptions.miniSearch\tMaybeRefOrGetter<MiniSearchOptions<T>>\t\tThe options passed to miniSearch\noptions.fetch\tMaybeRefOrGetter<UseFetchOptions<string | T>>\t\tThe options passed to useFetch\nMiniSearchOptions\n\nYou can easily define the miniSearch options by using the defineMiniSearchOptions composable:\n\nconst miniSearchOptions = defineMiniSearchOptions({\n\n  fields: ['title', 'description', 'body']\n\n})\n\n\nUsing these options allows you to modify how the search is performed. You can change the fields that are searched, the weight of each field, and more.\n\nOnly available when using the simple search, aka non-indexed search.\n\nUseFetchOptions\n\nAn option is provided to customize the behavior of the useFetch composable used internally to only fetch the search content on client and lazy. This could avoid fetching the content on SSR and adding content to the _payload.json file improving the performance of your app since _payload is loaded for hydration.\n\nuseUnwrap()\n\nA composable to unwrap slots, for advanced usage.\n\n<ContentDoc>\n\nThe fastest way to query and display your content."
  },
  {
    "title": "useUnwrap() - Nuxt Content",
    "url": "https://content.nuxt.com/composables/use-unwrap/",
    "html": "Composables\n\nuseUnwrap()\n\nA composable to unwrap slots, for advanced usage.\n\nIt can be used to achieve a similar behavior as unwrap prop from <ContentSlot> component.\n\nExample:\n\n<script setup lang=\"ts\">\n\nconst { flatUnwrap } = useUnwrap()\n\n\n\n</script>\n\n\n\n<template>\n\n  <ul>\n\n    <li v-for=\"(item, index) of flatUnwrap($slots.default!(), ['ul'])\" :key=\"index\">\n\n      â˜‘ï¸Ž\n\n      <span><ContentSlot :use=\"() => item\" unwrap=\"li\" /></span>\n\n    </li>\n\n  </ul>\n\n</template>\n\n\nuseContentHelpers()\n\nHelpers to interact with the navigation object.\n\nsearchContent()\n\nUsed to search in your content directory."
  },
  {
    "title": "useContentHelpers() - Nuxt Content",
    "url": "https://content.nuxt.com/composables/use-content-helpers/",
    "html": "Composables\n\nuseContentHelpers()\n\nHelpers to interact with the navigation object.\n\nUsage\n<script setup lang=\"ts\">\n\nconst {\n\n  navBottomLink,\n\n  navDirFromPath,\n\n  navPageFromPath,\n\n  navKeyFromPath\n\n} = useContentHelpers()\n\n</script>\n\n\nLearn more about the navigation object.\n\nnavBottomLink()\n\nTake a navigation node and will resolve the first available path from that node.\n\nIt can be useful to build nested navigations systems.\n\n<script setup>\n\nconst { navBottomLink } = useContentHelpers()\n\nconst { data: navigation } = await useAsyncData('navigation', () => fetchContentNavigation())\n\n\n\nconst path = navBottomLink(navigation.value)\n\n</script>\n\nnavDirFromPath()\n\nThis function will take a path and will resolve the first available navigation node from that path.\n\nIt can be useful to find the current directory of a navigation node.\n\n<script setup>\n\nconst route = useRoute()\n\nconst { navDirFromPath } = useContentHelpers()\n\nconst { data: navigation } = await useAsyncData('navigation', () => fetchContentNavigation())\n\n\n\nconst dir = navDirFromPath(route.path, navigation.value)\n\n</script>\n\nnavPageFromPath()\n\nThis function will take a path and will resolve the first available navigation page from that path.\n\nIt can be useful to find the current navigation node the page you're browsing.\n\n<script setup>\n\nconst route = useRoute()\n\nconst { navPageFromPath } = useContentHelpers()\n\nconst { data: navigation } = await useAsyncData('navigation', () => fetchContentNavigation())\n\n\n\nconst page = navPageFromPath(route.path, navigation.value)\n\n</script>\n\nnavKeyFromPath()\n\nThis function will take a path and will resolve a specific key from that path.\n\nIt can be useful when you want to add a fallback on the _dir.yml value of a key in a page.\n\n<script setup>\n\nconst route = useRoute()\n\nconst { navKeyFromPath } = useContentHelpers()\n\nconst { data: navigation } = await useAsyncData('navigation', () => fetchContentNavigation())\n\n\n\nconst layout = navKeyFromPath(route.path, 'layout', navigation.value)\n\n</script>\n\n\nuseContentHead()\n\nThe useContentHead() composable provides a binding between your content data and useHead() composable.\n\nuseUnwrap()\n\nA composable to unwrap slots, for advanced usage."
  },
  {
    "title": "useContentHead() - Nuxt Content",
    "url": "https://content.nuxt.com/composables/use-content-head/",
    "html": "Composables\n\nuseContentHead()\n\nThe useContentHead() composable provides a binding between your content data and useHead() composable.\n\nUsage\n\nuseContentHead() is available everywhere in your app where useHead would be.\n\nIt takes two arguments:\n\ndocument: A document data (of any type)\nto: A route path\nDefault: useRoute()\nwith queryContent\nwith document-driven\n<script setup lang=\"ts\">\n\nconst { data: page } = await useAsyncData('my-page', queryContent('/').findOne)\n\n\n\nuseContentHead(page)\n\n</script>\n\nAutomation\n\nWhen using the <ContentDoc /> component or the default document-driven page, the composable will be automatically used.\n\nTo disable the automation, you can set the contentHead option to false in your nuxt.config:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  content: {\n\n    contentHead: false\n\n  }\n\n})\n\nParameters\n\nThese parameters can be used from the Front-Matter section of your pages.\n\nKey\tType\tDefault\tDescription\nhead\tobject\t\tA useHead compatible object\ntitle\tstring\t\tWill be used as the default value for head.title\nhead.title\tstring\tParsed title\tSets the <title> tag\ndescription\tstring\t\tWill be used as the default value for head.description\nhead.description\tstring\tParsed description\tSets the <meta name=\"description\"> tag\nimage\tstring | object\t\tWill be used as the default value for head.image\nimage.src\tstring\t\tThe source of the image\nimage.alt\tstring\t\tThe alt description of the image\nimage.xxx\tstring\t\tAny og:image:xxx compatible attribute\nhead.image\tstring | object\t\tOverrides the <meta property=\"og:image\">\n\nAt the exception of title, description and image, the head object behaves exactly the same in Front-Matter as it would in useHead({ ... }) composable.\n\nYou can specify any value that is writeable in yaml format.\n\nexample-usage.md\n---\n\ntitle: 'My Page Title'\n\ndescription: 'What a lovely page.'\n\nimage:\n\n  src: '/assets/image.jpg'\n\n  alt: 'An image showcasing My Page.'\n\n  width: 400\n\n  height: 300\n\nhead:\n\n  meta:\n\n    - name: 'keywords'\n\n      content: 'nuxt, vue, content'\n\n    - name: 'robots'\n\n      content: 'index, follow'\n\n    - name: 'author'\n\n      content: 'NuxtLabs'\n\n    - name: 'copyright'\n\n      content: 'Â© 2022 NuxtLabs'\n\n---\n\n\nfetchContentNavigation()\n\nThe fetchContentNavigation utility returns a tree of items based on the content/ directory structure and files.\n\nuseContentHelpers()\n\nHelpers to interact with the navigation object."
  },
  {
    "title": "fetchContentNavigation() - Nuxt Content",
    "url": "https://content.nuxt.com/composables/fetch-content-navigation/",
    "html": "Composables\n\nfetchContentNavigation()\n\nThe fetchContentNavigation utility returns a tree of items based on the content/ directory structure and files.\n\nUsage\napp.vue\nDirectory structure\nOutput\n<script setup>\n\nconst { data: navigation } = await useAsyncData('navigation', () => fetchContentNavigation())\n\n</script>\n\n\n\n<template>\n\n  <pre>{{ navigation }}</pre>\n\n</template>\n\nArguments\nqueryBuilder\nType: QueryBuilder\nDefinition: Any query built via queryContent()\nDefault: /\n\nqueryContent()\n\nThe queryContent composable provides methods for querying and fetching your contents.\n\nuseContentHead()\n\nThe useContentHead() composable provides a binding between your content data and useHead() composable."
  },
  {
    "title": "queryContent() - Nuxt Content",
    "url": "https://content.nuxt.com/composables/query-content/",
    "html": "Composables\n\nqueryContent()\n\nThe queryContent composable provides methods for querying and fetching your contents.\n\nImportant âš ï¸\n\nIn your pages and components, wrap your query in useAsyncData composable to prevent fetching duplication on first load.\n\napp.vue\n<script setup>\n\nconst { data } = await useAsyncData('home', () => queryContent('/').findOne())\n\n</script>\n\n\n\n<template>\n\n  <pre>\n\n    {{ data }}\n\n  </pre>\n\n</template>\n\nQuery builder\n\nThe queryContent() composable provides methods for querying and fetching your contents.\n\nCreate a query builder to search contents.\n\n// Create a query looking for anything in content/ directory\n\nconst contentQuery = queryContent()\n\n\n\n// Create a query looking into content/articles directory\n\nconst contentQuery = queryContent('articles')\n\n\n\n// Create a query looking into content/articles/nuxt3 directory\n\nconst contentQuery = queryContent('articles', 'nuxt3')\n\nwhere(query)\nquery:\nType: Partial<QueryBuilderParams>\nRequired\n\nFilter results by query.\n\nWhere queries are based on subset of Mongo query syntax, it handles: $eq, $ne, $gt, $gte, $lt, $lte and $in\n\n// Implicit (assumes $eq operator)\n\nconst articles = await queryContent('articles').where({ title: 'Home' }).findOne()\n\n\n\n// Explicit $eq\n\nconst articles = await queryContent('articles').where({ title: { $eq: 'Home' } }).findOne()\n\n\n\n// $gt\n\nconst articles = await queryContent('articles').where({ age: { $gt: 18 } }).find()\n\n\n\n// $in\n\nconst articles = await queryContent('articles').where({ name: { $in: ['odin', 'thor'] } }).find()\n\n\nIn order to filter in objects and an array or arrays, you can use the nested properties style:\n\nconst products = await queryContent('products').where({ 'categories': { $contains: 'top' } }).find()\n\n\n\nconst products = await queryContent('products').where({ 'categories': { $contains: ['top', 'woman'] } }).find()\n\nsort(options)\noptions\nType: object\nRequired\n\nSort results by a field or fields.\n\n// Sort by title ascending\n\nconst articles = await queryContent('articles')\n\n  .sort({ title: 1 })\n\n  .find()\n\n\n\n// Sort by title ascending first then sort by category descending\n\nconst articles = await queryContent('articles')\n\n  .sort({ title: 1, category: -1 })\n\n  .find()\n\n// OR\n\nconst articles = await queryContent('articles')\n\n  .sort({ title: 1 })\n\n  .sort({ category: -1 })\n\n  .find()\n\n\n\n// Sort by nested field\n\nconst articles = await queryContent('articles')\n\n  .sort({ 'category.title': 1 })\n\n  .find()\n\n\nsort() method does case-sensitive, alphabetical sort by default. There is some magical options you can pass to sort options to change sort behavior, like sorting case-insensitive or numerically rather than alphabetically.\n\n$sensitivity: Change case sensitivity. Like using $sensitivity: 'base' for case-insensitive sort\n$numeric: Boolean whether numeric collation should be used, such that \"1\" < \"2\" < \"10\".\n$caseFirst: Whether upper case or lower case should sort first.\n\nFor example, to sort a list of people from youngest to oldest:\n\nconst people = await queryContent('people')\n\n  .sort({ age: 1, $numeric: true })\n\n  .find()\n\n\nThese options are given to Intl.Collator().\n\nlimit(count)\ncount\nType: number\nRequired\n\nLimit number of results.\n\n// fetch only 5 articles\n\nconst articles = await queryContent('articles').limit(5).find()\n\nskip(count)\ncount\nType: number\nRequired\n\nSkip results.\n\n// fetch the next 5 articles\n\nconst articles = await queryContent('articles')\n\n    .skip(5)\n\n    .limit(5)\n\n    .find()\n\nwithout(keys)\nkeys\nType: string[] or string\nRequired\n\nRemove a subset of fields.\n\nconst articles = await queryContent('articles').without('unused-key').find()\n\n\n\nconst articles = await queryContent('articles').without(['unused-key', 'another-unused-key']).find()\n\nonly(keys)\nkeys\nType: string[] or string\nRequired\n\nSelect a subset of fields.\n\nconst articles = await queryContent('articles').only('id').find()\n\n\n\nconst articles = await queryContent('articles').only(['id', 'title']).find()\n\nfind()\n\nFetch and return the list of matched contents based on the query.\n\n// List of articles\n\nconst articles = await queryContent('articles').find()\n\nfindOne()\n\nFetch the first match of content.\n\nconst firstArticle = await queryContent('articles').findOne()\n\nfindSurround(path, options)\npath\nType: string\nRequired\noptions\nType: { before: number, after: number }\nDefault: { before: 1, after: 1 }\n\nGet the previous and next results around the path. The path should be the full path of the target content.\n\nYou will always obtain an array of fixed length filled with the matching document or null.\n\nconst [prev, next] = await queryContent()\n\n  .only(['_path', 'title'])\n\n  .sort({ date: 1})\n\n  .where({ isArchived: false })\n\n  .findSurround('/articles/article-2')\n\n\n\n// Returns\n\n[\n\n  {\n\n    title: 'Article 1',\n\n    _path: '/articles/article-1'\n\n    //...\n\n  },\n\n  null // no article-3 here\n\n]\n\ncount()\n\nCount the number of matched contents based on the query.\n\n// Count of articles\n\nconst count = await queryContent('articles').count()\n\n\n\n// Returns\n\n5 // number of articles\n\n\nYou can also use count() with where() method.\n\n// Count of articles\n\nconst count = await queryContent('articles')\n\n  .where({ isArchived: false })\n\n  .count()\n\n\n\n// Returns\n\n5 // number of articles\n\n\nTypeScript Support\n\nNuxt Content v2 is built with TypeScript in mind.\n\nfetchContentNavigation()\n\nThe fetchContentNavigation utility returns a tree of items based on the content/ directory structure and files."
  },
  {
    "title": "TypeScript Support - Nuxt Content",
    "url": "https://content.nuxt.com/usage/typescript/",
    "html": "Usage\n\nTypeScript Support\n\nNuxt Content v2 is built with TypeScript in mind.\n\nTypings properly\n\nThe module exposes typings properly from configuration to query builder.\n\nUsage\n\nWhen using queryContent(), you will retrieve a QueryBuilder instance.\n\nOnce you use one of the fetching methods (find(), findOne(), findSurround()), you will retrieve an object of type ParsedContent.\n\nType augmentation\n\nIf you are adding keys to the front-matter other than the default keys, you might want to have typings over these.\n\nThis is currently possible, yet not in an optimal way.\n\nThe recommended way to do it is by using this method:\n\n<script setup lang=\"ts\">\n\nimport type { ParsedContent } from '@nuxt/content/dist/runtime/types'\n\n\n\ninterface MyCustomParsedContent extends ParsedContent {\n\n  yourOwn: 'keys'\n\n  foo: 'bar'\n\n  baz: 'bar'\n\n}\n\n\n\n// That `data` key will be typed with `MyCustomParsedContent`\n\nconst { data } = await useAsyncData(\n\n  () => queryContent<MyCustomParsedContent>({ ...anyQuery })\n\n)\n\n</script>\n\nMarkdown Specific Types\n\nIf you know the content being fetched will be Markdown, then you can extend the MarkdownParsedContent type for improved type-safety.\n\n<script setup lang=\"ts\">\n\nimport type { MarkdownParsedContent } from '@nuxt/content/dist/runtime/types'\n\n\n\ninterface Article extends MarkdownParsedContent {\n\n  author: string\n\n}\n\nconst { data } = await useAsyncData(\n\n  'first-article',\n\n  () => queryContent<Article>('articles').findOne()\n\n)\n\n// data.value.author will be typed as well as markdown specific entries\n\n</script>\n\nThe future\n\nTypeScript support is a strong focus for us.\n\nWe want to provide fully generated type for each content in your project, that would allow the same as type augmentation.\n\nThis is not yet implemented but will be part of the roadmap in upcoming months.\n\nYou can track #1057 if you want to know more about roadmap for TypeScript support of front-matter keys.\n\nFetch Navigation\n\nComponent and composable to display a navigation\n\nqueryContent()\n\nThe queryContent composable provides methods for querying and fetching your contents."
  },
  {
    "title": "Fetch Navigation - Nuxt Content",
    "url": "https://content.nuxt.com/usage/navigation/",
    "html": "Usage\n\nFetch Navigation\n\nComponent and composable to display a navigation\n\nSelf-managed navigation\n\nNuxt Content provides a component and composable to display a navigation based on the content/ directory structure and files.\n\nBased on the generated _id and _path keys, Nuxt Content generates a whole navigation structure for your content.\n\nIt allows you to create advanced navigation components without having to maintain any querying logic related to it.\n\nStructure\n\nThe navigation object can be seen as a tree, representing the structure of your content sources in JSON format.\n\nIt is divided into two types of nodes: pages and directories.\n\nDirectory structure\nDirectory node\nPage node\nComplete navigation\ncontent/\n  my-directory/\n    page.md\n\nCustom keys\n\nYou can use the navigation property in the front-matter of your content files to add keys to the navigation object.\n\nindex.md\nNavigation\n---\n\nnavigation:\n\n  title: 'Home'\n\n  icon: 'ðŸ¡'\n\n---\n\n\n\n# Welcome\n\n\nAlternatively, the navigation also allows you to configure directory nodes via _dir.yml files.\n\nIt allows you to overwrite the title and custom properties to directory nodes in navigation.\n\nDirectory structure\n_dir.yml\nNavigation\ncontent/\n  my-directory/\n    _dir.yml\n    page.md\n\n\nIf you want to use top-level keys in the front-matter to be included in the navigation object, use the content.navigation.fields property in the nuxt.config:\n\nnuxt.config.ts\npage.md\nNavigation node\ndefineNuxtConfig({\n\n  content: {\n\n    navigation: {\n\n      fields: ['author', 'publishedAt']\n\n    }\n\n  }\n\n})\n\nExcluding\n\nSet navigation: false in the front-matter of a page to filter it out.\n\npage.md\n---\n\nnavigation: false\n\n---\n\n\nThis pattern also works inside _dir.yml file, allowing you to filter out content directories and files.\n\n_dir.yml\nnavigation: false\n\n\nYou can also use the _ content prefix to exclude content directories and files.\n\nDirectory structure\nNavigation object\ncontent/\n  _hidden-directory/\n    page.md\n    index.md\n  not-hidden-directory/\n    _dir.yml\n    index.md\n    page.md\n\nNested navigation\n\nYou can pass a queryContent() instance to the fetchContentNavigation() utility to filter the items returned.\n\nThat allows to create navigation objects for which the starting point is based on a specific content directory.\n\nconst query = queryContent({\n\n  where: {\n\n    _path: { $contains: '/your/navigation/starting/point' }\n\n  }\n\n})\n\nGo deeper in the API section:\nfetchContentNavigation() composable to fetch navigation in <script>\n<ContentNavigation> component made to shorten access to navigation in <template>\n\nSearch\n\nWith some simple configuration and a composable, you can add search to your Nuxt Content site.\n\nTypeScript Support\n\nNuxt Content v2 is built with TypeScript in mind."
  },
  {
    "title": "Search - Nuxt Content",
    "url": "https://content.nuxt.com/usage/search/",
    "html": "Usage\n\nSearch\n\nWith some simple configuration and a composable, you can add search to your Nuxt Content site.\n\nUsage\n\nFirst, you need to enable the search feature in your nuxt.config.ts:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  content: {\n\n    experimental: {\n\n      search: true\n\n    }\n\n  }\n\n})\n\nYou can use the search feature with any Nuxt Content source. You can also enable or not the document-driven feature.\nSearch\n\nYou can use the searchContent composable to search in your content directory:\n\napp.vue\n<script lang=\"ts\" setup>\n\nconst search  = ref('')\n\n\n\nconst results = searchContent(search)\n\n</script>\n\n\n\n<template>\n\n  <main>\n\n    <input v-model=\"search\">\n\n\n\n    <pre>{{ result }} </pre>\n\n  </main>\n\n</template>\n\n\nBy default, the searchContent composable will use an indexed search. This means that the search is faster and the API response is smaller and optimized. The response is only usable by miniSearch.\n\nInternally, both the searchContent composable and the /api/indexed-search.ts endpoint use miniSearch.\nSimple Search\n\nIf needed, you can disable the indexed search and use a simple search instead:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  content: {\n\n    experimental: {\n\n      search: {\n\n        indexed: false\n\n      }\n\n    }\n\n  }\n\n})\n\n\nRemember that the simple search is slower and the API response bigger. You can still use the searchContent composable which is agnostic of the search type.\n\nCustom Search\n\nUsing the simple search, aka non-indexed search, you can use the tool of your choice to search in the API response. For example, you can use fuse.js with the integration of @vueuse/integrations:\n\ncomposables/custom-search-content.ts\nexport default async function customSearchContent(search: Ref<string>) {\n\n  const runtimeConfig = useRuntimeConfig()\n\n  const { integrity, api } = runtimeConfig.public.content\n\n\n\n  const { data } = await useFetch(`${api.baseURL}/search${integrity ? '.' + integrity : ''}.json`)\n\n\n\n  const { results } = useFuse(search, data)\n\n\n\n  return results\n\n}\n\nConfiguration\n\nPlease, read the configuration section to learn more about the search options.\n\nRender Content\n\nRender the body of a Markdown document in a rich-text format.\n\nFetch Navigation\n\nComponent and composable to display a navigation"
  },
  {
    "title": "Render Content - Nuxt Content",
    "url": "https://content.nuxt.com/usage/render/",
    "html": "Usage\n\nRender Content\n\nRender the body of a Markdown document in a rich-text format.\n\n<ContentDoc />\n\nThe <ContentDoc> component fetches a document and renders it in a rich-text format.\n\nBy default it fetchs the current route ($route.path) but an explicit path can be passed to the component with the path prop.\n\nCreate a catch all route named pages/[...slug].vue and add the component:\n\npages/[...slug].vue\n<template>\n\n  <main>\n\n    <ContentDoc />\n\n  </main>\n\n</template>\n\n\nIt will fetch the document corresponding to the $route.path and render it. It will also handle the head management using useContentHead() section.\n\nYou can use the <ContentDoc> component to render a specific document by specifying the path property:\n\napp.vue\n<template>\n\n  <main>\n\n    <ContentDoc path=\"/about\" />\n\n  </main>\n\n</template>\n\nHead over to the <ContentDoc> API section.\n<ContentRenderer />\n\nThe <ContentRenderer> component renders the body of a Markdown document returned by queryContent() in a rich-text format. It fallbacks to rendering the content in a <pre> tag if the content is not Markdown (source code).\n\n<ContentRenderer> accepts a value prop containing the data.\n\napp.vue\n<script setup>\n\nconst { data } = await useAsyncData('hello', () => queryContent('/hello').findOne())\n\n</script>\n\n\n\n<template>\n\n  <ContentRenderer :value=\"data\" />\n\n</template>\n\nHead over to the <ContentRenderer> and queryContent() API sections to learn more.\n\nJSON, YAML, CSV\n\nNuxt Content can also query JSON, YAML and CSV content.\n\nSearch\n\nWith some simple configuration and a composable, you can add search to your Nuxt Content site."
  },
  {
    "title": "JSON, YAML, CSV - Nuxt Content",
    "url": "https://content.nuxt.com/usage/files/",
    "html": "Usage\n\nJSON, YAML, CSV\n\nNuxt Content can also query JSON, YAML and CSV content.\n\nJSON\n\nNuxt Content can query JSON formatted content.\n\ncontent/hello.json\nQuery\nOutput\n{\n\n  \"title\": \"Hello Content v2!\",\n\n  \"description\": \"The writing experience for Nuxt 3\",\n\n  \"category\": \"announcement\"\n\n}\n\nIf the document root is an object {}, the output contains all the document properties at its root. If the document root is an array [], the output contains all the document properties in a body property.\nYAML / YML\n\nNuxt Content can query YAML / YML formatted content.\n\ncontent/hello.yml\nQuery\nOutput\ntitle: Hello Content v2!\n\ndescription: The writing experience for Nuxt 3\n\ncategory: announcement\n\nIf the document root is based on key-value pairs, the output contains all the document properties at its root. If the document root is a list -, the output contains all the document properties in a body property.\nCSV\n\nNuxt Content can query CSV formatted content.\n\nvscode-icons:file-type-csv\ncontent/hello.csv\nQuery\nOutput\ntitle,description,category\nHello Content v2!,The writing experience for Nuxt 3,announcement\n\nThe body of the output is an array containing every row as objects.\n\nMarkdown\n\nNuxt Content uses the Markdown syntax and conventions to provide a rich-text editing experience.\n\nRender Content\n\nRender the body of a Markdown document in a rich-text format."
  },
  {
    "title": "Markdown - Nuxt Content",
    "url": "https://content.nuxt.com/usage/markdown/",
    "html": "Usage\n\nMarkdown\n\nNuxt Content uses the Markdown syntax and conventions to provide a rich-text editing experience.\n\nIntroduction\n\nWe created the MDC syntax to supercharge Markdown and give you the ability to leverage the power of Vue components with slots and props.\n\nInstall the MDC VS Code extension to get proper syntax highlighting for your MDC components.\nFront-matter\n\nFront-matter is a convention of Markdown-based CMS to provide meta-data to pages, like description or title. In Nuxt Content, the front-matter uses the YAML syntax with key: value pairs.\n\nThese data are available when rendering the content and can hold any information that you would need.\n\nSyntax\n\nYou can declare a front-matter block at the top of the Markdown files in the content/ directory with the --- identifier.\n\ncontent/index.md\n---\n\ntitle: 'Title of the page'\n\ndescription: 'meta description of the page'\n\n---\n\n\n\n<!-- Content of the page -->\n\nNative parameters\nKey\tType\tDefault\tDescription\ntitle\tstring\tFirst <h1> of the page\tTitle of the page, will also be injected in metas\ndescription\tstring\tFirst <p> of the page\tDescription of the page, will be shown below the title and injected into the metas\ndraft\tboolean\tfalse\tMark the page as draft (and only display it in development mode).\nnavigation\tboolean\ttrue\tDefine if the page is included in fetchContentNavigation return value.\nhead\tobject\ttrue\tEasy access to useContentHead\n\nWhen used together with <ContentDoc> or the document-driven mode to display the current page, the useContentHead() composable will be used to set the page's metadata.\n\nExcerpt\n\nContent excerpt or summary can be extracted from the content using <!--more--> as a divider.\n\n---\n\ntitle: Introduction\n\n---\n\n\n\nLearn how to use @nuxt/content.\n\n<!--more-->\n\nFull amount of content beyond the more divider.\n\n\nDescription property will contain the excerpt content unless defined within the Front Matter props.\n\nIf there is no <!--more--> divider in the text then excerpt is undefined.\n\nExample variables will be injected into the document:\n\n{\n\n  \"_id\": \"content:index.md\"\n\n  \"excerpt\": Object\n\n  \"body\": Object\n\n  // ... other keys\n\n}\n\nCode Highlighting\n\nNuxt Content uses Shikiji, that colors tokens with VSCode themes.\n\nCode highlighting works both on ProseCode and ProseCodeInline.\n\nEach line of a code block gets its line number in the line attribute so lines can be labeled or individually styled.\n\nRead the API reference to configure or entirely disable syntax highlighting.\nImages\n\nYou can add images to your public directory:\n\ncontent/\n  index.md\npublic/\n  img/\n    image.png\nnuxt.config.ts\npackage.json\ntsconfig.json\n\n\nAnd then use them in your markdown files in the content directory as such:\n\ncontent/index.md\n![my image](/img/image.png)\n\nVue Components\n\nEvery Vue component created inside the components/content/ directory will be available in Markdown files.\n\nComponents that are used in Markdown has to be marked as global in your Nuxt app if you don't use the components/content/ directory, visit Nuxt 3 docs to learn more about it.\nBlock Components\n\nBlock components are components that accept Markdown content or another component as a slot.\n\nThe component must contain either:\n\nA <slot /> to accept raw text or another component.\nThe <ContentSlot /> component to accept formatted text.\n\nIn a markdown file, use the component with the :: identifier.\n\nindex.md\nCard.vue\nPreview\n::card\n\nThe content of the card\n\n::\n\nSlots\n\nA component's slots can accept content or another components.\n\nThe default slot renders the top-level content inside the block component.\nnamed slots use the # identifier to render the corresponding content.\nindex.md\nHero.vue\nPreview\n::hero\n\nDefault slot text\n\n\n\n#description\n\nThis will be rendered inside the `description` slot.\n\n::\n\nNesting\n\nMDC supports nested components inside slots by indenting them.\n\nindex.md\nPreview\n::hero\n\n  :::card\n\n    A nested card\n\n    ::card\n\n      A super nested card\n\n    ::\n\n  :::\n\n::\n\nYou can add more :::: when nesting components as a visual reminder.\nMarkdown rendering\n\nThe <ContentSlot /> component is auto-imported by Nuxt Content. It acts as a special slot that accepts rich text rendered by Markdown.\n\nThe unwrap prop accepts an HTML tag that will be used to unwrap the content, useful when using tags such as title tags (<h1>, <h2>, ...) or inline tags (<button>, <a>, ...).\n\nTheTitle.vue\nindex.md\nPreview\n<!-- components/content/TheTitle.vue -->\n\n<template>\n\n  <h1 class=\"text-4xl\">\n\n    <ContentSlot :use=\"$slots.default\" unwrap=\"p\" />\n\n  </h1>\n\n</template>\n\n\nThe <ContentSlot /> component can act as a named slot with the use property:\n\n<ContentSlot :use=\"$slots.description\" unwrap=\"p\">\n\nInline components\n\nInline components are components without slots or <ContentSlot />.\n\nThey can be used with the : identifier.\n\nindex.md\nBanner.vue\n# Title\n\n\n\n:banner\n\n\nIf you want to use an inline component followed by specific characters like -, _ or :, you can use a dummy props specifier after it.\n\n:hello{}-world\n\n\nIn this example, :hello{} will search for the <Hello /> component, and -world will be plain text.\n\nProps\n\nThere are two ways to pass props to components using MDC.\n\nInline method\n\nThe {} identifier passes props to components in a terse way by using a key=value syntax.\n\nindex.md\nAlert.vue\nPreview\n::alert{type=\"warning\"}\n\nThe **alert** component.\n\n::\n\n\nMultiple props can be separated with a space:\n\n::alert{type=\"warning\" icon=\"exclamation-circle\"}\n\nOops! An error occurred\n\n::\n\n\nThe v-bind shorthand : can be also be used to bind a prop to a value in the front matter.\n\n---\n\ntype: \"warning\"\n\n---\n\n\n\n::alert{:type=\"type\"}\n\nYour warning\n\n::\n\n\nIf you want to pass arrays or objects as props to components you can pass them as JSON string and prefix the prop key with a colon to automatically decode the JSON string. Note that in this case you should use single quotes for the value string so you can use double quotes to pass a valid JSON string:\n\narray.md\nnumber-array.md\nobject.md\n::dropdown{:items='[\"Nuxt\", \"Vue\", \"React\"]'}\n\n::\n\nYAML method\n\nThe YAML method uses the --- identifier to declare one prop per line, that can be useful for readability.\n\nindex.md\nIconCard.vue\nPreview\n::icon-card\n\n---\n\nicon: IconNuxt\n\ndescription: Harness the full power of Nuxt and the Nuxt ecosystem.\n\ntitle: Nuxt Architecture.\n\n---\n\n::\n\nSpan Text\n\nTo create inline spans in your text you can use the [] identifier.\n\nCode\nPreview\nHello [World]{style=\"background-color: var(--color-primary-500)\"}!\n\nAttributes\n\nAttributes are useful for highlighting and modifying part of paragraph. The syntax is nearly similar to inline components and markdown links syntax.\n\nPossible values â€‹â€‹are all named attributes, classes with the notation .class-name and an ID with #id-name.\n\nCode\nPreview\nHello [World]{style=\"color: green;\" .custom-class #custom-id}!\n\n\nIn addition to mdc components and span, attribute syntax will work on images, links, inline code, bold and italic text.\n\nCode\nPreview\nAttributes work on:\n\n\n\n- ![](/favicon.ico){style=\"display: inline; margin: 0;\"} image,\n\n- [link](#attributes){style=\"background-color: pink;\"}, `code`{style=\"color: cyan;\"},\n\n- _italic_{style=\"background-color: yellow; color:black;\"} and **bold**{style=\"background-color: lightgreen;\"} texts.\n\nBinding Data in Markdown\n\nYou can bind data within your Markdown document using the {{ $doc.variable || 'defaultValue' }} syntax. These values can be defined in the YAML front matter at the top of the document, within each MDC component, or injected using the data prop of the <ContentRendererMarkdown> component.\n\nExample 1: Define in YAML\n---\n\ntitle: 'Title of the page'\n\ndescription: 'meta description of the page'\n\ncustomVariable: 'Custom Value'\n\n---\n\n\n\n# The Title is {{ $doc.title }} and customVariable is {{ $doc.customVariable || 'defaultValue' }}\n\nExample 2: Define in external with <ContentRendererMarkdown>\n<template>\n\n  <div>\n\n    <ContentRendererMarkdown :value=\"data\" :data=\"mdcVars\"/>\n\n    <button type=\"button\" v-on:click=\"mdcVars.name = 'Hugo'\">Change name</button>\n\n  </div>\n\n</template>\n\n\n\n<script setup lang=\"ts\">\n\nconst { data } = await useAsyncData(() => queryContent('test').findOne());\n\nconst mdcVars = ref({ name: 'Maxime'});\n\n</script>\n\n\n\n# Hello {{ $doc.name || 'World' }}\n\nProse Components\n\nIn Nuxt Content, the prose represents HTML tags generated by the Markdown syntax, such as title levels and links.\n\nFor each HTML tag, a Vue component is used, allowing you to override them if needed, for example <p> becomes <ProseP>.\n\nIf you want to customize a Prose component, here are the recommended steps:\n\nCheckout the original component sources.\nUse the exact same props.\nIn your components/content/ directory, give it the same name.\nMake it yours ðŸš€.\nRead the complete Prose reference in the Prose Components section.\n\nContent Directory\n\nThe Content module parses .md and .yaml files inside the content/ directory and provides paths according to the directory structure.\n\nJSON, YAML, CSV\n\nNuxt Content can also query JSON, YAML and CSV content."
  },
  {
    "title": "Content Directory - Nuxt Content",
    "url": "https://content.nuxt.com/usage/content-directory/",
    "html": "Usage\n\nContent Directory\n\nThe Content module parses .md and .yaml files inside the content/ directory and provides paths according to the directory structure.\n\nPaths\n\nNuxt Content will automatically generate paths for your content files.\n\nFile\tInternal path\ncontent/index.md\t/\ncontent/about.md\t/about\ncontent/blog/index.md\t/blog\ncontent/blog/hello.md\t/blog/hello\ncontent/1.guide/2.installation\t/guide/installation\n\nThe module creates REST GET endpoints for every document in the content/ directory reachable with the /api/_content/query route.\n\nComponents and pages can query contents using queryContent().\n\nOrdering\n\nAdd numeric prefixes to files and directories inside the content/ directory to specify an order. Nuxt Content uses these numbers to order content lists.\n\nDirectory structure\ncontent/\n  1.frameworks/\n    1.vue.md\n    2.nuxt.md\n  2.examples/\n    1.vercel.md\n    2.netlify.md\n    3.heroku.md\n    index.md\n\nSeparate number from file name using . character. Using any other separator will not work.\nIgnoring\n\nContent module will ignore files and folders starting with a ..\n\nDirectory structure\ncontent/\n  1.frameworks/\n    .1.vue.md              // Ignored content\n    2.nuxt.md\n  .2.translation/          // Ignored directory\n    1.fa/\n      1.messages.md        // Ignored content because of its grand parent\n    2.fr/\n      1.messages.md        // Ignored content because of its grand parent\n\nPartials\n\nAdding _ prefix to files will mark them as partial contents.\n\nPartial contents are accessible in search and content lists but are not displayed in content navigation.\n\nDirectory structure\ncontent/\n  1.frameworks/\n    _1.vue.md              // Partial content\n    2.nuxt.md\n  _2.translation/          // Partial directory\n    1.fa/\n      1.messages.md        // Partial content because of its grand parent\n    2.fr/\n      1.messages.md        // Partial content because of its grand parent\n\nStarting a directory name with _ will mark its entire nested content as partial.\n\nYou can query partials by using queryContent().where({ _partial: true }).\n\nMigration\n\nLearn how to upgrade from Nuxt Content V1 to Nuxt Content V2 with Nuxt 3.\n\nMarkdown\n\nNuxt Content uses the Markdown syntax and conventions to provide a rich-text editing experience."
  },
  {
    "title": "Migration - Nuxt Content",
    "url": "https://content.nuxt.com/get-started/from-v1/",
    "html": "Get Started\n\nMigration\n\nLearn how to upgrade from Nuxt Content V1 to Nuxt Content V2 with Nuxt 3.\n\nContent V1 Documentation\nRead V1 Documentation\nHow to Migrate\nMake sure your dev server (nuxt dev) isn't running and remove any package lock files (package-lock.json, yarn.lock, or pnpm-lock.yaml)\nUpgrade to Nuxt 3 (check out the Nuxt 3 migration guide)\n- \"nuxt\": \"latest\"\n\n+ \"nuxt\": \"^3.0.0\"\n\nUpgrade Content module\n- \"@nuxt/content\": \"^1.15.1\"\n\n+ \"@nuxt/content\": \"^2.0.0\"\n\nThen, reinstall your dependencies:\nnpm install\n\nGlobal Components\n\nThe global components directory for Nuxt Content v2 is now ~/components/content.\n\n- components/global\n\n+ components/content\n\nFetching Content\n\nThere is no global $content variable, instead you can use queryContent composable to fetch contents.\n\n- const posts = await this.$content('/blog', { deep: true }).only(['title']).fetch()\n\n+ const { data: posts } = await useAsyncData('posts-list', () => queryContent('/blog').only(['title']).find())\n\n\nqueryContent provides same utilities as legacy $content with some improvements:\n\nfetch dropped in favor of new find utils\nfind: retrieve a list of contents\nfindOne: retrieve first matched content\nsurround dropped in favor of findSurround\nwhere utility can be chained\nqueryContent()\n\n  .where({ /* first step conditions */ })\n\n  .where({ /* second step conditions */ })\n\n  .find()\n\nThere is no search utility for full text search.\nconst doc = await getContentDocument(post.id)\n\nThere is a new fetchContentNavigation utility is designed to provide a tree of items based on the content/ directory structure.\nRendering Content\n\n<NuxtContent> component removed in favor of a <ContentRenderer> component.\n\n<ContentDoc> component receives a document path and then fetches and renders the document.\n\n<script setup lang=\"ts\">\n\nconst route = useRoute()\n\n\n\nconst { data } = await useAsyncData('get-document', () => queryContent(route.path).findOne())\n\n</script>\n\n\n\n<template>\n\n  <ContentRenderer :value=\"data\" />\n\n</template>\n\n\nYou can go even faster if you know that route.path will be the same as your content files, use the <ContentDoc> component:\n\n<template>\n\n  <ContentDoc />\n\n</template>\n\n\nThe <ContentDoc> component will fetch the document for the current route path and use <ContentRenderer> to render it.\n\nFeature comparison\nFeature / Version\tContent v1\tContent v2\nNuxt Version\tnuxt@2.x\tnuxt@3.x\nSupported files\t.md, .yaml, .yml, .csv, .json, .json5, .xml\t.md, .yaml, .yml, .csv, .json, .json5\nFull text search\tâœ…\tâŒ\nReactive Composables\tâŒ\tâœ…\nFrontMatter\tâœ…\tâœ…\nExcerpt\tâœ…\tâœ…\nTable Of Contents\tâœ…\tâœ…\nMDC Components syntax\tâŒ\tâœ…\nMulti Source\tâŒ\tâœ…\nLocale Support\tâŒ\tâœ…\nContent Navigation\tâŒ\tâœ…\nQuerying content\nLearn more about query methods in the API reference\n\nEdge Channel\n\nNuxt Content is landing commits, improvements, and bug fixes every day. You can opt-in to test them earlier before the next release.\n\nContent Directory\n\nThe Content module parses .md and .yaml files inside the content/ directory and provides paths according to the directory structure."
  },
  {
    "title": "Edge Channel - Nuxt Content",
    "url": "https://content.nuxt.com/get-started/edge-channel/",
    "html": "Get Started\n\nEdge Channel\n\nNuxt Content is landing commits, improvements, and bug fixes every day. You can opt-in to test them earlier before the next release.\n\nAutomated release\n\nAfter each commit is merged into the main branch of @nuxt/content and passing all tests, we trigger an automated npm release using Github Actions publishing a @nuxt/content-edge package.\n\nYou can opt in to use this release channel and avoid waiting for the next release and helping the module by beta testing changes.\n\nThe build and publishing method and quality of edge releases are the same as stable ones. The only difference is that you should often check the GitHub repository for updates. There is a slight chance of regressions not being caught during the review process and by the automated tests. Therefore, we internally use this channel to double-check everything before each release.\n\nFeatures only available on the edge channel are marked with an alert in the documentation.\nOpting into the edge channel\n\nUpdate @nuxt/content dependency inside package.json:\n\npackage.json\n{\n\n  \"devDependencies\": {\n\n-   \"@nuxt/content\": \"^2.0.0\"\n\n+   \"@nuxt/content\": \"npm:@nuxt/content-edge@latest\"\n\n  }\n\n}\n\n\nRemove lockfile (package-lock.json, yarn.lock, or pnpm-lock.yaml) and reinstall dependencies.\n\nOpting out from the edge channel\n\nUpdate @nuxt/content dependency inside package.json:\n\npackage.json\n{\n\n  \"devDependencies\": {\n\n-   \"@nuxt/content\": \"npm:@nuxt/content-edge@latest\"\n\n+   \"@nuxt/content\": \"^2.0.0\"\n\n  }\n\n}\n\n\nRemove lockfile (package-lock.json, yarn.lock, or pnpm-lock.yaml) and reinstall dependencies.\n\nConfiguration\n\nNuxt Content has many properties that can be configured to fit your needs.\n\nMigration\n\nLearn how to upgrade from Nuxt Content V1 to Nuxt Content V2 with Nuxt 3."
  },
  {
    "title": "Configuration - Nuxt Content",
    "url": "https://content.nuxt.com/get-started/configuration/",
    "html": "Get Started\n\nConfiguration\n\nNuxt Content has many properties that can be configured to fit your needs.\n\nYou can configure Nuxt Content with the content property in your nuxt.config file.\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  content: {\n\n    // My custom configuration\n\n  }\n\n})\n\napi\nType: Record<string, any>\nDefault: { baseURL: '/api/_content' }\n\nChange default behaviour of Content APIs.\n\nbaseURL: change the base URL of Content APIs. Default is /api/_content.\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  content: {\n\n    api: {\n\n      baseURL: '/api/_my_content'\n\n    }\n\n  }\n\n})\n\ncontentHead\nType: boolean\nDefault: true\n\nEnable content head feature. If enabled, module will automatically use useContentHead composable to inject content head data to your page.\n\ndefaultLocale\nType: string\nDefault: undefined\n\nDefault locale for top level contents. Module will use first locale code from locales array if this option is not defined.\n\nNote that in case of defining multiple locales, Module will filter content with defaultLocale. If you want to fetch contents of another locale, you need to use where option.\ndocumentDriven\nType: boolean | object\nDefault: false\n\nToggles the document-driven mode.\n\nfalse will disable the feature completely.\n\ntrue will enable the feature with these defaults:\n\nDocument-driven defaults\n{\n\n  // Will fetch navigation, page and surround.\n\n  navigation: true,\n\n  page: true,\n\n  surround: true,\n\n  // Will fetch `content/_theme.yml` and put it in `globals.theme` if present.\n\n  globals: {\n\n    theme: {\n\n      where: {\n\n        _id: 'content:_theme.yml'\n\n      },\n\n      without: ['_']\n\n    }\n\n  },\n\n  // Will use `theme` global to search for a fallback `layout` key.\n\n  layoutFallbacks: ['theme'],\n\n  // Will inject `[...slug].vue` as the root page.\n\n  injectPage: true\n\n}\n\nOption\tType\tDescription\npage\tboolean\tEnables the page binding, making it globally accessible.\nnavigation\tboolean\tEnables the navigation binding, making it globally accessible.\nsurround\tboolean\tEnables the surround binding, making it globally accessible.\nglobals\tobject | boolean\tA list of globals to be made available globally.\nlayoutFallbacks\tstring[]\tA list of globals key to use to find a layout fallback.\ninjectPage\tboolean\tInject [...slug].vue pre-configured page\ntrailingSlash\tboolean\tAdd a slash at the end of canonical and og:url\nmarkdown\nanchorLinks: Control anchor link generation, by default it generates anchor links for h2, h3 and h4 heading\nType: boolean | object\nDefault: { depth: 4, exclude: [1] }\nValues:\nfalse will disable link generation.\ntrue will enable link generation for all headings.\nobject will customize the link generation.\nOption\tType\tDescription\ndepth\tnumber\tSets the maximal depth for anchor link generation.\nexclude\tnumber[]\tA list of headings to exclude from link generation.\nmdc: Whether MDC syntax should be supported or not.\nType: boolean\nDefault: true\nremarkPlugins: A list of remark plugins to use.\nType: object\nDefault: {}\nExample\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  content: {\n\n    markdown: {\n\n      // Object syntax can be used to override default options\n\n      remarkPlugins: {\n\n        // Override remark-emoji options\n\n        'remark-emoji': {\n\n          emoticon: true\n\n        },\n\n        // Disable remark-gfm\n\n        'remark-gfm': false,\n\n        // Add remark-oembed\n\n        'remark-oembed': {\n\n          // Options\n\n        }\n\n      },\n\n    }\n\n  }\n\n})\n\nrehypePlugins: A list of rehype plugins to use.\nType: string[]\nDefault: []\nExample:\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  content: {\n\n    markdown: {\n\n      rehypePlugins: [\n\n        'rehype-figure'\n\n      ]\n\n    }\n\n  }\n\n})\n\ntoc: Control behavior of Table of Contents generation.\nType: object\nDefault: { depth: 2, searchDepth: 2 }\ndepth: Maximum heading depth to include in the table of contents.\nsearchDepth: Maximum depth of nested tags to search for heading.\ntags: Tags will be used to replace markdown components and render custom components instead of default ones.\nType: object\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  content: {\n\n    markdown: {\n\n      tags: {\n\n        p: 'MyCustomParagraph'\n\n      }\n\n    }\n\n  }\n\n})\n\nhighlight\nType: false | object\n\nNuxt Content uses Shikiji to provide syntax highlighting for ProseCode and ProseCodeInline.\n\nOption\tType\tDescription\ntheme\tShikiTheme or Record<string, ShikiTheme>\tThe color theme to use.\npreload\tShikiLang[]\tThe preloaded languages available for highlighting.\nhighlight.theme\n\nTheme can be specified by a single string but also supports an object with multiple themes.\n\nThis option is compatible with Color Mode module.\n\nIf you are using multiple themes, it's recommended to always have a default theme specified.\n\nexport default defineNuxtConfig({\n\n  content: {\n\n    highlight: {\n\n      // Theme used in all color schemes.\n\n      theme: 'github-light'\n\n      // OR\n\n      theme: {\n\n        // Default theme (same as single string)\n\n        default: 'github-light',\n\n        // Theme used if `html.dark`\n\n        dark: 'github-dark',\n\n        // Theme used if `html.sepia`\n\n        sepia: 'monokai'\n\n      }\n\n    }\n\n  }\n\n})\n\nhighlight.preload\n\nBy default, module preloads couple of languages for syntax highlighter: ['diff', 'json', 'js', 'ts', 'css', 'shell', 'html', 'md', 'yaml']\n\nIf you plan to use code samples of other languages, you need to define the language in these options.\n\nexport default defineNuxtConfig({\n\n  content: {\n\n    highlight: {\n\n      preload: [\n\n        'c',\n\n        'cpp',\n\n        'java'\n\n      ]\n\n    }\n\n  }\n\n})\n\n\nIf you wish to add highlighting for an unsupported language, you can do so by loading the grammar file for the language.\n\nimport { readFileSync } from 'node:fs'\n\n\n\nexport default defineNuxtConfig({\n\n  content: {\n\n    highlight: {\n\n      preload: [\n\n        // Read more about shikiji languages: https://github.com/antfu/shikiji#fine-grained-bundle\n\n        JSON.parse(\n\n          readFileSync('./shiki/languages/gdscript.tmLanguage.json', 'utf-8'),\n\n        ),\n\n      ],\n\n    },\n\n  },\n\n})\n\n\nRead more about adding languages in the Shiki documentation.\n\nignores\nType: string[]\nDefault: ['\\\\.', '-']\n\nList of ignore patterns to exclude content from parsing, rendering and watching.\n\nNote that:\n\npatterns are converted to regular expressions\n. and - prefixed files are ignored by default\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  content: {\n\n    ignores: [\n\n      'hidden',        // any file or folder that contains the word \"hidden\"\n\n      '/hidden/',      // any folder that exactly matches the word \"hidden\"\n\n      '/path/to/file', // any file path matching \"/path/to/file\"\n\n      '\\\\.bak$',       // any file with the extension \".bak\"\n\n    ]\n\n  }\n\n})\n\nlocales\nType: string[]\nDefault: []\n\nList of locale codes. This codes will be used to detect contents locale.\n\nnavigation\nType: false | object\nDefault: true\n\nConfigure the navigation feature.\n\nCan be set to false to disable the feature completely.\n\nOption\tType\tDescription\nfields\tstring[]\tA list of fields to inherit from front-matter to navigation nodes.\ndefineNuxtConfig({\n\n  content: {\n\n    navigation: {\n\n      fields: ['author', 'publishedAt']\n\n    }\n\n  }\n\n})\n\nrespectPathCase\nType: boolean\nDefault: false\n\nWhether to respect the case of the file path when generating the route. Defaults to false, which means the route will be generated in lowercase. For example, content/en-US/foo.md will resolve to the en-us/foo path. This may not be what you expect.If set to true, the route will be generated with the same case as the file path. content/en-US/foo.md will resolve to the en-US/foo path.\n\nsources\nType: Record<string, object>\nDefault: {}\n\nDefine different sources for contents.\n\nContents can be located in multiple places, in multiple directories, or in remote git repositories thanks to unstorage.\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  content: {\n\n    sources: {\n\n      // overwrite default source AKA `content` directory\n\n      content: {\n\n        driver: 'fs',\n\n        prefix: '/docs', // All contents inside this source will be prefixed with `/docs`\n\n        base: resolve(__dirname, 'content')\n\n      }\n\n      // Additional sources\n\n      fa: {\n\n        prefix: '/fa', // All contents inside this source will be prefixed with `/fa`\n\n        driver: 'fs',\n\n        // ...driverOptions\n\n        base: resolve(__dirname, 'content-fa') // Path for source directory\n\n      },\n\n      github: {\n\n        prefix: '/blog', // Prefix for routes used to query contents\n\n        driver: 'github', // Driver used to fetch contents (view unstorage documentation)\n\n        repo: \"<owner>/<repo>\",\n\n        branch: \"main\",\n\n        dir: \"content\", // Directory where contents are located. It could be a subdirectory of the repository.\n\n        // Imagine you have a blog inside your content folder. You can set this option to `content/blog` with the prefix option to `/blog` to avoid conflicts with local files.\n\n      },\n\n    }\n\n  }\n\n})\n\nIt is highly recommended to prevent modifying default source. If you want to load contents from another location, consider adding an additional source.\nwatch\nType: object | false\nDefault: { ws: { port: 4000, showUrl: true } }\nOption\tDefault\tDescription\nport\t4000\tSelect the port used for the WebSocket server.\nshowUrl\tfalse\tToggle URL display in dev server boot message.\n\nDisable content watcher and hot content reload.\n\nThe watcher is a development feature and will not be included in production.\n\nEnabled\nDisabled\nexport default defineNuxtConfig({\n\n  content: {\n\n    watch: {\n\n      ws: {\n\n        port: 4000,\n\n        showUrl: true\n\n      }\n\n    }\n\n  }\n\n})\n\nyaml\nType: false | object\nDefault: {}\n\nOptions for yaml parser.\n\nexperimental\nsearch\nType: boolean | undefined\nDefault: undefined\n\nEnable search feature.\n\nindexed\nType: boolean\nDefault: true\n\nEnable indexed search. This will generate a search index file that allow faster and more performant search.\n\nignoredTags\nType: string[]\nDefault: ['style', 'code']\n\nList of tags to ignore when parsing content for the search API response. This is useful to avoid including code snippets in the search results or style that does not provide any useful information.\n\nfilterQuery\nType: QueryBuilderWhere\nDefault: {}\n\nQuery to ignore when parsing content for the search API response. This is useful to avoid including content that is not meant to be searchable like drafts or private content.\n\noptions\nType: object\nDefault:\n{\n\n  fields: ['title', 'content', 'titles'],\n\n  storeFields: ['title', 'content', 'titles'],\n\n  searchOptions: {\n\n    prefix: true,\n\n    fuzzy: 0.2,\n\n    boost: {\n\n      title: 4,\n\n      content: 2,\n\n      titles: 1\n\n    }\n\n  }\n\n}\n\n\nWhen the indexed search is enabled, this option will automatically configure both the API endpoint and the searchContent composable. For simple search, you will need to pass the options to the searchContent composable.\n\nInstallation\n\nGet started with Nuxt Content by creating a new project or adding it to an existing Nuxt application.\n\nEdge Channel\n\nNuxt Content is landing commits, improvements, and bug fixes every day. You can opt-in to test them earlier before the next release."
  },
  {
    "title": "Installation - Nuxt Content",
    "url": "https://content.nuxt.com/get-started/installation/",
    "html": "Get Started\n\nInstallation\n\nGet started with Nuxt Content by creating a new project or adding it to an existing Nuxt application.\n\nPlay online\n\nYou can start playing with Nuxt Content in your browser using our online sandboxes:\n\nPlay on StackBlitz\nPlay on CodeSandbox\n\nOr open the embedded playground.\n\nNew Project\nBefore getting started, please make sure to have installed the recommended setup:\nFollow the Nuxt 3 Prerequisites\nDownload the VS Code MDC Extension\nYou can start a fresh Nuxt Content project with:\nTerminal\nnpx nuxi@latest init content-app -t content\n\n\nIt will ask you with which package manager you want to install the dependencies.\n\nMove into the content-app folder and start the development server:\npnpm\nyarn\nnpm\npnpm run dev\n\nâœ¨ Well done! A browser window should automatically open for http://localhost:3000\nðŸ‘‰ Next step is to head over the Writing section to learn how to use Nuxt Content.\nAdd to a project\n\nYou can add Nuxt Content at anytime during your Nuxt project development by installing the @nuxt/content module:\n\npnpm\nyarn\nnpm\npnpm add @nuxt/content\n\n\nThen, add @nuxt/content to the modules section of nuxt.config.ts:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  modules: [\n\n    '@nuxt/content'\n\n  ],\n\n  content: {\n\n    // ... options\n\n  }\n\n})\n\nCreate content\n\nPlace your markdown files inside the content/ directory in the root directory of your project.\n\ncontent/index.md\n# Hello Content\n\n\nThe module automatically loads and parses them.\n\nRender pages\n\nTo render content pages, add a catch-all route using the ContentDoc component:\n\npages/[...slug].vue\n<template>\n\n  <main>\n\n    <ContentDoc />\n\n  </main>\n\n</template>\n\nâš ï¸ If you have an app.vue file at the project's root, ensure that you include <NuxtPage /> in its template to render pages.\nâš ï¸ Content v2 requires Nuxt 3. If you are using Nuxt 2, checkout Content v1 documentation.\nðŸ‘‰ Next step is to head over the Writing section to learn how to use Nuxt Content.\n\nI am a partial\n\nWith some Hello World text.\n\nConfiguration\n\nNuxt Content has many properties that can be configured to fit your needs."
  }
]