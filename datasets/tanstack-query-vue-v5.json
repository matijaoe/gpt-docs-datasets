[
  {
    "title": "Overview | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/overview",
    "html": "Overview\n\nTanStack Query (FKA Vue Query) is often described as the missing data-fetching library for web applications, but in more technical terms, it makes fetching, caching, synchronizing and updating server state in your web applications a breeze.\n\nMotivation\n\nMost core web frameworks do not come with an opinionated way of fetching or updating data in a holistic way. Because of this developers end up building either meta-frameworks which encapsulate strict opinions about data-fetching, or they invent their own ways of fetching data. This usually means cobbling together component-based state and side-effects, or using more general purpose state management libraries to store and provide asynchronous data throughout their apps.\n\nWhile most traditional state management libraries are great for working with client state, they are not so great at working with async or server state. This is because server state is totally different. For starters, server state:\n\nIs persisted remotely in a location you do not control or own\nRequires asynchronous APIs for fetching and updating\nImplies shared ownership and can be changed by other people without your knowledge\nCan potentially become \"out of date\" in your applications if you're not careful\n\nOnce you grasp the nature of server state in your application, even more challenges will arise as you go, for example:\n\nCaching... (possibly the hardest thing to do in programming)\nDeduping multiple requests for the same data into a single request\nUpdating \"out of date\" data in the background\nKnowing when data is \"out of date\"\nReflecting updates to data as quickly as possible\nPerformance optimizations like pagination and lazy loading data\nManaging memory and garbage collection of server state\nMemoizing query results with structural sharing\n\nIf you're not overwhelmed by that list, then that must mean that you've probably solved all of your server state problems already and deserve an award. However, if you are like a vast majority of people, you either have yet to tackle all or most of these challenges and we're only scratching the surface!\n\nVue Query is hands down one of the best libraries for managing server state. It works amazingly well out-of-the-box, with zero-config, and can be customized to your liking as your application grows.\n\nVue Query allows you to defeat and overcome the tricky challenges and hurdles of server state and control your app data before it starts to control you.\n\nOn a more technical note, Vue Query will likely:\n\nHelp you remove many lines of complicated and misunderstood code from your application and replace with just a handful of lines of Vue Query logic.\nMake your application more maintainable and easier to build new features without worrying about wiring up new server state data sources\nHave a direct impact on your end-users by making your application feel faster and more responsive than ever before.\nPotentially help you save on bandwidth and increase memory performance"
  },
  {
    "title": "Community Projects | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/community/community-projects#query-key-factory",
    "html": "Community Projects\n\nThere are lots of community projects that build on top of React Query and use it to provide additional functionality or enhanced developer experience. Projects are listed in alphabetical order. If you have a project that you would like to add to this list, please open a PR!\n\nPlease note that these projects are entirely community maintained. If you have questions about these projects, please reach out to the project maintainers.\n\nbatshit\n\nA batch manager that will deduplicate and batch requests for a certain data type made within a window\n\nLink: https://github.com/yornaath/batshit\n\nBlitz\n\nThe Missing Fullstack Toolkit for Next.js\n\nLink: https://blitzjs.com/\n\nGraphQL Code Generator\n\nGenerate React Query hooks from your GraphQL schema\n\nLink: https://the-guild.dev/graphql/codegen\n\nHttp-wizard\n\nEnd-to-end type-safe Fastify API with typecript magic âœ¨\n\nLink: https://http-wizard.com\n\nKubb\n\nGenerate SDKs for all your APIs\n\nLink: https://www.kubb.dev/\n\nNgQuery\n\nQuery adapter for Angular\n\nLink: https://ngneat.github.io/query/\n\nNormy\n\nAutomatic normalization and data updates for data fetching libraries\n\nLink: https://github.com/klis87/normy\n\nOpenAPI codegen\n\nA tool for generating code based on an OpenAPI schema.\n\nLink: https://github.com/fabien0102/openapi-codegen\n\nOpenAPI React Query codegen\n\nGenerate TanStack Query hooks based on an OpenAPI specification file.\n\nLink: https://github.com/7nohe/openapi-react-query-codegen\n\nOpenAPI zod client\n\nGenerate a zodios client from an OpenAPI specification\n\nLink: https://github.com/astahmer/openapi-zod-client\n\nOrval\n\nGenerate TypeScript client from OpenAPI specifications\n\nLink: https://orval.dev/\n\nQuery Key factory\n\nA library for creating typesafe standardized query keys, useful for cache management in @tanstack/query\n\nLink: https://github.com/lukemorales/query-key-factory\n\nReact Query Kit\n\nðŸ•Šï¸ A toolkit for ReactQuery that makes ReactQuery hooks reusable and typesafe\n\nLink: https://github.com/liaoliao666/react-query-kit\n\nReact Query Swagger\n\nGenerate React Query hooks based on Swagger API definitions\n\nLink: https://github.com/Shaddix/react-query-swagger\n\ntRPC\n\nEnd-to-end typesafe APIs made easy\n\nLink: https://trpc.io/\n\nts-rest\n\nIncrementally adoptable type-safety for your new and existing APIs\n\nLink: https://ts-rest.com/\n\nwagmi\n\nReact Hooks for Ethereum based on @tanstack/react-query\n\nLink: https://wagmi.sh/\n\nzodios\n\nEnd-to-end typesafe REST API toolbox\n\nLink: https://www.zodios.org/\n"
  },
  {
    "title": "hydration | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/reference/hydration",
    "html": "hydration\ndehydrate\n\ndehydrate creates a frozen representation of a cache that can later be hydrated with HydrationBoundary or hydrate. This is useful for passing prefetched queries from server to client or persisting queries to localStorage or other persistent locations. It only includes currently successful queries by default.\n\ntsx\nimport { dehydrate } from '@tanstack/vue-query'\n\n\nconst dehydratedState = dehydrate(queryClient, {\n  shouldDehydrateQuery,\n  shouldDehydrateMutation,\n})\n\nOptions\n\nclient: QueryClient\nRequired\nThe queryClient that should be dehydrated\noptions: DehydrateOptions\nOptional\nshouldDehydrateMutation: (mutation: Mutation) => boolean\nOptional\nWhether to dehydrate mutations.\nThe function is called for each mutation in the cache\nReturn true to include this mutation in dehydration, or false otherwise\nDefaults to only including paused mutations\nIf you would like to extend the function while retaining the default behavior, import and execute defaultShouldDehydrateMutation as part of the return statement\nshouldDehydrateQuery: (query: Query) => boolean\nOptional\nWhether to dehydrate queries.\nThe function, it is called for each query in the cache\nReturn true to include this query in dehydration, or false otherwise\nDefaults to only including successful queries\nIf you would like to extend the function while retaining the default behavior, import and execute defaultShouldDehydrateQuery as part of the return statement\n\nReturns\n\ndehydratedState: DehydratedState\nThis includes everything that is needed to hydrate the queryClient at a later point\nYou should not rely on the exact format of this response, it is not part of the public API and can change at any time\nThis result is not in serialized form, you need to do that yourself if desired\nlimitations\n\nSome storage systems (such as browser Web Storage API) require values to be JSON serializable. If you need to dehydrate values that are not automatically serializable to JSON (like Error or undefined), you have to serialize them for yourself. Since only successful queries are included per default, to also include Errors, you have to provide shouldDehydrateQuery, e.g.:\n\ntsx\n// server\nconst state = dehydrate(client, { shouldDehydrateQuery: () => true }) // to also include Errors\nconst serializedState = mySerialize(state) // transform Error instances to objects\n\n\n// client\nconst state = myDeserialize(serializedState) // transform objects back to Error instances\nhydrate(client, state)\nhydrate\n\nhydrate adds a previously dehydrated state into a cache.\n\ntsx\nimport { hydrate } from '@tanstack/vue-query'\n\n\nhydrate(queryClient, dehydratedState, options)\n\nOptions\n\nclient: QueryClient\nRequired\nThe queryClient to hydrate the state into\ndehydratedState: DehydratedState\nRequired\nThe state to hydrate into the client\noptions: HydrateOptions\nOptional\ndefaultOptions: DefaultOptions\nOptional\nmutations: MutationOptions The default mutation options to use for the hydrated mutations.\nqueries: QueryOptions The default query options to use for the hydrated queries.\nqueryClient?: QueryClient,\nUse this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.\nLimitations\n\nIf the queries included in dehydration already exist in the queryCache, hydrate does not overwrite them and they will be silently discarded.\n\nHydrationBoundary\n\nHydrationBoundary adds a previously dehydrated state into the queryClient that would be returned by useQueryClient(). If the client already contains data, the new queries will be intelligently merged based on update timestamp.\n\ntsx\nimport { HydrationBoundary } from '@tanstack/vue-query'\n\n\nfunction App() {\n  return <HydrationBoundary state={dehydratedState}>...</HydrationBoundary>\n}\n\nOptions\n\nstate: DehydratedState\nThe state to hydrate\noptions: HydrateOptions\nOptional\ndefaultOptions: QueryOptions\nThe default query options to use for the hydrated queries.\nqueryClient?: QueryClient,\nUse this to use a custom QueryClient. Otherwise, the one from the nearest context will be used."
  },
  {
    "title": "OnlineManager | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/reference/onlineManager",
    "html": "OnlineManager\n\nThe OnlineManager manages the online state within TanStack Query. It can be used to change the default event listeners or to manually change the online state.\n\nPer default, the onlineManager assumes an active network connection, and listens to the online and offline events on the window object to detect changes.\n\nIn previous versions, navigator.onLine was used to determine the network status. However, it doesn't work well in Chromium based browsers. There are a lot of issues around false negatives, which lead to Queries being wrongfully marked as offline.\n\nTo circumvent this, we now always start with online: true and only listen to online and offline events to update the status.\n\nThis should reduce the likelihood of false negatives, however, it might mean false positives for offline apps that load via serviceWorkers, which can work even without an internet connection.\n\nIts available methods are:\n\nsetEventListener\nsubscribe\nsetOnline\nisOnline\nonlineManager.setEventListener\n\nsetEventListener can be used to set a custom event listener:\n\ntsx\nimport NetInfo from '@react-native-community/netinfo'\nimport { onlineManager } from '@tanstack/vue-query'\n\n\nonlineManager.setEventListener(setOnline => {\n  return NetInfo.addEventListener(state => {\n    setOnline(!!state.isConnected)\n  })\n})\nonlineManager.subscribe\n\nsubscribe can be used to subscribe to changes in the online state. It returns an unsubscribe function:\n\ntsx\nimport { onlineManager } from '@tanstack/vue-query'\n\n\nconst unsubscribe = onlineManager.subscribe(isOnline => {\n  console.log('isOnline', isOnline)\n})\nonlineManager.setOnline\n\nsetOnline can be used to manually set the online state.\n\ntsx\nimport { onlineManager } from '@tanstack/vue-query'\n\n\n// Set to online\nonlineManager.setOnline(true)\n\n\n// Set to offline\nonlineManager.setOnline(false)\n\nOptions\n\nonline: boolean\nonlineManager.isOnline\n\nisOnline can be used to get the current online state.\n\ntsx\nconst isOnline = onlineManager.isOnline()"
  },
  {
    "title": "FocusManager | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/reference/focusManager",
    "html": "FocusManager\n\nThe FocusManager manages the focus state within TanStack Query.\n\nIt can be used to change the default event listeners or to manually change the focus state.\n\nIts available methods are:\n\nsetEventListener\nsubscribe\nsetFocused\nisFocused\nfocusManager.setEventListener\n\nsetEventListener can be used to set a custom event listener:\n\ntsx\nimport { focusManager } from '@tanstack/vue-query'\n\n\nfocusManager.setEventListener((handleFocus) => {\n  // Listen to visibilitychange\n  if (typeof window !== 'undefined' && window.addEventListener) {\n    window.addEventListener('visibilitychange', handleFocus, false)\n  }\n\n\n  return () => {\n    // Be sure to unsubscribe if a new handler is set\n    window.removeEventListener('visibilitychange', handleFocus)\n  }\n})\nfocusManager.subscribe\n\nsubscribe can be used to subscribe to changes in the visibility state. It returns an unsubscribe function:\n\ntsx\nimport { focusManager } from '@tanstack/vue-query'\n\n\nconst unsubscribe = focusManager.subscribe(isVisible => {\n  console.log('isVisible', isVisible)\n})\nfocusManager.setFocused\n\nsetFocused can be used to manually set the focus state. Set undefined to fall back to the default focus check.\n\ntsx\nimport { focusManager } from '@tanstack/vue-query'\n\n\n// Set focused\nfocusManager.setFocused(true)\n\n\n// Set unfocused\nfocusManager.setFocused(false)\n\n\n// Fallback to the default focus check\nfocusManager.setFocused(undefined)\n\nOptions\n\nfocused: boolean | undefined\nfocusManager.isFocused\n\nisFocused can be used to get the current focus state.\n\ntsx\nconst isFocused = focusManager.isFocused()"
  },
  {
    "title": "QueriesObserver | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/reference/QueriesObserver",
    "html": "QueriesObserver\nQueriesObserver\n\nThe QueriesObserver can be used to observe multiple queries.\n\ntsx\nconst observer = new QueriesObserver(queryClient, [\n  { queryKey: ['post', 1], queryFn: fetchPost },\n  { queryKey: ['post', 2], queryFn: fetchPost },\n])\n\n\nconst unsubscribe = observer.subscribe(result => {\n  console.log(result)\n  unsubscribe()\n})\n\nOptions\n\nThe options for the QueriesObserver are exactly the same as those of useQueries.\n"
  },
  {
    "title": "InfiniteQueryObserver | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/reference/InfiniteQueryObserver",
    "html": "InfiniteQueryObserver\nInfiniteQueryObserver\n\nThe InfiniteQueryObserver can be used to observe and switch between infinite queries.\n\ntsx\nconst observer = new InfiniteQueryObserver(queryClient, {\n  queryKey: ['posts'],\n  queryFn: fetchPosts,\n  getNextPageParam: (lastPage, allPages) => lastPage.nextCursor,\n  getPreviousPageParam: (firstPage, allPages) => firstPage.prevCursor,\n})\n\n\nconst unsubscribe = observer.subscribe(result => {\n  console.log(result)\n  unsubscribe()\n})\n\nOptions\n\nThe options for the InfiniteQueryObserver are exactly the same as those of useInfiniteQuery.\n"
  },
  {
    "title": "QueryClient | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/reference/QueryClient",
    "html": "QueryClient\nQueryClient\n\nThe QueryClient can be used to interact with a cache:\n\ntsx\nimport { QueryClient } from '@tanstack/vue-query'\n\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: Infinity,\n    },\n  },\n})\n\n\nawait queryClient.prefetchQuery({ queryKey: ['posts'], queryFn: fetchPosts })\n\nIts available methods are:\n\nqueryClient.fetchQuery\nqueryClient.fetchInfiniteQuery\nqueryClient.prefetchQuery\nqueryClient.prefetchInfiniteQuery\nqueryClient.getQueryData\nqueryClient.ensureQueryData\nqueryClient.getQueriesData\nqueryClient.setQueryData\nqueryClient.getQueryState\nqueryClient.setQueriesData\nqueryClient.invalidateQueries\nqueryClient.refetchQueries\nqueryClient.cancelQueries\nqueryClient.removeQueries\nqueryClient.resetQueries\nqueryClient.isFetching\nqueryClient.isMutating\nqueryClient.getDefaultOptions\nqueryClient.setDefaultOptions\nqueryClient.getQueryDefaults\nqueryClient.setQueryDefaults\nqueryClient.getMutationDefaults\nqueryClient.setMutationDefaults\nqueryClient.getQueryCache\nqueryClient.getMutationCache\nqueryClient.clear\nqueryClient.resumePausedMutations\n\nOptions\n\nqueryCache?: QueryCache\nOptional\nThe query cache this client is connected to.\nmutationCache?: MutationCache\nOptional\nThe mutation cache this client is connected to.\ndefaultOptions?: DefaultOptions\nOptional\nDefine defaults for all queries and mutations using this queryClient.\nqueryClient.fetchQuery\n\nfetchQuery is an asynchronous method that can be used to fetch and cache a query. It will either resolve with the data or throw with the error. Use the prefetchQuery method if you just want to fetch a query without needing the result.\n\nIf the query exists and the data is not invalidated or older than the given staleTime, then the data from the cache will be returned. Otherwise it will try to fetch the latest data.\n\nThe difference between using fetchQuery and setQueryData is that fetchQuery is async and will ensure that duplicate requests for this query are not created with useQuery instances for the same query are rendered while the data is fetching.\n\ntsx\ntry {\n  const data = await queryClient.fetchQuery({ queryKey, queryFn })\n} catch (error) {\n  console.log(error)\n}\n\nSpecify a staleTime to only fetch when the data is older than a certain amount of time:\n\ntsx\ntry {\n  const data = await queryClient.fetchQuery({ queryKey, queryFn, staleTime: 10000 })\n} catch (error) {\n  console.log(error)\n}\n\nOptions\n\nThe options for fetchQuery are exactly the same as those of useQuery, except the following: enabled, refetchInterval, refetchIntervalInBackground, refetchOnWindowFocus, refetchOnReconnect, refetchOnMount, notifyOnChangeProps, throwOnError, select, suspense, placeholderData; which are strictly for useQuery and useInfiniteQuery. You can check the source code for more clarity.\n\nReturns\n\nPromise<TData>\nqueryClient.fetchInfiniteQuery\n\nfetchInfiniteQuery is similar to fetchQuery but can be used to fetch and cache an infinite query.\n\ntsx\ntry {\n  const data = await queryClient.fetchInfiniteQuery({ queryKey, queryFn })\n  console.log(data.pages)\n} catch (error) {\n  console.log(error)\n}\n\nOptions\n\nThe options for fetchInfiniteQuery are exactly the same as those of fetchQuery.\n\nReturns\n\nPromise<InfiniteData<TData, TPageParam>>\nqueryClient.prefetchQuery\n\nprefetchQuery is an asynchronous method that can be used to prefetch a query before it is needed or rendered with useQuery and friends. The method works the same as fetchQuery except that it will not throw or return any data.\n\ntsx\nawait queryClient.prefetchQuery({ queryKey, queryFn })\n\nYou can even use it with a default queryFn in your config!\n\ntsx\nawait queryClient.prefetchQuery({ queryKey })\n\nOptions\n\nThe options for prefetchQuery are exactly the same as those of fetchQuery.\n\nReturns\n\nPromise<void>\nA promise is returned that will either immediately resolve if no fetch is needed or after the query has been executed. It will not return any data or throw any errors.\nqueryClient.prefetchInfiniteQuery\n\nprefetchInfiniteQuery is similar to prefetchQuery but can be used to prefetch and cache an infinite query.\n\ntsx\nawait queryClient.prefetchInfiniteQuery({ queryKey, queryFn })\n\nOptions\n\nThe options for prefetchInfiniteQuery are exactly the same as those of fetchQuery.\n\nReturns\n\nPromise<void>\nA promise is returned that will either immediately resolve if no fetch is needed or after the query has been executed. It will not return any data or throw any errors.\nqueryClient.getQueryData\n\ngetQueryData is a synchronous function that can be used to get an existing query's cached data. If the query does not exist, undefined will be returned.\n\ntsx\nconst data = queryClient.getQueryData(queryKey)\n\nOptions\n\nqueryKey: QueryKey: Query Keys\n\nReturns\n\ndata: TQueryFnData | undefined\nThe data for the cached query, or undefined if the query does not exist.\nqueryClient.ensureQueryData\n\nensureQueryData is an asynchronous function that can be used to get an existing query's cached data. If the query does not exist, queryClient.fetchQuery will be called and its results returned.\n\ntsx\nconst data = await queryClient.ensureQueryData({ queryKey, queryFn })\n\nOptions\n\nThe options for ensureQueryData are exactly the same as those of fetchQuery except that queryKey is required.\n\nReturns\n\nPromise<TData>\nqueryClient.getQueriesData\n\ngetQueriesData is a synchronous function that can be used to get the cached data of multiple queries. Only queries that match the passed queryKey or queryFilter will be returned. If there are no matching queries, an empty array will be returned.\n\ntsx\nconst data = queryClient.getQueriesData(filters)\n\nOptions\n\nfilters: QueryFilters: Query Filters\nif a filter is passed, the data with queryKeys matching the filter will be returned\n\nReturns\n\n[queryKey: QueryKey, data: TQueryFnData | undefined][]\nAn array of tuples for the matched query keys, or [] if there are no matches. The tuples are the query key and its associated data.\n\nCaveats\n\nBecause the returned data in each tuple can be of varying structures (i.e. using a filter to return \"active\" queries can return different data types), the TData generic defaults to unknown. If you provide a more specific type to TData it is assumed that you are certain each tuple's data entry is all the same type.\n\nThis distinction is more a \"convenience\" for ts devs that know which structure will be returned.\n\nqueryClient.setQueryData\n\nsetQueryData is a synchronous function that can be used to immediately update a query's cached data. If the query does not exist, it will be created. If the query is not utilized by a query hook in the default gcTime of 5 minutes, the query will be garbage collected. To update multiple queries at once and match query keys partially, you need to use queryClient.setQueriesData instead.\n\nThe difference between using setQueryData and fetchQuery is that setQueryData is sync and assumes that you already synchronously have the data available. If you need to fetch the data asynchronously, it's suggested that you either refetch the query key or use fetchQuery to handle the asynchronous fetch.\n\ntsx\nqueryClient.setQueryData(queryKey, updater)\n\nOptions\n\nqueryKey: QueryKey: Query Keys\nupdater: TQueryFnData | undefined | ((oldData: TQueryFnData | undefined) => TQueryFnData | undefined)\nIf non-function is passed, the data will be updated to this value\nIf a function is passed, it will receive the old data value and be expected to return a new one.\n\nUsing an updater value\n\ntsx\nsetQueryData(queryKey, newData)\n\nIf the value is undefined, the query data is not updated.\n\nUsing an updater function\n\nFor convenience in syntax, you can also pass an updater function which receives the current data value and returns the new one:\n\ntsx\nsetQueryData(queryKey, oldData => newData)\n\nIf the updater function returns undefined, the query data will not be updated. If the updater function receives undefined as input, you can return undefined to bail out of the update and thus not create a new cache entry.\n\nImmutability\n\nUpdates via setQueryData must be performed in an immutable way. DO NOT attempt to write directly to the cache by mutating oldData or data that you retrieved via getQueryData in place.\n\nqueryClient.getQueryState\n\ngetQueryState is a synchronous function that can be used to get an existing query's state. If the query does not exist, undefined will be returned.\n\ntsx\nconst state = queryClient.getQueryState(queryKey)\nconsole.log(state.dataUpdatedAt)\n\nOptions\n\nqueryKey: QueryKey: Query Keys\nqueryClient.setQueriesData\n\nsetQueriesData is a synchronous function that can be used to immediately update cached data of multiple queries by using filter function or partially matching the query key. Only queries that match the passed queryKey or queryFilter will be updated - no new cache entries will be created. Under the hood, setQueryData is called for each existing query.\n\ntsx\nqueryClient.setQueriesData(filters, updater)\n\nOptions\n\nfilters: QueryFilters: Query Filters\nif a filter is passed, queryKeys matching the filter will be updated\nupdater: TQueryFnData | (oldData: TQueryFnData | undefined) => TQueryFnData\nthe setQueryData updater function or new data, will be called for each matching queryKey\nqueryClient.invalidateQueries\n\nThe invalidateQueries method can be used to invalidate and refetch single or multiple queries in the cache based on their query keys or any other functionally accessible property/state of the query. By default, all matching queries are immediately marked as invalid and active queries are refetched in the background.\n\nIf you do not want active queries to refetch, and simply be marked as invalid, you can use the refetchType: 'none' option.\nIf you want inactive queries to refetch as well, use the refetchType: 'all' option\ntsx\nawait queryClient.invalidateQueries({\n  queryKey: ['posts'],\n  exact,\n  refetchType: 'active',\n}, { throwOnError, cancelRefetch })\n\nOptions\n\nfilters?: QueryFilters: Query Filters\nqueryKey?: QueryKey: Query Keys\nrefetchType?: 'active' | 'inactive' | 'all' | 'none'\nDefaults to 'active'\nWhen set to active, only queries that match the refetch predicate and are actively being rendered via useQuery and friends will be refetched in the background.\nWhen set to inactive, only queries that match the refetch predicate and are NOT actively being rendered via useQuery and friends will be refetched in the background.\nWhen set to all, all queries that match the refetch predicate will be refetched in the background.\nWhen set to none, no queries will be refetched, and those that match the refetch predicate will be marked as invalid only.\noptions?: InvalidateOptions:\nthrowOnError?: boolean\nWhen set to true, this method will throw if any of the query refetch tasks fail.\ncancelRefetch?: boolean\nDefaults to true\nPer default, a currently running request will be cancelled before a new request is made\nWhen set to false, no refetch will be made if there is already a request running.\nqueryClient.refetchQueries\n\nThe refetchQueries method can be used to refetch queries based on certain conditions.\n\nExamples:\n\ntsx\n// refetch all queries:\nawait queryClient.refetchQueries()\n\n\n// refetch all stale queries:\nawait queryClient.refetchQueries({ stale: true })\n\n\n// refetch all active queries partially matching a query key:\nawait queryClient.refetchQueries({ queryKey: ['posts'], type: 'active' })\n\n\n// refetch all active queries exactly matching a query key:\nawait queryClient.refetchQueries({ queryKey: ['posts', 1], type: 'active', exact: true })\n\nOptions\n\nfilters?: QueryFilters: Query Filters\noptions?: RefetchOptions:\nthrowOnError?: boolean\nWhen set to true, this method will throw if any of the query refetch tasks fail.\ncancelRefetch?: boolean\nDefaults to true\nPer default, a currently running request will be cancelled before a new request is made\nWhen set to false, no refetch will be made if there is already a request running.\n\nReturns\n\nThis function returns a promise that will resolve when all of the queries are done being refetched. By default, it will not throw an error if any of those queries refetches fail, but this can be configured by setting the throwOnError option to true\n\nqueryClient.cancelQueries\n\nThe cancelQueries method can be used to cancel outgoing queries based on their query keys or any other functionally accessible property/state of the query.\n\nThis is most useful when performing optimistic updates since you will likely need to cancel any outgoing query refetches so they don't clobber your optimistic update when they resolve.\n\ntsx\nawait queryClient.cancelQueries({ queryKey: ['posts'], exact: true })\n\nOptions\n\nfilters?: QueryFilters: Query Filters\n\nReturns\n\nThis method does not return anything\n\nqueryClient.removeQueries\n\nThe removeQueries method can be used to remove queries from the cache based on their query keys or any other functionally accessible property/state of the query.\n\ntsx\nqueryClient.removeQueries({ queryKey, exact: true })\n\nOptions\n\nfilters?: QueryFilters: Query Filters\n\nReturns\n\nThis method does not return anything\n\nqueryClient.resetQueries\n\nThe resetQueries method can be used to reset queries in the cache to their initial state based on their query keys or any other functionally accessible property/state of the query.\n\nThis will notify subscribers â€” unlike clear, which removes all subscribers â€” and reset the query to its pre-loaded state â€” unlike invalidateQueries. If a query has initialData, the query's data will be reset to that. If a query is active, it will be refetched.\n\ntsx\nqueryClient.resetQueries({ queryKey, exact: true })\n\nOptions\n\nfilters?: QueryFilters: Query Filters\noptions?: ResetOptions:\nthrowOnError?: boolean\nWhen set to true, this method will throw if any of the query refetch tasks fail.\ncancelRefetch?: boolean\nDefaults to true\nPer default, a currently running request will be cancelled before a new request is made\nWhen set to false, no refetch will be made if there is already a request running.\n\nReturns\n\nThis method returns a promise that resolves when all active queries have been refetched.\n\nqueryClient.isFetching\n\nThis isFetching method returns an integer representing how many queries, if any, in the cache are currently fetching (including background-fetching, loading new pages, or loading more infinite query results)\n\ntsx\nif (queryClient.isFetching()) {\n  console.log('At least one query is fetching!')\n}\n\nTanStack Query also exports a handy useIsFetching hook that will let you subscribe to this state in your components without creating a manual subscription to the query cache.\n\nOptions\n\nfilters?: QueryFilters: Query Filters\n\nReturns\n\nThis method returns the number of fetching queries.\n\nqueryClient.isMutating\n\nThis isMutating method returns an integer representing how many mutations, if any, in the cache are currently fetching.\n\ntsx\nif (queryClient.isMutating()) {\n  console.log('At least one mutation is fetching!')\n}\n\nTanStack Query also exports a handy useIsMutating hook that will let you subscribe to this state in your components without creating a manual subscription to the mutation cache.\n\nOptions\n\nfilters: MutationFilters: Mutation Filters\n\nReturns\n\nThis method returns the number of fetching mutations.\n\nqueryClient.getDefaultOptions\n\nThe getDefaultOptions method returns the default options which have been set when creating the client or with setDefaultOptions.\n\ntsx\nconst defaultOptions = queryClient.getDefaultOptions()\nqueryClient.setDefaultOptions\n\nThe setDefaultOptions method can be used to dynamically set the default options for this queryClient. Previously defined default options will be overwritten.\n\ntsx\nqueryClient.setDefaultOptions({\n  queries: {\n    staleTime: Infinity,\n  },\n})\nqueryClient.getQueryDefaults\n\nThe getQueryDefaults method returns the default options which have been set for specific queries:\n\ntsx\nconst defaultOptions = queryClient.getQueryDefaults(['posts'])\n\nNote that if several query defaults match the given query key, the first matching one is returned. This could lead to unexpected behaviours. See setQueryDefaults.\n\nqueryClient.setQueryDefaults\n\nsetQueryDefaults can be used to set default options for specific queries:\n\ntsx\nqueryClient.setQueryDefaults(['posts'], { queryFn: fetchPosts })\n\n\nfunction Component() {\n  const { data } = useQuery({ queryKey: ['posts'] })\n}\n\nOptions\n\nqueryKey: QueryKey: Query Keys\noptions: QueryOptions\n\nAs stated in getQueryDefaults, the order of registration of query defaults does matter. Since the first matching defaults are returned by getQueryDefaults, the registration should be made in the following order: from the least generic key to the most generic one. This way, in case of specific key, the first matching one would be the expected one.\n\nqueryClient.getMutationDefaults\n\nThe getMutationDefaults method returns the default options which have been set for specific mutations:\n\ntsx\nconst defaultOptions = queryClient.getMutationDefaults(['addPost'])\nqueryClient.setMutationDefaults\n\nsetMutationDefaults can be used to set default options for specific mutations:\n\ntsx\nqueryClient.setMutationDefaults(['addPost'], { mutationFn: addPost })\n\n\nfunction Component() {\n  const { data } = useMutation({ mutationKey: ['addPost'] })\n}\n\nOptions\n\nmutationKey: unknown[]\noptions: MutationOptions\n\nSimilar to setQueryDefaults, the order of registration does matter here.\n\nqueryClient.getQueryCache\n\nThe getQueryCache method returns the query cache this client is connected to.\n\ntsx\nconst queryCache = queryClient.getQueryCache()\nqueryClient.getMutationCache\n\nThe getMutationCache method returns the mutation cache this client is connected to.\n\ntsx\nconst mutationCache = queryClient.getMutationCache()\nqueryClient.clear\n\nThe clear method clears all connected caches.\n\ntsx\nqueryClient.clear()\nqueryClient.resumePausedMutations\n\nCan be used to resume mutations that have been paused because there was no network connection.\n\ntsx\nqueryClient.resumePausedMutations()"
  },
  {
    "title": "QueryObserver | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/reference/QueryObserver",
    "html": "QueryObserver\nQueryObserver\n\nThe QueryObserver can be used to observe and switch between queries.\n\ntsx\nconst observer = new QueryObserver(queryClient, { queryKey: ['posts'] })\n\n\nconst unsubscribe = observer.subscribe(result => {\n  console.log(result)\n  unsubscribe()\n})\n\nOptions\n\nThe options for the QueryObserver are exactly the same as those of useQuery.\n"
  },
  {
    "title": "MutationCache | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/reference/MutationCache",
    "html": "MutationCache\n\nThe MutationCache is the storage for mutations.\n\nNormally, you will not interact with the MutationCache directly and instead use the QueryClient.\n\ntsx\nimport { MutationCache } from '@tanstack/vue-query'\n\n\nconst mutationCache = new MutationCache({\n  onError: error => {\n    console.log(error)\n  },\n  onSuccess: data => {\n    console.log(data)\n  },\n})\n\nIts available methods are:\n\ngetAll\nsubscribe\nclear\n\nOptions\n\nonError?: (error: unknown, variables: unknown, context: unknown, mutation: Mutation) => Promise<unknown> | unknown\nOptional\nThis function will be called if some mutation encounters an error.\nIf you return a Promise from it, it will be awaited\nonSuccess?: (data: unknown, variables: unknown, context: unknown, mutation: Mutation) => Promise<unknown> | unknown\nOptional\nThis function will be called if some mutation is successful.\nIf you return a Promise from it, it will be awaited\nonSettled?: (data: unknown | undefined, error: unknown | null, variables: unknown, context: unknown, mutation: Mutation) => Promise<unknown> | unknown\nOptional\nThis function will be called if some mutation is settled (either successful or errored).\nIf you return a Promise from it, it will be awaited\nonMutate?: (variables: unknown, mutation: Mutation) => Promise<unknown> | unknown\nOptional\nThis function will be called before some mutation executes.\nIf you return a Promise from it, it will be awaited\nGlobal callbacks\n\nThe onError, onSuccess, onSettled and onMutate callbacks on the MutationCache can be used to handle these events on a global level. They are different to defaultOptions provided to the QueryClient because:\n\ndefaultOptions can be overridden by each Mutation - the global callbacks will always be called.\nonMutate does not allow returning a context value.\nmutationCache.getAll\n\ngetAll returns all mutations within the cache.\n\nNote: This is not typically needed for most applications, but can come in handy when needing more information about a mutation in rare scenarios\n\ntsx\nconst mutations = mutationCache.getAll()\n\nReturns\n\nMutation[]\nMutation instances from the cache\nmutationCache.subscribe\n\nThe subscribe method can be used to subscribe to the mutation cache as a whole and be informed of safe/known updates to the cache like mutation states changing or mutations being updated, added or removed.\n\ntsx\nconst callback = event => {\n  console.log(event.type, event.mutation)\n}\n\n\nconst unsubscribe = mutationCache.subscribe(callback)\n\nOptions\n\ncallback: (mutation?: MutationCacheNotifyEvent) => void\nThis function will be called with the mutation cache any time it is updated.\n\nReturns\n\nunsubscribe: Function => void\nThis function will unsubscribe the callback from the mutation cache.\nmutationCache.clear\n\nThe clear method can be used to clear the cache entirely and start fresh.\n\ntsx\nmutationCache.clear()"
  },
  {
    "title": "QueryCache | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/reference/QueryCache",
    "html": "QueryCache\n\nThe QueryCache is the storage mechanism for TanStack Query. It stores all the data, meta information and state of queries it contains.\n\nNormally, you will not interact with the QueryCache directly and instead use the QueryClient for a specific cache.\n\ntsx\nimport { QueryCache } from '@tanstack/vue-query'\n\n\nconst queryCache = new QueryCache({\n  onError: (error) => {\n    console.log(error)\n  },\n  onSuccess: (data) => {\n    console.log(data)\n  },\n  onSettled: (data, error) => {\n    console.log(data, error)\n  },\n})\n\n\nconst query = queryCache.find(['posts'])\n\nIts available methods are:\n\nfind\nfindAll\nsubscribe\nclear\n\nOptions\n\nonError?: (error: unknown, query: Query) => void\nOptional\nThis function will be called if some query encounters an error.\nonSuccess?: (data: unknown, query: Query) => void\nOptional\nThis function will be called if some query is successful.\nonSettled?: (data: unknown | undefined, error: unknown | null, query: Query) => void\nOptional\nThis function will be called if some query is settled (either successful or errored).\nGlobal callbacks\n\nThe onError, onSuccess and onSettled callbacks on the QueryCache can be used to handle these events on a global level. They are different to defaultOptions provided to the QueryClient because:\n\ndefaultOptions can be overridden by each Query - the global callbacks will always be called.\ndefaultOptions callbacks will be called once for each Observer, while the global callbacks will only be called once per Query.\nqueryCache.find\n\nfind is a slightly more advanced synchronous method that can be used to get an existing query instance from the cache. This instance not only contains all the state for the query, but all of the instances, and underlying guts of the query as well. If the query does not exist, undefined will be returned.\n\nNote: This is not typically needed for most applications, but can come in handy when needing more information about a query in rare scenarios (eg. Looking at the query.state.dataUpdatedAt timestamp to decide whether a query is fresh enough to be used as an initial value)\n\ntsx\nconst query = queryCache.find(queryKey)\n\nOptions\n\nqueryKey?: QueryKey: Query Keys\nfilters?: QueryFilters: Query Filters\n\nReturns\n\nQuery\nThe query instance from the cache\nqueryCache.findAll\n\nfindAll is even more advanced synchronous method that can be used to get existing query instances from the cache that partially match query key. If queries do not exist, empty array will be returned.\n\nNote: This is not typically needed for most applications, but can come in handy when needing more information about a query in rare scenarios\n\ntsx\nconst queries = queryCache.findAll(queryKey)\n\nOptions\n\nqueryKey?: QueryKey: Query Keys\nfilters?: QueryFilters: Query Filters\n\nReturns\n\nQuery[]\nQuery instances from the cache\nqueryCache.subscribe\n\nThe subscribe method can be used to subscribe to the query cache as a whole and be informed of safe/known updates to the cache like query states changing or queries being updated, added or removed\n\ntsx\nconst callback = (event) => {\n  console.log(event.type, event.query)\n}\n\n\nconst unsubscribe = queryCache.subscribe(callback)\n\nOptions\n\ncallback: (event: QueryCacheNotifyEvent) => void\nThis function will be called with the query cache any time it is updated via its tracked update mechanisms (eg, query.setState, queryClient.removeQueries, etc). Out of scope mutations to the cache are not encouraged and will not fire subscription callbacks\n\nReturns\n\nunsubscribe: Function => void\nThis function will unsubscribe the callback from the query cache.\nqueryCache.clear\n\nThe clear method can be used to clear the cache entirely and start fresh.\n\ntsx\nqueryCache.clear()\nFurther reading\n\nTo get a better understanding how the QueryCache works internally, have a look at #18: Inside React Query from the Community Resources.\n"
  },
  {
    "title": "useQueryClient | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/reference/useQueryClient",
    "html": "useQueryClient\n\nThe useQueryClient hook returns the current QueryClient instance.\n\ntsx\nimport { useQueryClient } from '@tanstack/vue-query'\n\n\nconst queryClient = useQueryClient(queryClient?: QueryClient)\n\nOptions\n\nqueryClient?: QueryClient,\nUse this to use a custom QueryClient. Otherwise, the one from the nearest context will be used."
  },
  {
    "title": "useMutation | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/reference/useMutation",
    "html": "useMutation\ntsx\nconst {\n  data,\n  error,\n  isError,\n  isIdle,\n  isPending,\n  isPaused,\n  isSuccess,\n  failureCount,\n  failureReason,\n  mutate,\n  mutateAsync,\n  reset,\n  status,\n  submittedAt,\n  variables,\n} = useMutation({\n  mutationFn,\n  gcTime,\n  mutationKey,\n  networkMode,\n  onError,\n  onMutate,\n  onSettled,\n  onSuccess,\n  retry,\n  retryDelay,\n  throwOnError,\n  meta,\n})\n\n\nmutate(variables, {\n  onError,\n  onSettled,\n  onSuccess,\n})\n\nOptions\n\nmutationFn: (variables: TVariables) => Promise<TData>\nRequired, but only if no default mutation function has been defined\nA function that performs an asynchronous task and returns a promise.\nvariables is an object that mutate will pass to your mutationFn\ngcTime: number | Infinity\nThe time in milliseconds that unused/inactive cache data remains in memory. When a mutation's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different cache times are specified, the longest one will be used.\nIf set to Infinity, will disable garbage collection\nmutationKey: unknown[]\nOptional\nA mutation key can be set to inherit defaults set with queryClient.setMutationDefaults.\nnetworkMode: 'online' | 'always' | 'offlineFirst\noptional\ndefaults to 'online'\nsee Network Mode for more information.\nonMutate: (variables: TVariables) => Promise<TContext | void> | TContext | void\nOptional\nThis function will fire before the mutation function is fired and is passed the same variables the mutation function would receive\nUseful to perform optimistic updates to a resource in hopes that the mutation succeeds\nThe value returned from this function will be passed to both the onError and onSettled functions in the event of a mutation failure and can be useful for rolling back optimistic updates.\nonSuccess: (data: TData, variables: TVariables, context?: TContext) => Promise<unknown> | unknown\nOptional\nThis function will fire when the mutation is successful and will be passed the mutation's result.\nIf a promise is returned, it will be awaited and resolved before proceeding\nonError: (err: TError, variables: TVariables, context?: TContext) => Promise<unknown> | unknown\nOptional\nThis function will fire if the mutation encounters an error and will be passed the error.\nIf a promise is returned, it will be awaited and resolved before proceeding\nonSettled: (data: TData, error: TError, variables: TVariables, context?: TContext) => Promise<unknown> | unknown\nOptional\nThis function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error\nIf a promise is returned, it will be awaited and resolved before proceeding\nretry: boolean | number | (failureCount: number, error: TError) => boolean\nDefaults to 0.\nIf false, failed mutations will not retry.\nIf true, failed mutations will retry infinitely.\nIf set to an number, e.g. 3, failed mutations will retry until the failed mutations count meets that number.\nretryDelay: number | (retryAttempt: number, error: TError) => number\nThis function receives a retryAttempt integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.\nA function like attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000) applies exponential backoff.\nA function like attempt => attempt * 1000 applies linear backoff.\nthrowOnError: undefined | boolean | (error: TError) => boolean\nDefaults to the global query config's throwOnError value, which is undefined\nSet this to true if you want mutation errors to be thrown in the render phase and propagate to the nearest error boundary\nSet this to false to disable the behavior of throwing errors to the error boundary.\nIf set to a function, it will be passed the error and should return a boolean indicating whether to show the error in an error boundary (true) or return the error as state (false)\nmeta: Record<string, unknown>\nOptional\nIf set, stores additional information on the mutation cache entry that can be used as needed. It will be accessible wherever the mutation is available (eg. onError, onSuccess functions of the MutationCache).\nqueryClient?: QueryClient,\nUse this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.\n\nReturns\n\nmutate: (variables: TVariables, { onSuccess, onSettled, onError }) => void\nThe mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.\nvariables: TVariables\nOptional\nThe variables object to pass to the mutationFn.\nonSuccess: (data: TData, variables: TVariables, context: TContext) => void\nOptional\nThis function will fire when the mutation is successful and will be passed the mutation's result.\nVoid function, the returned value will be ignored\nonError: (err: TError, variables: TVariables, context: TContext | undefined) => void\nOptional\nThis function will fire if the mutation encounters an error and will be passed the error.\nVoid function, the returned value will be ignored\nonSettled: (data: TData | undefined, error: TError | null, variables: TVariables, context: TContext | undefined) => void\nOptional\nThis function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error\nVoid function, the returned value will be ignored\nIf you make multiple requests, onSuccess will fire only after the latest call you've made.\nmutateAsync: (variables: TVariables, { onSuccess, onSettled, onError }) => Promise<TData>\nSimilar to mutate but returns a promise which can be awaited.\nstatus: string\nWill be:\nidle initial status prior to the mutation function executing.\npending if the mutation is currently executing.\nerror if the last mutation attempt resulted in an error.\nsuccess if the last mutation attempt was successful.\nisIdle, isPending, isSuccess, isError: boolean variables derived from status\nisPaused: boolean\nwill be true if the mutation has been paused\nsee Network Mode for more information.\ndata: undefined | unknown\nDefaults to undefined\nThe last successfully resolved data for the query.\nerror: null | TError\nThe error object for the query, if an error was encountered.\nreset: () => void\nA function to clean the mutation internal state (i.e., it resets the mutation to its initial state).\nfailureCount: number\nThe failure count for the mutation.\nIncremented every time the mutation fails.\nReset to 0 when the mutation succeeds.\nfailureReason: null | TError\nThe failure reason for the mutation retry.\nReset to null when the mutation succeeds.\nsubmittedAt: number\nThe timestamp for when the mutation was submitted.\nDefaults to 0.\nvariables: undefined | TVariables\nThe variables object passed to the mutationFn.\nDefaults to undefined."
  },
  {
    "title": "useIsFetching | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/reference/useIsFetching",
    "html": "useIsFetching\n\nuseIsFetching is an optional hook that returns the number of the queries that your application is loading or fetching in the background (useful for app-wide loading indicators).\n\ntsx\nimport { useIsFetching } from '@tanstack/vue-query'\n// How many queries are fetching?\nconst isFetching = useIsFetching()\n// How many queries matching the posts prefix are fetching?\nconst isFetchingPosts = useIsFetching({ queryKey: ['posts'] })\n\nOptions\n\nfilters?: QueryFilters: Query Filters\nqueryClient?: QueryClient,\nUse this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.\n\nReturns\n\nisFetching: number\nWill be the number of the queries that your application is currently loading or fetching in the background."
  },
  {
    "title": "useInfiniteQuery | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/reference/useInfiniteQuery",
    "html": "useInfiniteQuery\ntsx\nconst {\n  fetchNextPage,\n  fetchPreviousPage,\n  hasNextPage,\n  hasPreviousPage,\n  isFetchingNextPage,\n  isFetchingPreviousPage,\n  ...result\n} = useInfiniteQuery({\n  queryKey,\n  queryFn: ({ pageParam }) => fetchPage(pageParam),\n  initialPageParam: 1,\n  ...options,\n  getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) =>\n    lastPage.nextCursor,\n  getPreviousPageParam: (firstPage, allPages, firstPageParam, allPageParams) =>\n    firstPage.prevCursor,\n})\n\nOptions\n\nThe options for useInfiniteQuery are identical to the useQuery hook with the addition of the following:\n\nqueryFn: (context: QueryFunctionContext) => Promise<TData>\nRequired, but only if no default query function has been defined defaultQueryFn\nThe function that the query will use to request data.\nReceives a QueryFunctionContext\nMust return a promise that will either resolve data or throw an error.\ninitialPageParam: TPageParam\nRequired\nThe default page param to use when fetching the first page.\ngetNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => TPageParam | undefined | null\nRequired\nWhen new data is received for this query, this function receives both the last page of the infinite list of data and the full array of all pages, as well as pageParam information.\nIt should return a single variable that will be passed as the last optional parameter to your query function.\nReturn undefined or null to indicate there is no next page available.\ngetPreviousPageParam: (firstPage, allPages, firstPageParam, allPageParams) => TPageParam | undefined | null\nWhen new data is received for this query, this function receives both the first page of the infinite list of data and the full array of all pages, as well as pageParam information.\nIt should return a single variable that will be passed as the last optional parameter to your query function.\nReturn undefined or nullto indicate there is no previous page available.\nmaxPages: number | undefined\nThe maximum number of pages to store in the infinite query data.\nWhen the maximum number of pages is reached, fetching a new page will result in the removal of either the first or last page from the pages array, depending on the specified direction.\nIf undefined or equals 0, the number of pages is unlimited\nDefault value is undefined\ngetNextPageParam and getPreviousPageParam must be properly defined if maxPages value is greater than 0 to allow fetching a page in both directions when needed.\n\nReturns\n\nThe returned properties for useInfiniteQuery are identical to the useQuery hook, with the addition of the following and a small difference in isRefetching:\n\ndata.pages: TData[]\nArray containing all pages.\ndata.pageParams: unknown[]\nArray containing all page params.\nisFetchingNextPage: boolean\nWill be true while fetching the next page with fetchNextPage.\nisFetchingPreviousPage: boolean\nWill be true while fetching the previous page with fetchPreviousPage.\nfetchNextPage: (options?: FetchNextPageOptions) => Promise<UseInfiniteQueryResult>\nThis function allows you to fetch the next \"page\" of results. getNextPageParam.\noptions.cancelRefetch: boolean if set to true, calling fetchNextPage repeatedly will invoke fetchPage every time, whether the previous invocation has resolved or not. Also, the result from previous invocations will be ignored. If set to false, calling fetchNextPage repeatedly won't have any effect until the first invocation has resolved. Default is true.\nfetchPreviousPage: (options?: FetchPreviousPageOptions) => Promise<UseInfiniteQueryResult>\nThis function allows you to fetch the previous \"page\" of results.\noptions.cancelRefetch: boolean same as for fetchNextPage.\nhasNextPage: boolean\nThis will be true if there is a next page to be fetched (known via the getNextPageParam option).\nhasPreviousPage: boolean\nThis will be true if there is a previous page to be fetched (known via the getPreviousPageParam option).\nisRefetching: boolean\nIs true whenever a background refetch is in-flight, which does not include initial pending or fetching of next or previous page\nIs the same as isFetching && !isPending && !isFetchingNextPage && !isFetchingPreviousPage\n\nKeep in mind that imperative fetch calls, such as fetchNextPage, may interfere with the default refetch behaviour, resulting in outdated data. Make sure to call these functions only in response to user actions, or add conditions like hasNextPage && !isFetching.\n"
  },
  {
    "title": "useIsMutating | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/reference/useIsMutating",
    "html": "useIsMutating\n\nuseIsMutating is an optional hook that returns the number of mutations that your application is fetching (useful for app-wide loading indicators).\n\ntsx\nimport { useIsMutating } from '@tanstack/vue-query'\n// How many mutations are fetching?\nconst isMutating = useIsMutating()\n// How many mutations matching the posts prefix are fetching?\nconst isMutatingPosts = useIsMutating({ mutationKey: ['posts'] })\n\nOptions\n\nfilters?: MutationFilters: Mutation Filters\nqueryClient?: QueryClient,\nUse this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.\n\nReturns\n\nisMutating: number\nWill be the number of the mutations that your application is currently fetching."
  },
  {
    "title": "useQuery | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/reference/useQuery",
    "html": "useQuery\ntsx\nconst {\n  data,\n  dataUpdatedAt,\n  error,\n  errorUpdatedAt,\n  failureCount,\n  failureReason,\n  fetchStatus,\n  isError,\n  isFetched,\n  isFetchedAfterMount,\n  isFetching,\n  isInitialLoading,\n  isLoading,\n  isLoadingError,\n  isPaused,\n  isPending,\n  isPlaceholderData,\n  isRefetchError,\n  isRefetching,\n  isStale,\n  isSuccess,\n  refetch,\n  status,\n} = useQuery({\n  queryKey,\n  queryFn,\n  gcTime,\n  enabled,\n  networkMode,\n  initialData,\n  initialDataUpdatedAt,\n  meta,\n  notifyOnChangeProps,\n  placeholderData,\n  queryKeyHashFn,\n  refetchInterval,\n  refetchIntervalInBackground,\n  refetchOnMount,\n  refetchOnReconnect,\n  refetchOnWindowFocus,\n  retry,\n  retryOnMount,\n  retryDelay,\n  select,\n  staleTime,\n  structuralSharing,\n  throwOnError,\n})\n\nOptions\n\nqueryKey: unknown[]\nRequired\nThe query key to use for this query.\nThe query key will be hashed into a stable hash. See Query Keys for more information.\nThe query will automatically update when this key changes (as long as enabled is not set to false).\nqueryFn: (context: QueryFunctionContext) => Promise<TData>\nRequired, but only if no default query function has been defined See Default Query Function for more information.\nThe function that the query will use to request data.\nReceives a QueryFunctionContext\nMust return a promise that will either resolve data or throw an error. The data cannot be undefined.\nenabled: boolean\nSet this to false to disable this query from automatically running.\nCan be used for Dependent Queries.\nnetworkMode: 'online' | 'always' | 'offlineFirst\noptional\ndefaults to 'online'\nsee Network Mode for more information.\nretry: boolean | number | (failureCount: number, error: TError) => boolean\nIf false, failed queries will not retry by default.\nIf true, failed queries will retry infinitely.\nIf set to a number, e.g. 3, failed queries will retry until the failed query count meets that number.\ndefaults to 3 on the client and 0 on the server\nretryOnMount: boolean\nIf set to false, the query will not be retried on mount if it contains an error. Defaults to true.\nretryDelay: number | (retryAttempt: number, error: TError) => number\nThis function receives a retryAttempt integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.\nA function like attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000) applies exponential backoff.\nA function like attempt => attempt * 1000 applies linear backoff.\nstaleTime: number | Infinity\nOptional\nDefaults to 0\nThe time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.\nIf set to Infinity, the data will never be considered stale\ngcTime: number | Infinity\nDefaults to 5 * 60 * 1000 (5 minutes) or Infinity during SSR\nThe time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.\nIf set to Infinity, will disable garbage collection\nqueryKeyHashFn: (queryKey: QueryKey) => string\nOptional\nIf specified, this function is used to hash the queryKey to a string.\nrefetchInterval: number | false | ((query: Query) => number | false | undefined)\nOptional\nIf set to a number, all queries will continuously refetch at this frequency in milliseconds\nIf set to a function, the function will be executed with the query to compute a frequency\nrefetchIntervalInBackground: boolean\nOptional\nIf set to true, queries that are set to continuously refetch with a refetchInterval will continue to refetch while their tab/window is in the background\nrefetchOnMount: boolean | \"always\" | ((query: Query) => boolean | \"always\")\nOptional\nDefaults to true\nIf set to true, the query will refetch on mount if the data is stale.\nIf set to false, the query will not refetch on mount.\nIf set to \"always\", the query will always refetch on mount.\nIf set to a function, the function will be executed with the query to compute the value\nrefetchOnWindowFocus: boolean | \"always\" | ((query: Query) => boolean | \"always\")\nOptional\nDefaults to true\nIf set to true, the query will refetch on window focus if the data is stale.\nIf set to false, the query will not refetch on window focus.\nIf set to \"always\", the query will always refetch on window focus.\nIf set to a function, the function will be executed with the query to compute the value\nrefetchOnReconnect: boolean | \"always\" | ((query: Query) => boolean | \"always\")\nOptional\nDefaults to true\nIf set to true, the query will refetch on reconnect if the data is stale.\nIf set to false, the query will not refetch on reconnect.\nIf set to \"always\", the query will always refetch on reconnect.\nIf set to a function, the function will be executed with the query to compute the value\nnotifyOnChangeProps: string[] | \"all\" | (() => string[] | \"all\")\nOptional\nIf set, the component will only re-render if any of the listed properties change.\nIf set to ['data', 'error'] for example, the component will only re-render when the data or error properties change.\nIf set to \"all\", the component will opt-out of smart tracking and re-render whenever a query is updated.\nIf set to a function, the function will be executed to compute the list of properties.\nBy default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.\nselect: (data: TData) => unknown\nOptional\nThis option can be used to transform or select a part of the data returned by the query function. It affects the returned data value, but does not affect what gets stored in the query cache.\ninitialData: TData | () => TData\nOptional\nIf set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)\nIf set to a function, the function will be called once during the shared/root query initialization, and be expected to synchronously return the initialData\nInitial data is considered stale by default unless a staleTime has been set.\ninitialData is persisted to the cache\ninitialDataUpdatedAt: number | (() => number | undefined)\nOptional\nIf set, this value will be used as the time (in milliseconds) of when the initialData itself was last updated.\nplaceholderData: TData | (previousValue: TData | undefined; previousQuery: Query | undefined,) => TData\nOptional\nIf set, this value will be used as the placeholder data for this particular query observer while the query is still in the pending state.\nplaceholderData is not persisted to the cache\nIf you provide a function for placeholderData, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.\nstructuralSharing: boolean | (<T>(oldData: T | undefined, newData: T) => T)\nOptional\nDefaults to true\nIf set to false, structural sharing between query results will be disabled.\nIf set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.\nthrowOnError: undefined | boolean | (error: TError, query: Query) => boolean\nDefaults to the global query config's throwOnError value, which is undefined\nSet this to true if you want errors to be thrown in the render phase and propagate to the nearest error boundary\nSet this to false to disable suspense's default behavior of throwing errors to the error boundary.\nIf set to a function, it will be passed the error and the query, and it should return a boolean indicating whether to show the error in an error boundary (true) or return the error as state (false)\nmeta: Record<string, unknown>\nOptional\nIf set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the query is available, and is also part of the QueryFunctionContext provided to the queryFn.\nqueryClient?: QueryClient,\nUse this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.\n\nReturns\n\nstatus: String\nWill be:\npending if there's no cached data and no query attempt was finished yet.\nerror if the query attempt resulted in an error. The corresponding error property has the error received from the attempted fetch\nsuccess if the query has received a response with no errors and is ready to display its data. The corresponding data property on the query is the data received from the successful fetch or if the query's enabled property is set to false and has not been fetched yet data is the first initialData supplied to the query on initialization.\nisPending: boolean\nA derived boolean from the status variable above, provided for convenience.\nisSuccess: boolean\nA derived boolean from the status variable above, provided for convenience.\nisError: boolean\nA derived boolean from the status variable above, provided for convenience.\nisLoadingError: boolean\nWill be true if the query failed while fetching for the first time.\nisRefetchError: boolean\nWill be true if the query failed while refetching.\ndata: TData\nDefaults to undefined.\nThe last successfully resolved data for the query.\ndataUpdatedAt: number\nThe timestamp for when the query most recently returned the status as \"success\".\nerror: null | TError\nDefaults to null\nThe error object for the query, if an error was thrown.\nerrorUpdatedAt: number\nThe timestamp for when the query most recently returned the status as \"error\".\nisStale: boolean\nWill be true if the data in the cache is invalidated or if the data is older than the given staleTime.\nisPlaceholderData: boolean\nWill be true if the data shown is the placeholder data.\nisFetched: boolean\nWill be true if the query has been fetched.\nisFetchedAfterMount: boolean\nWill be true if the query has been fetched after the component mounted.\nThis property can be used to not show any previously cached data.\nfetchStatus: FetchStatus\nfetching: Is true whenever the queryFn is executing, which includes initial pending as well as background refetches.\npaused: The query wanted to fetch, but has been paused.\nidle: The query is not fetching.\nsee Network Mode for more information.\nisFetching: boolean\nA derived boolean from the fetchStatus variable above, provided for convenience.\nisPaused: boolean\nA derived boolean from the fetchStatus variable above, provided for convenience.\nisRefetching: boolean\nIs true whenever a background refetch is in-flight, which does not include initial pending\nIs the same as isFetching && !isPending\nisLoading: boolean\nIs true whenever the first fetch for a query is in-flight\nIs the same as isFetching && isPending\nisInitialLoading: boolean\ndeprecated\nAn alias for isLoading, will be removed in the next major version.\nfailureCount: number\nThe failure count for the query.\nIncremented every time the query fails.\nReset to 0 when the query succeeds.\nfailureReason: null | TError\nThe failure reason for the query retry.\nReset to null when the query succeeds.\nerrorUpdateCount: number\nThe sum of all errors.\nrefetch: (options: { throwOnError: boolean, cancelRefetch: boolean }) => Promise<UseQueryResult>\nA function to manually refetch the query.\nIf the query errors, the error will only be logged. If you want an error to be thrown, pass the throwOnError: true option\ncancelRefetch?: boolean\nDefaults to true\nPer default, a currently running request will be cancelled before a new request is made\nWhen set to false, no refetch will be made if there is already a request running."
  },
  {
    "title": "useQueries | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/reference/useQueries",
    "html": "useQueries\n\nThe useQueries hook can be used to fetch a variable number of queries:\n\ntsx\nconst ids = [1,2,3]\nconst results = useQueries({\n  queries: ids.map(id => (\n    { queryKey: ['post', id], queryFn: () => fetchPost(id), staleTime: Infinity },\n  )),\n})\n\nOptions\n\nThe useQueries hook accepts an options object with a queries key whose value is an array with query option objects identical to the useQuery hook (excluding the queryClient option - because the QueryClient can be passed in on the top level).\n\nqueryClient?: QueryClient,\nUse this to provide a custom QueryClient. Otherwise, the one from the nearest context will be used.\ncombine?: (result: UseQueriesResults) => TCombinedResult\nUse this to combine the results of the queries into a single value.\n\nHaving the same query key more than once in the array of query objects may cause some data to be shared between queries. To avoid this, consider de-duplicating the queries and map the results back to the desired structure.\n\nplaceholderData\n\nThe placeholderData option exists for useQueries as well, but it doesn't get information passed from previously rendered Queries like useQuery does, because the input to useQueries can be a different number of Queries on each render.\n\nReturns\n\nThe useQueries hook returns an array with all the query results. The order returned is the same as the input order.\n\nCombine\n\nIf you want to combine data (or other Query information) from the results into a single value, you can use the combine option. The result will be structurally shared to be as referentially stable as possible.\n\ntsx\nconst ids = [1,2,3]\nconst combinedQueries = useQueries({\n  queries: ids.map(id => (\n    { queryKey: ['post', id], queryFn: () => fetchPost(id) },\n  )),\n  combine: (results) => {\n    return ({\n      data: results.map(result => result.data),\n      pending: results.some(result => result.isPending),\n    })\n  }\n})\n\nIn the above example, combinedQueries will be an object with a data and a pending property. Note that all other properties of the Query results will be lost.\n"
  },
  {
    "title": "Overview | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/overview",
    "html": "Overview\n\nTanStack Query (FKA Vue Query) is often described as the missing data-fetching library for web applications, but in more technical terms, it makes fetching, caching, synchronizing and updating server state in your web applications a breeze.\n\nMotivation\n\nMost core web frameworks do not come with an opinionated way of fetching or updating data in a holistic way. Because of this developers end up building either meta-frameworks which encapsulate strict opinions about data-fetching, or they invent their own ways of fetching data. This usually means cobbling together component-based state and side-effects, or using more general purpose state management libraries to store and provide asynchronous data throughout their apps.\n\nWhile most traditional state management libraries are great for working with client state, they are not so great at working with async or server state. This is because server state is totally different. For starters, server state:\n\nIs persisted remotely in a location you do not control or own\nRequires asynchronous APIs for fetching and updating\nImplies shared ownership and can be changed by other people without your knowledge\nCan potentially become \"out of date\" in your applications if you're not careful\n\nOnce you grasp the nature of server state in your application, even more challenges will arise as you go, for example:\n\nCaching... (possibly the hardest thing to do in programming)\nDeduping multiple requests for the same data into a single request\nUpdating \"out of date\" data in the background\nKnowing when data is \"out of date\"\nReflecting updates to data as quickly as possible\nPerformance optimizations like pagination and lazy loading data\nManaging memory and garbage collection of server state\nMemoizing query results with structural sharing\n\nIf you're not overwhelmed by that list, then that must mean that you've probably solved all of your server state problems already and deserve an award. However, if you are like a vast majority of people, you either have yet to tackle all or most of these challenges and we're only scratching the surface!\n\nVue Query is hands down one of the best libraries for managing server state. It works amazingly well out-of-the-box, with zero-config, and can be customized to your liking as your application grows.\n\nVue Query allows you to defeat and overcome the tricky challenges and hurdles of server state and control your app data before it starts to control you.\n\nOn a more technical note, Vue Query will likely:\n\nHelp you remove many lines of complicated and misunderstood code from your application and replace with just a handful of lines of Vue Query logic.\nMake your application more maintainable and easier to build new features without worrying about wiring up new server state data sources\nHave a direct impact on your end-users by making your application feel faster and more responsive than ever before.\nPotentially help you save on bandwidth and increase memory performance\nYou talked me into it, so what now?\nLearn Vue Query at your own pace with our amazingly thorough Walkthrough Guide and API Reference"
  },
  {
    "title": "TkDodo's Blog | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/community/tkdodos-blog",
    "html": "TkDodo's Blog\n\nTanStack Query maintainer TkDodo has a series of blog posts about using and working with the library. Some articles show general best practices, but most have an opinionated point of view.\n\n#1: Practical React Query\n\nAn advanced introduction to React Query, showing practical tips that go beyond the docs. It covers explaining the defaults (staleTime vs. gcTime), concepts like keeping server and client state separate, handling dependencies and creating custom hooks, as well as outlining why the enabled option is very powerful. Read more...\n\n#2: React Query Data Transformations\n\nLearn the possibilities to perform the quite common and important task of transforming your data with React Query. From transforming in the queryFn to using the select option, this article outlines the pros and cons of all the different approaches. Read more...\n\n#3: React Query Render Optimizations\n\nLet's take a look at what you can do when your component re-renders too often when using React Query. The library is already pretty optimized, but there are still some opt-in features (like tracked queries) that you can use to avoid the isFetching transition. We're also looking into what structural sharing refers to. Read more...\n\n#4: Status Checks in React Query\n\nWe usually check for isPending first before checking for isError , but sometimes, checking if data is available should be the first thing to do. This article shows how the wrong status check order can negatively impact user experience. Read more...\n\n#5: Testing React Query\n\nThe docs already cover pretty well what you need to do to get started when testing React Query. This article shows some additional tips (like turning off retries or silencing the console) you might want to follow when testing custom hooks or components using them. It also links to an example repository with tests for success and error states, powered by mock-service-worker. Read more...\n\n#6: React Query and TypeScript\n\nSince React Query is written in TypeScript, it has great support for it. This blog post explains the various Generics, how you can leverage type inference to avoid having to explicitly type useQuery and friends, what to do with unknown errors, how type narrowing works and more! Read more...\n\n#7: Using WebSockets with React Query\n\nA step-by-step guide on how to make real-time notifications work with React Query, with either event-based subscriptions or pushing full data directly to the client. Applicable to anything from the browser native WebSocket API over Firebase and even GraphQL subscriptions. Read more...\n\n#8: Effective React Query Keys\n\nMost examples just use a simple String or Array Query Key, but how do you organize your keys effectively once your app grows past a todo list? This article shows how co-location and Query Key Factories can make life easier. Read more...\n\n#8a: Leveraging the Query Function Context\n\nIn this amendment to the previous blog post, we look at how we can leverage the Query Function Context and Object Query Keys for maximum safety as our app grows. Read more...\n\n#9: Placeholder and Initial Data in React Query\n\nPlaceholder and Initial Data are two similar yet different concepts for synchronously showing data instead of a loading spinner to improve an application's UX. This blog post compares the two and outlines the scenarios where each one shines. Read more...\n\n#10: React Query as a State Manager\n\nReact Query doesn't fetch any data for you - it's a data synchronization tool that excels when used for server state. This article has everything you need to know to make React Query your single source of truth state manager for your async state. You'll learn how to let React Query do it's magic and why customizing staleTime might be all you need. Read more...\n\n#11: React Query Error Handling\n\nHandling errors is an integral part of working with asynchronous data, especially data fetching. We have to face it: Not all requests will be successful, and not all Promises will be fulfilled. This blog post describes various ways of coping with errors in React Query, such as the error property, using Error Boundaries or onError callbacks, so that you can prepare your application for the cases when \"Something went wrong\". Read more...\n\n#12: Mastering Mutations in React Query\n\nMutations are the important, second part necessary to work with server data - for situations where you need to update it. This blog post covers what mutations are and how they are different from queries. You'll learn the difference between mutate and mutateAsync as well as how you can tie queries and mutations together. Read more...\n\n#13: Offline React Query\n\nThere are many ways to produce promises - which is everything React Query needs - but by far the biggest use-case is data fetching. Very often, that requires an active network connection. But sometimes, especially on mobile devices where, the network connection can be unreliable, you need your app to also work without it. In this article, you'll learn about the different offline strategies React Query offers. Read more...\n\n#14: React Query and Forms\n\nForms tend to blur the line between what is server state and what is client state. In most applications, we would not only like to display state, but also let the user interact with it. This article shows two different approaches as well as some tips and tricks about using React Query with Forms. Read more...\n\n#15: React Query FAQs\n\nThis article tries to answer the most frequently asked questions about React Query. Read more...\n\n#16: React Query meets React Router\n\nRemix and React Router are changing the game when thinking about when to fetch data. This article goes into why React Query and Routers that support data loading are a match made in heaven. Read more...\n\n#17: Seeding the Query Cache\n\nThis blog post shows multiple ways how to get data into your Query Cache before you start rendering to minimize the amount of loading spinners displayed in your app. The options range from prefetching on the server or in your router to seeding cache entries via setQueryData. Read more...\n\n#18: Inside React Query\n\nIf you've ever wondered how React Query works under the hood - this post is for you. It explains the architecture (including visuals), starting with the agnostic Query Core and how it communicates with the framework specific adapters. Read more...\n\n#19: Type-safe React Query\n\nThere's a big difference between \"having types\" and \"being type-safe\". This article tries to outline those differences and shows how you can get the best possible type-safety when using React Query together with TypeScript Read more...\n"
  },
  {
    "title": "Migrating to TanStack Query v5 | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/migrating-to-v5",
    "html": "Migrating to TanStack Query v5\nBreaking Changes\n\nv5 is a major version, so there are some breaking changes to be aware of:\n\nSupports a single signature, one object\n\nuseQuery and friends used to have many overloads in TypeScript - different ways how the function can be invoked. Not only this was tough to maintain, type wise, it also required a runtime check to see which type the first and the second parameter, to correctly create options.\n\nnow we only support the object format.\n\ndiff\n- useQuery(key, fn, options)\n+ useQuery({ queryKey, queryFn, ...options })\n- useInfiniteQuery(key, fn, options)\n+ useInfiniteQuery({ queryKey, queryFn, ...options })\n- useMutation(fn, options)\n+ useMutation({ mutationFn, ...options })\n- useIsFetching(key, filters)\n+ useIsFetching({ queryKey, ...filters })\n- useIsMutating(key, filters)\n+ useIsMutating({ mutationKey, ...filters })\ndiff\n- queryClient.isFetching(key, filters)\n+ queryClient.isFetching({ queryKey, ...filters })\n- queryClient.ensureQueryData(key, filters)\n+ queryClient.ensureQueryData({ queryKey, ...filters })\n- queryClient.getQueriesData(key, filters)\n+ queryClient.getQueriesData({ queryKey, ...filters })\n- queryClient.setQueriesData(key, updater, filters, options)\n+ queryClient.setQueriesData({ queryKey, ...filters }, updater, options)\n- queryClient.removeQueries(key, filters)\n+ queryClient.removeQueries({ queryKey, ...filters })\n- queryClient.resetQueries(key, filters, options)\n+ queryClient.resetQueries({ queryKey, ...filters }, options)\n- queryClient.cancelQueries(key, filters, options)\n+ queryClient.cancelQueries({ queryKey, ...filters }, options)\n- queryClient.invalidateQueries(key, filters, options)\n+ queryClient.invalidateQueries({ queryKey, ...filters }, options)\n- queryClient.refetchQueries(key, filters, options)\n+ queryClient.refetchQueries({ queryKey, ...filters }, options)\n- queryClient.fetchQuery(key, fn, options)\n+ queryClient.fetchQuery({ queryKey, queryFn, ...options })\n- queryClient.prefetchQuery(key, fn, options)\n+ queryClient.prefetchQuery({ queryKey, queryFn, ...options })\n- queryClient.fetchInfiniteQuery(key, fn, options)\n+ queryClient.fetchInfiniteQuery({ queryKey, queryFn, ...options })\n- queryClient.prefetchInfiniteQuery(key, fn, options)\n+ queryClient.prefetchInfiniteQuery({ queryKey, queryFn, ...options })\ndiff\n- queryCache.find(key, filters)\n+ queryCache.find({ queryKey, ...filters })\n- queryCache.findAll(key, filters)\n+ queryCache.findAll({ queryKey, ...filters })\nqueryClient.getQueryData now accepts queryKey only as an Argument\n\nqueryClient.getQueryData argument is changed to accept only a queryKey\n\ndiff\n- queryClient.getQueryData(queryKey, filters)\n+ queryClient.getQueryData(queryKey)\nqueryClient.getQueryState now accepts queryKey only as an Argument\n\nqueryClient.getQueryState argument is changed to accept only a queryKey\n\ndiff\n- queryClient.getQueryState(queryKey, filters)\n+ queryClient.getQueryState(queryKey)\nCodemod\n\nTo make the remove overloads migration easier, v5 comes with a codemod.\n\nThe codemod is a best efforts attempt to help you migrate the breaking change. Please review the generated code thoroughly! Also, there are edge cases that cannot be found by the code mod, so please keep an eye on the log output.\n\nIf you want to run it against .js or .jsx files, please use the command below:\n\nbash\nnpx jscodeshift@latest ./path/to/src/ \\\n  --extensions=js,jsx \\\n  --transform=./node_modules/@tanstack/react-query/build/codemods/src/v5/remove-overloads/remove-overloads.js\n\nIf you want to run it against .ts or .tsx files, please use the command below:\n\nbash\nnpx jscodeshift@latest ./path/to/src/ \\\n  --extensions=ts,tsx \\\n  --parser=tsx \\\n  --transform=./node_modules/@tanstack/react-query/build/codemods/src/v5/remove-overloads/remove-overloads.js\n\nPlease note in the case of TypeScript you need to use tsx as the parser; otherwise, the codemod won't be applied properly!\n\nNote: Applying the codemod might break your code formatting, so please don't forget to run prettier and/or eslint after you've applied the codemod!\n\nA few notes about how codemod works:\n\nGenerally, we're looking for the lucky case, when the first parameter is an object expression and contains the \"queryKey\" or \"mutationKey\" property (depending on which hook/method call is being transformed). If this is the case, your code already matches the new signature, so the codemod won't touch it. ðŸŽ‰\nIf the condition above is not fulfilled, then the codemod will check whether the first parameter is an array expression or an identifier that references an array expression. If this is the case, the codemod will put it into an object expression, then it will be the first parameter.\nIf object parameters can be inferred, the codemod will attempt to copy the already existing properties to the newly created one.\nIf the codemod cannot infer the usage, then it will leave a message on the console. The message contains the file name and the line number of the usage. In this case, you need to do the migration manually.\nIf the transformation results in an error, you will also see a message on the console. This message will notify you something unexpected happened, please do the migration manually.\nCallbacks on useQuery (and QueryObserver) have been removed\n\nonSuccess, onError and onSettled have been removed from Queries. They haven't been touched for Mutations. Please see this RFC for motivations behind this change and what to do instead.\n\nThe refetchInterval callback function only gets query passed\n\nThis streamlines how callbacks are invoked (the refetchOnWindowFocus, refetchOnMount and refetchOnReconnect callbacks all only get the query passed as well), and it fixes some typing issues when callbacks get data transformed by select.\n\ndiff\n- refetchInterval: number | false | ((data: TData | undefined, query: Query) => number | false | undefined)\n+ refetchInterval: number | false | ((query: Query) => number | false | undefined)\n\nYou can still access data with query.state.data, however, it will not be data that has been transformed by select. If you need to access the transformed data, you can call the transformation again on query.state.data.\n\nThe remove method has been removed from useQuery\n\nPreviously, remove method used to remove the query from the queryCache without informing observers about it. It was best used to remove data imperatively that is no longer needed, e.g. when logging a user out.\n\nBut It doesn't make much sense to do this while a query is still active, because it will just trigger a hard loading state with the next re-render.\n\nif you still need to remove a query, you can use queryClient.removeQueries({queryKey: key})\n\ndiff\nconst queryClient = useQueryClient();\n const query = useQuery({ queryKey, queryFn });\n- query.remove()\n+ queryClient.removeQueries({ queryKey })\nThe minimum required TypeScript version is now 4.7\n\nMainly because an important fix was shipped around type inference. Please see this TypeScript issue for more information.\n\nThe isDataEqual option has been removed from useQuery\n\nPreviously, This function was used to indicate whether to use previous data (true) or new data (false) as a resolved data for the query.\n\nYou can achieve the same functionality by passing a function to structuralSharing instead:\n\ndiff\nimport { replaceEqualDeep } from '@tanstack/react-query'\n\n\n- isDataEqual: (oldData, newData) => customCheck(oldData, newData)\n+ structuralSharing: (oldData, newData) => customCheck(oldData, newData) ? oldData : replaceEqualDeep(oldData, newData)\nThe deprecated custom logger has been removed\n\nCustom loggers were already deprecated in 4 and have been removed in this version. Logging only had an effect in development mode, where passing a custom logger is not necessary.\n\nSupported Browsers\n\nWe have updated our browserslist to produce a more modern, performant and smaller bundle. You can read about the requirements here.\n\nPrivate class fields and methods\n\nTanStack Query has always had private fields and methods on classes, but they weren't really private - they were just private in TypeScript. We now use ECMAScript Private class features, which means those fields are now truly private and can't be accessed from the outside at runtime.\n\nRename cacheTime to gcTime\n\nAlmost everyone gets cacheTime wrong. It sounds like \"the amount of time that data is cached for\", but that is not correct.\n\ncacheTime does nothing as long as a query is still in used. It only kicks in as soon as the query becomes unused. After the time has passed, data will be \"garbage collected\" to avoid the cache from growing.\n\ngc is referring to \"garbage collect\" time. It's a bit more technical, but also a quite well known abbreviation in computer science.\n\ndiff\nconst MINUTE = 1000 * 60;\n\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n-      cacheTime: 10 * MINUTE,\n+      gcTime: 10 * MINUTE,\n    },\n  },\n})\nThe useErrorBoundary option has been renamed to throwOnError\n\nTo make the useErrorBoundary option more framework-agnostic and avoid confusion with the established React function prefix \"use\" for hooks and the \"ErrorBoundary\" component name, it has been renamed to throwOnError to more accurately reflect its functionality.\n\nTypeScript: Error is now the default type for errors instead of unknown\n\nEven though in JavaScript, you can throw anything (which makes unknown the most correct type), almost always, Errors (or subclasses of Error) are thrown. This change makes it easier to work with the error field in TypeScript for most cases.\n\nIf you want to throw something that isn't an Error, you'll now have to set the generic for yourself:\n\nts\nuseQuery<number, string>({\n  queryKey: ['some-query'],\n  queryFn: async () => {\n    if (Math.random() > 0.5) {\n      throw 'some error'\n    }\n    return 42\n  },\n})\n\nFor a way to set a different kind of Error globally, see the TypeScript Guide.\n\neslint prefer-query-object-syntax rule is removed\n\nSince the only supported syntax now is the object syntax, this rule is no longer needed\n\nRemoved keepPreviousData in favor of placeholderData identity function\n\nWe have removed the keepPreviousData option and isPreviousData flag as they were doing mostly the same thing as placeholderData and isPlaceholderData flag.\n\nTo achieve the same functionality as keepPreviousData, we have added previous query data as an argument to placeholderData which accepts an identity function. Therefore you just need to provide an identity function to placeholderData or use the included keepPreviousData function from Tanstack Query.\n\nA note here is that useQueries would not receive previousData in the placeholderData function as argument. This is due to a dynamic nature of queries passed in the array, which may lead to a different shape of result from placeholder and queryFn.\n\ndiff\nimport {\n   useQuery,\n+  keepPreviousData\n} from \"@tanstack/react-query\";\n\n\nconst {\n   data,\n-  isPreviousData,\n+  isPlaceholderData,\n} = useQuery({\n  queryKey,\n  queryFn,\n- keepPreviousData: true,\n+ placeholderData: keepPreviousData\n});\n\nAn identity function, in the context of Tanstack Query, refers to a function that always returns its provided argument (i.e. data) unchanged.\n\nts\nuseQuery({\n  queryKey,\n  queryFn,\n  placeholderData: (previousData, previousQuery) => previousData, // identity function with the same behaviour as `keepPreviousData`\n})\n\nThere are some caveats to this change however, which you must be aware of:\n\nplaceholderData will always put you into success state, while keepPreviousData gave you the status of the previous query. That status could be error if we have data fetched successfully and then got a background refetch error. However, the error itself was not shared, so we decided to stick with behavior of placeholderData.\n\nkeepPreviousData gave you the dataUpdatedAt timestamp of the previous data, while with placeholderData, dataUpdatedAt will stay at 0. This might be annoying if you want to show that timestamp continuously on screen. However you might get around it with useEffect.\n\nts\nconst [updatedAt, setUpdatedAt] = useState(0)\n\n\nconst { data, dataUpdatedAt } = useQuery({\n  queryKey: ['projects', page],\n  queryFn: () => fetchProjects(page),\n})\n\n\nuseEffect(() => {\n  if (dataUpdatedAt > updatedAt) {\n    setUpdatedAt(dataUpdatedAt)\n  }\n}, [dataUpdatedAt])\nWindow focus refetching no longer listens to the focus event\n\nThe visibilitychange event is used exclusively now. This is possible because we only support browsers that support the visibilitychange event. This fixes a bunch of issues as listed here.\n\nNetwork status no longer relies on the navigator.onLine property\n\nnavigator.onLine doesn't work well in Chromium based browsers. There are a lot of issues around false negatives, which lead to Queries being wrongfully marked as offline.\n\nTo circumvent this, we now always start with online: true and only listen to online and offline events to update the status.\n\nThis should reduce the likelihood of false negatives, however, it might mean false positives for offline apps that load via serviceWorkers, which can work even without an internet connection.\n\nRemoved custom context prop in favor of custom queryClient instance\n\nIn v4, we introduced the possibility to pass a custom context to all react-query hooks. This allowed for proper isolation when using MicroFrontends.\n\nHowever, context is a react-only feature. All that context does is give us access to the queryClient. We could achieve the same isolation by allowing to pass in a custom queryClient directly. This in turn will enable other frameworks to have the same functionality in a framework-agnostic way.\n\ndiff\nimport { queryClient } from './my-client'\n\n\nconst { data } = useQuery(\n  {\n    queryKey: ['users', id],\n    queryFn: () => fetch(...),\n-   context: customContext\n  },\n+  queryClient,\n)\nRemoved refetchPage in favor of maxPages\n\nIn v4, we introduced the possibility to define the pages to refetch for infinite queries with the refetchPage function.\n\nHowever, refetching all pages might lead to UI inconsistencies. Also, this option is available on e.g. queryClient.refetchQueries, but it only does something for infinite queries, not \"normal\" queries.\n\nThe v5 includes a new maxPages option for infinite queries to limit the number of pages to store in the query data and to refetch. This new feature handles the use cases initially identified for the refetchPage page feature without the related issues.\n\nNew dehydrate API\n\nThe options you can pass to dehydrate have been simplified. Queries and Mutations are always dehydrated (according to the default function implementation). To change this behaviour, instead of using the removed boolean options dehydrateMutations and dehydrateQueries you can implement the function equivalents shouldDehydrateQuery or shouldDehydrateMutation instead. To get the old behaviour of not hydrating queries/mutations at all, pass in () => false.\n\ndiff\n- dehydrateMutations?: boolean\n- dehydrateQueries?: boolean\nInfinite queries now need a initialPageParam\n\nPreviously, we've passed undefined to the queryFn as pageParam, and you could assign a default value to the pageParam parameter in the queryFn function signature. This had the drawback of storing undefined in the queryCache, which is not serializable.\n\nInstead, you now have to pass an explicit initialPageParam to the infinite query options. This will be used as the pageParam for the first page:\n\ndiff\nuseInfiniteQuery({\n   queryKey,\n-  queryFn: ({ pageParam = 0 }) => fetchSomething(pageParam),\n+  queryFn: ({ pageParam }) => fetchSomething(pageParam),\n+  initialPageParam: 0,\n   getNextPageParam: (lastPage) => lastPage.next,\n})\nManual mode for infinite queries has been removed\n\nPreviously, we've allowed to overwrite the pageParams that would be returned from getNextPageParam or getPreviousPageParam by passing a pageParam value directly to fetchNextPage or fetchPreviousPage. This feature didn't work at all with refetches and wasn't widely known or used. This also means that getNextPageParam is now required for infinite queries.\n\nReturning null from getNextPageParam or getPreviousPageParam now indicates that there is no further page available\n\nIn v4, you needed to explicitly return undefined to indicate that there is no further page available. We've widened this check to include null.\n\nNo retries on the server\n\nOn the server, retry now defaults to 0 instead of 3. For prefetching, we have always defaulted to 0 retries, but since queries that have suspense enabled can now execute directly on the server as well (since React18), we have to make sure that we don't retry on the server at all.\n\nstatus: loading has been changed to status: pending and isLoading has been changed to isPending and isInitialLoading has now been renamed to isLoading\n\nThe loading status has been renamed to pending, and similarly the derived isLoading flag has been renamed to isPending.\n\nFor mutations as well the status has been changed from loading to pending and the isLoading flag has been changed to isPending.\n\nLastly, a new derived isLoading flag has been added to the queries that is implemented as isPending && isFetching. This means that isLoading and isInitialLoading have the same thing, but isInitialLoading is deprecated now and will be removed in the next major version.\n\nTo understand the reasoning behing this change checkout the v5 roadmap discussion.\n\nhashQueryKey has been renamed to hashKey\n\nbecause it also hashes mutation keys and can be used inside the predicate functions of useIsMutating and useMutationState, which gets mutations passed.\n\nVue Query Breaking Changes useQueries composable returns ref instead of reactive\n\nTo fix compatibility with Vue 2, useQueries composable now returns queries array wrapped in ref. Previously reactive was returned which led to multiple problems:\n\nUser could spread return value loosing reactivity.\nreadonly wrapper used for return value was breaking Vue 2 reactivity detection mechanism. This was a silent issue in Vue 2.6, but appeared as error in Vue 2.7.\nVue 2 does not support arrays as a root value of reactive.\n\nWith this change all of those issues are fixed.\n\nAlso this aligns useQueries with other composables which return all of the values as refs.\n\nVue v3.3 is now required\n\nTo be able to provide new features following Vue releases, we now require Vue 3 to be at least in v3.3 version. Requirements for Vue 2.x remain unchanged.\n\nNew Features ðŸš€\n\nv5 also comes with new features:\n\nSimplified optimistic updates\n\nWe have a new, simplified way to perform optimistic updates by leveraging the returned variables from useMutation:\n\ntsx\nconst queryInfo = useTodos()\nconst addTodoMutation = useMutation({\n  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),\n  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),\n})\n\n\nif (queryInfo.data) {\n  return (\n    <ul>\n      {queryInfo.data.items.map((todo) => (\n        <li key={todo.id}>{todo.text}</li>\n      ))}\n      {addTodoMutation.isPending && (\n        <li key={String(addTodoMutation.submittedAt)} style={{ opacity: 0.5 }}>\n          {addTodoMutation.variables}\n        </li>\n      )}\n    </ul>\n  )\n}\n\nHere, we are only changing how the UI looks when the mutation is running instead of writing data directly to the cache. This works best if we only have one place where we need to show the optimistic update. For more details, have a look at the optimistic updates documentation.\n\nLimited, Infinite Queries with new maxPages option\n\nInfinite queries are great when infinite scroll or pagination are needed. However, the more pages you fetch, the more memory you consume, and this also slows down the query refetching process as all the pages are sequentially refetched.\n\nVersion 5 has a new maxPages option for infinite queries, which allows developers to limit the number of pages that are stored in the query data and subsequently refetched. You can adjust the maxPages value according to the UX and refetching performance you want to deliver.\n\nNote that the infinite list must be bi-directional, which requires both getNextPageParam and getPreviousPageParam to be defined.\n\nInfinite Queries can prefetch multiple pages\n\nInfinite Queries can be prefetched like regular Queries. Per default, only the first page of the Query will be prefetched and will be stored under the given QueryKey. If you want to prefetch more than one page, you can use the pages option. Read the prefetching guide for more information.\n\nNew combine option for useQueries\n\nSee the useQueries docs for more details.\n\nExperimental fine grained storage persister\n\nSee the experimental_createPersister docs for more details.\n\nAbility to run vue-query composables in injectionContext\n\nPreviously vue-query composables could be run only within setup function of the component.\nWe had an escape hatch in place to allow those hooks to be run anywhere if user would provide queryClient as a composable option.\n\nNow you can use vue-query composables in any function that supports injectionContext. Ex. router navigation guards. When using this new feature, make sure that vue-query composable is running within effectScope. Otherwise it might lead to memory leaks. We have added dev-only warnings to inform users about potential misusage.\n"
  },
  {
    "title": "Does TanStack Query replace Vuex, Pinia or other global state managers? | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/does-this-replace-client-state",
    "html": "Does TanStack Query replace Vuex, Pinia or other global state managers?\n\nWell, let's start with a few important items:\n\nTanStack Query is a server-state library, responsible for managing asynchronous operations between your server and client\nVuex, Pinia, Zustand, etc. are client-state libraries that can be used to store asynchronous data, albeit inefficiently when compared to a tool like TanStack Query\n\nWith those points in mind, the short answer is that TanStack Query replaces the boilerplate code and related wiring used to manage cache data in your client-state and replaces it with just a few lines of code.\n\nFor a vast majority of applications, the truly globally accessible client state that is left over after migrating all of your async code to TanStack Query is usually very tiny.\n\nThere are still some circumstances where an application might indeed have a massive amount of synchronous client-only state (like a visual designer or music production application), in which case, you will probably still want a client state manager. In this situation it's important to note that TanStack Query is not a replacement for local/client state management. However, you can use TanStack Query alongside most client state managers with zero issues.\n\nA Contrived Example\n\nHere we have some \"global\" state being managed by a global state library:\n\ntsx\nconst globalState = {\n  projects,\n  teams,\n  tasks,\n  users,\n  themeMode,\n  sidebarStatus,\n}\n\nCurrently, the global state manager is caching 4 types of server-state: projects, teams, tasks, and users. If we were to move these server-state assets to TanStack Query, our remaining global state would look more like this:\n\ntsx\nconst globalState = {\n  themeMode,\n  sidebarStatus,\n}\n\nThis also means that with a few hook calls to useQuery and useMutation, we also get to remove any boilerplate code that was used to manage our server state e.g.\n\nConnectors\nAction Creators\nMiddlewares\nReducers\nLoading/Error/Result states\nContexts\n\nWith all of those things removed, you may ask yourself, \"Is it worth it to keep using our client state manager for this tiny global state?\"\n\nAnd that's up to you!\n\nBut TanStack Query's role is clear. It removes asynchronous wiring and boilerplate from your application and replaces it with just a few lines of code.\n\nWhat are you waiting for, give it a go already!\n"
  },
  {
    "title": "Custom Client | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/custom-client",
    "html": "Custom Client\nCustom client\n\nVue Query allows providing custom QueryClient for Vue context.\n\nIt might be handy when you need to create QueryClient beforehand to integrate it with other libraries that do not have access to the Vue context.\n\nFor this reason, VueQueryPlugin accepts either QueryClientConfig or QueryClient as a plugin options.\n\nIf You provide QueryClientConfig, QueryClient instance will be created internally and provided to Vue context.\n\ntsx\nconst vueQueryPluginOptions: VueQueryPluginOptions = {\n  queryClientConfig: {\n    defaultOptions: { queries: { staleTime: 3600 } },\n  },\n}\napp.use(VueQueryPlugin, vueQueryPluginOptions)\ntsx\nconst myClient = new QueryClient(queryClientConfig)\nconst vueQueryPluginOptions: VueQueryPluginOptions = {\n  queryClient: myClient,\n}\napp.use(VueQueryPlugin, vueQueryPluginOptions)\nCustom context key\n\nYou can also customize the key under which QueryClient will be accessible in Vue context. This can be usefull is you want to avoid name clashing between multiple apps on the same page with Vue2.\n\nIt works both with default, and custom QueryClient\n\ntsx\nconst vueQueryPluginOptions: VueQueryPluginOptions = {\n  queryClientKey: 'Foo',\n}\napp.use(VueQueryPlugin, vueQueryPluginOptions)\ntsx\nconst myClient = new QueryClient(queryClientConfig)\nconst vueQueryPluginOptions: VueQueryPluginOptions = {\n  queryClient: myClient,\n  queryClientKey: 'Foo',\n}\napp.use(VueQueryPlugin, vueQueryPluginOptions)\n\nTo use the custom client key, You have to provide it as a query options\n\njs\nuseQuery({\n  queryKey: ['query1'],\n  queryFn: fetcher,\n  queryClientKey: 'foo',\n})\n\nInternally custom key will be combined with default query key as a suffix. But user do not have to worry about it.\n\ntsx\nconst vueQueryPluginOptions: VueQueryPluginOptions = {\n  queryClientKey: 'Foo',\n}\napp.use(VueQueryPlugin, vueQueryPluginOptions) // -> VUE_QUERY_CLIENT:Foo"
  },
  {
    "title": "Testing | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/testing",
    "html": "Testing"
  },
  {
    "title": "Suspense (experimental) | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/suspense",
    "html": "Suspense (experimental)\n\nNOTE: Suspense mode for Vue Query is experimental, same as Vue's Suspense itself. These APIs WILL change and should not be used in production unless you lock both your Vue and Vue Query versions to patch-level versions that are compatible with each other.\n\nVue Query can also be used with Vue's new Suspense API's.\n\nTo do that you need to wrap your suspendable component with Suspense component provided by Vue\n\nvue\n<script setup>\nimport SuspendableComponent from './SuspendableComponent.vue'\n</script>\n\n\n<template>\n  <Suspense>\n    <template #default>\n      <SuspendableComponent />\n    </template>\n    <template #fallback>\n      <div>Loading...</div>\n    </template>\n  </Suspense>\n</template>\n\nAnd change your setup function in suspendable component to be async. Then you can use async suspense function that is provided by vue-query.\n\nvue\n<script>\nimport { defineComponent } from 'vue'\nimport { useQuery } from '@tanstack/vue-query'\n\n\nconst todoFetcher = async () =>\n  await fetch('https://jsonplaceholder.cypress.io/todos').then((response) =>\n    response.json(),\n  )\nexport default defineComponent({\n  name: 'SuspendableComponent',\n  async setup() {\n    const { data, suspense } = useQuery(['todos'], todoFetcher)\n    await suspense()\n\n\n    return { data }\n  },\n})\n</script>\nFetch-on-render vs Render-as-you-fetch\n\nOut of the box, Vue Query in suspense mode works really well as a Fetch-on-render solution with no additional configuration. This means that when your components attempt to mount, they will trigger query fetching and suspend, but only once you have imported them and mounted them. If you want to take it to the next level and implement a Render-as-you-fetch model, we recommend implementing Prefetching on routing callbacks and/or user interactions events to start loading queries before they are mounted and hopefully even before you start importing or mounting their parent components.\n"
  },
  {
    "title": "Caching Examples | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/caching",
    "html": "Caching Examples\n\nPlease thoroughly read the Important Defaults before reading this guide\n\nBasic Example\n\nThis caching example illustrates the story and lifecycle of:\n\nQuery Instances with and without cache data\nBackground Refetching\nInactive Queries\nGarbage Collection\n\nLet's assume we are using the default gcTime of 5 minutes and the default staleTime of 0.\n\nA new instance of useQuery({ queryKey: ['todos'], queryFn: fetchTodos }) mounts.\nSince no other queries have been made with the ['todos'] query key, this query will show a hard loading state and make a network request to fetch the data.\nWhen the network request has completed, the returned data will be cached under the ['todos'] key.\nThe hook will mark the data as stale after the configured staleTime (defaults to 0, or immediately).\nA second instance of useQuery({ queryKey: ['todos'], queryFn: fetchTodos }) mounts elsewhere.\nSince the cache already has data for the ['todos'] key from the first query, that data is immediately returned from the cache.\nThe new instance triggers a new network request using its query function.\nNote that regardless of whether both fetchTodos query functions are identical or not, both queries' status are updated (including isFetching, isPending, and other related values) because they have the same query key.\nWhen the request completes successfully, the cache's data under the ['todos'] key is updated with the new data, and both instances are updated with the new data.\nBoth instances of the useQuery({ queryKey: ['todos'], queryFn: fetchTodos }) query are unmounted and no longer in use.\nSince there are no more active instances of this query, a garbage collection timeout is set using gcTime to delete and garbage collect the query (defaults to 5 minutes).\nBefore the cache timeout has completed, another instance of useQuery({ queryKey: ['todos'], queryFn: fetchTodos }) mounts. The query immediately returns the available cached data while the fetchTodos function is being run in the background. When it completes successfully, it will populate the cache with fresh data.\nThe final instance of useQuery({ queryKey: ['todos'], queryFn: fetchTodos }) unmounts.\nNo more instances of useQuery({ queryKey: ['todos'], queryFn: fetchTodos }) appear within 5 minutes.\nThe cached data under the ['todos'] key is deleted and garbage collected."
  },
  {
    "title": "Default Query Function | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/default-query-function",
    "html": "Default Query Function\n\nIf you find yourself wishing for whatever reason that you could just share the same query function for your entire app and just use query keys to identify what it should fetch, you can do that by providing a default query function to TanStack Query:\n\ntsx\n// Define a default query function that will receive the query key\nconst defaultQueryFn = async ({ queryKey }) => {\n  const { data } = await axios.get(\n    `https://jsonplaceholder.typicode.com${queryKey[0]}`,\n  )\n  return data\n}\n\n\n// provide the default query function to your app with defaultOptions\nconst vueQueryPluginOptions: VueQueryPluginOptions = {\n  queryClientConfig: {\n    defaultOptions: { queries: { queryFn: defaultQueryFn } },\n  },\n}\napp.use(VueQueryPlugin, vueQueryPluginOptions)\n\n\n// All you have to do now is pass a key!\nconst { status, data, error, isFetching } = useQuery({\n  queryKey: [`/posts/${postId}`],\n})\n\nIf you ever want to override the default queryFn, you can just provide your own like you normally would.\n"
  },
  {
    "title": "SSR | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/ssr",
    "html": "SSR\n\nVue Query supports prefetching multiple queries on the server and then dehydrating those queries to the queryClient. This means the server can prerender markup that is immediately available on page load and as soon as JS is available, Vue Query can upgrade or hydrate those queries with the full functionality of the library. This includes refetching those queries on the client if they have become stale since the time they were rendered on the server.\n\nUsing Nuxt.js Nuxt 3\n\nFirst create vue-query.ts file in your plugins directory with the following content:\n\nts\nimport type { DehydratedState, VueQueryPluginOptions } from '@tanstack/vue-query'\nimport { VueQueryPlugin, QueryClient, hydrate, dehydrate } from '@tanstack/vue-query'\n// Nuxt 3 app aliases\nimport { defineNuxtPlugin, useState } from '#imports'\n\n\nexport default defineNuxtPlugin((nuxt) => {\n  const vueQueryState = useState<DehydratedState | null>('vue-query')\n\n\n  // Modify your Vue Query global settings here\n  const queryClient = new QueryClient({\n    defaultOptions: { queries: { staleTime: 5000 } },\n  })\n  const options: VueQueryPluginOptions = { queryClient }\n\n\n  nuxt.vueApp.use(VueQueryPlugin, options)\n\n\n  if (process.server) {\n    nuxt.hooks.hook('app:rendered', () => {\n      vueQueryState.value = dehydrate(queryClient)\n    })\n  }\n\n\n  if (process.client) {\n    nuxt.hooks.hook('app:created', () => {\n      hydrate(queryClient, vueQueryState.value)\n    })\n  }\n})\n\nNow you are ready to prefetch some data in your pages with onServerPrefetch.\n\nPrefetch all the queries that you need with queryClient.prefetchQuery or suspense\nts\nexport default defineComponent({\n  setup() {\n    const { data, suspense } = useQuery('test', fetcher)\n\n\n    onServerPrefetch(async () => {\n      await suspense()\n    })\n\n\n    return { data }\n  },\n})\nNuxt 2\n\nFirst create vue-query.js file in your plugins directory with the following content:\n\njs\nimport Vue from 'vue'\nimport { VueQueryPlugin, QueryClient, hydrate } from '@tanstack/vue-query'\n\n\nexport default (context) => {\n  // Modify your Vue Query global settings here\n  const queryClient = new QueryClient({\n    defaultOptions: { queries: { staleTime: 5000 } },\n  })\n  const options = { queryClient }\n\n\n  Vue.use(VueQueryPlugin, options)\n\n\n  if (process.client) {\n    if (context.nuxtState && context.nuxtState['vue-query']) {\n      hydrate(queryClient, context.nuxtState['vue-query'])\n    }\n  }\n}\n\nAdd this plugin to your nuxt.config.js\n\njs\nmodule.exports = {\n  ...\n  plugins: ['~/plugins/vue-query.js'],\n};\n\nNow you are ready to prefetch some data in your pages with onServerPrefetch.\n\nUse useContext to get nuxt context\nUse useQueryClient to get server-side instance of queryClient\nPrefetch all the queries that you need with queryClient.prefetchQuery or suspense\nDehydrate queryClient to the nuxtContext\njs\n// pages/todos.vue\n<template>\n  <div>\n    <button @click=\"refetch\">Refetch</button>\n    <p>{{ data }}</p>\n  </div>\n</template>\n\n\n<script lang=\"ts\">\nimport {\n  defineComponent,\n  onServerPrefetch,\n  useContext,\n} from \"@nuxtjs/composition-api\";\nimport { useQuery, useQueryClient, dehydrate } from \"@tanstack/vue-query\";\n\n\nexport default defineComponent({\n  setup() {\n    // This will be prefetched and sent from the server\n    const { refetch, data, suspense } = useQuery(\"todos\", getTodos);\n    // This won't be prefetched, it will start fetching on client side\n    const { data2 } = useQuery(\"todos2\", getTodos);\n\n\n    onServerPrefetch(async () => {\n     const { ssrContext } = useContext();\n      const queryClient = useQueryClient();\n      await suspense();\n\n\n      ssrContext.nuxt.vueQueryState = dehydrate(queryClient);\n    });\n\n\n    return {\n      refetch,\n      data,\n    };\n  },\n});\n</script>\n\nAs demonstrated, it's fine to prefetch some queries and let others fetch on the queryClient. This means you can control what content server renders or not by adding or removing prefetchQuery or suspense for a specific query.\n\nUsing Vite SSR\n\nSync VueQuery client state with vite-ssr in order to serialize it in the DOM:\n\njs\n// main.js (entry point)\nimport App from './App.vue'\nimport viteSSR from 'vite-ssr/vue'\nimport { QueryClient, VueQueryPlugin, hydrate, dehydrate } from '@tanstack/vue-query'\n\n\nexport default viteSSR(App, { routes: [] }, ({ app, initialState }) => {\n  // -- This is Vite SSR main hook, which is called once per request\n\n\n  // Create a fresh VueQuery client\n  const queryClient = new QueryClient()\n\n\n  // Sync initialState with the client state\n  if (import.meta.env.SSR) {\n    // Indicate how to access and serialize VueQuery state during SSR\n    initialState.vueQueryState = { toJSON: () => dehydrate(queryClient) }\n  } else {\n    // Reuse the existing state in the browser\n    hydrate(queryClient, initialState.vueQueryState)\n  }\n\n\n  // Mount and provide the client to the app components\n  app.use(VueQueryPlugin, { queryClient })\n})\n\nThen, call VueQuery from any component using Vue's onServerPrefetch:\n\nhtml\n<!-- MyComponent.vue -->\n<template>\n  <div>\n    <button @click=\"refetch\">Refetch</button>\n    <p>{{ data }}</p>\n  </div>\n</template>\n\n\n<script setup>\n  import { useQuery } from '@tanstack/vue-query'\n  import { onServerPrefetch } from 'vue'\n\n\n  // This will be prefetched and sent from the server\n  const { refetch, data, suspense } = useQuery('todos', getTodos)\n  onServerPrefetch(suspense)\n</script>\nTips, Tricks and Caveats Only successful queries are included in dehydration\n\nAny query with an error is automatically excluded from dehydration. This means that the default behavior is to pretend these queries were never loaded on the server, usually showing a loading state instead, and retrying the queries on the queryClient. This happens regardless of error.\n\nSometimes this behavior is not desirable, maybe you want to render an error page with a correct status code instead on certain errors or queries. In those cases, use fetchQuery and catch any errors to handle those manually.\n\nStaleness is measured from when the query was fetched on the server\n\nA query is considered stale depending on when it was dataUpdatedAt. A caveat here is that the server needs to have the correct time for this to work properly, but UTC time is used, so timezones do not factor into this.\n\nBecause staleTime defaults to 0, queries will be refetched in the background on page load by default. You might want to use a higher staleTime to avoid this double fetching, especially if you don't cache your markup.\n\nThis refetching of stale queries is a perfect match when caching markup in a CDN! You can set the cache time of the page itself decently high to avoid having to re-render pages on the server, but configure the staleTime of the queries lower to make sure data is refetched in the background as soon as a user visits the page. Maybe you want to cache the pages for a week, but refetch the data automatically on page load if it's older than a day?\n\nHigh memory consumption on server\n\nIn case you are creating the QueryClient for every request, Vue Query creates the isolated cache for this client, which is preserved in memory for the gcTime period. That may lead to high memory consumption on server in case of high number of requests during that period.\n\nOn the server, gcTime defaults to Infinity which disables manual garbage collection and will automatically clear memory once a request has finished. If you are explicitly setting a non-Infinity gcTime then you will be responsible for clearing the cache early.\n\nTo clear the cache after it is not needed and to lower memory consumption, you can add a call to queryClient.clear() after the request is handled and dehydrated state has been sent to the client.\n\nAlternatively, you can set a smaller gcTime.\n"
  },
  {
    "title": "Filters | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/filters",
    "html": "Filters\n\nSome methods within TanStack Query accept a QueryFilters or MutationFilters object.\n\nQuery Filters\n\nA query filter is an object with certain conditions to match a query with:\n\ntsx\n// Cancel all queries\nawait queryClient.cancelQueries()\n\n\n// Remove all inactive queries that begin with `posts` in the key\nqueryClient.removeQueries({ queryKey: ['posts'], type: 'inactive' })\n\n\n// Refetch all active queries\nawait queryClient.refetchQueries({ type: 'active' })\n\n\n// Refetch all active queries that begin with `posts` in the key\nawait queryClient.refetchQueries({ queryKey: ['posts'], type: 'active' })\n\nA query filter object supports the following properties:\n\nqueryKey?: QueryKey\nSet this property to define a query key to match on.\nexact?: boolean\nIf you don't want to search queries inclusively by query key, you can pass the exact: true option to return only the query with the exact query key you have passed.\ntype?: 'active' | 'inactive' | 'all'\nDefaults to all\nWhen set to active it will match active queries.\nWhen set to inactive it will match inactive queries.\nstale?: boolean\nWhen set to true it will match stale queries.\nWhen set to false it will match fresh queries.\nfetchStatus?: FetchStatus\nWhen set to fetching it will match queries that are currently fetching.\nWhen set to paused it will match queries that wanted to fetch, but have been paused.\nWhen set to idle it will match queries that are not fetching.\npredicate?: (query: Query) => boolean\nThis predicate function will be used as a final filter on all matching queries. If no other filters are specified, this function will be evaluated against every query in the cache.\nMutation Filters\n\nA mutation filter is an object with certain conditions to match a mutation with:\n\ntsx\n// Get the number of all fetching mutations\nawait queryClient.isMutating()\n\n\n// Filter mutations by mutationKey\nawait queryClient.isMutating({ mutationKey: [\"post\"] })\n\n\n// Filter mutations using a predicate function\nawait queryClient.isMutating({\n  predicate: (mutation) => mutation.options.variables?.id === 1,\n})\n\nA mutation filter object supports the following properties:\n\nmutationKey?: MutationKey\nSet this property to define a mutation key to match on.\nexact?: boolean\nIf you don't want to search mutations inclusively by mutation key, you can pass the exact: true option to return only the mutation with the exact mutation key you have passed.\nstatus?: MutationStatus\nAllows for filtering mutations according to their status.\npredicate?: (mutation: Mutation) => boolean\nThis predicate function will be used as a final filter on all matching mutations. If no other filters are specified, this function will be evaluated against every mutation in the cache."
  },
  {
    "title": "Scroll Restoration | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/scroll-restoration",
    "html": "Scroll Restoration\n\nTraditionally, when you navigate to a previously visited page on a web browser, you would find that the page would be scrolled to the exact position where you were before you navigated away from that page. This is called scroll restoration and has been in a bit of a regression since web applications have started moving towards client side data fetching. With TanStack Query however, that's no longer the case.\n\nOut of the box, \"scroll restoration\" for all queries (including paginated and infinite queries) Just Worksâ„¢ï¸ in TanStack Query. The reason for this is that query results are cached and able to be retrieved synchronously when a query is rendered. As long as your queries are being cached long enough (the default time is 5 minutes) and have not been garbage collected, scroll restoration will work out of the box all the time.\n"
  },
  {
    "title": "Query Cancellation | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/query-cancellation",
    "html": "Query Cancellation\n\nTanStack Query provides each query function with an AbortSignal instance. When a query becomes out-of-date or inactive, this signal will become aborted. This means that all queries are cancellable, and you can respond to the cancellation inside your query function if desired. The best part about this is that it allows you to continue to use normal async/await syntax while getting all the benefits of automatic cancellation.\n\nThe AbortController API is available in most runtime environments, but if your runtime environment does not support it, you will need to provide a polyfill. There are several available.\n\nDefault behavior\n\nBy default, queries that unmount or become unused before their promises are resolved are not cancelled. This means that after the promise has resolved, the resulting data will be available in the cache. This is helpful if you've started receiving a query, but then unmount the component before it finishes. If you mount the component again and the query has not been garbage collected yet, data will be available.\n\nHowever, if you consume the AbortSignal, the Promise will be cancelled (e.g. aborting the fetch) and therefore, also the Query must be cancelled. Cancelling the query will result in its state being reverted to its previous state.\n\nUsing fetch\ntsx\nconst query = useQuery({\n  queryKey: ['todos'],\n  queryFn: async ({ signal }) => {\n    const todosResponse = await fetch('/todos', {\n      // Pass the signal to one fetch\n      signal,\n    })\n    const todos = await todosResponse.json()\n\n\n    const todoDetails = todos.map(async ({ details }) => {\n      const response = await fetch(details, {\n        // Or pass it to several\n        signal,\n      })\n      return response.json()\n    })\n\n\n    return Promise.all(todoDetails)\n  },\n})\nUsing axios v0.22.0+\ntsx\nimport axios from 'axios'\n\n\nconst query = useQuery({\n  queryKey: ['todos'],\n  queryFn: ({ signal }) =>\n    axios.get('/todos', {\n      // Pass the signal to `axios`\n      signal,\n    }),\n})\nUsing axios with version lower than v0.22.0\ntsx\nimport axios from 'axios'\n\n\nconst query = useQuery({\n  queryKey: ['todos'],\n  queryFn: ({ signal }) => {\n    // Create a new CancelToken source for this request\n    const CancelToken = axios.CancelToken\n    const source = CancelToken.source()\n\n\n    const promise = axios.get('/todos', {\n      // Pass the source token to your request\n      cancelToken: source.token,\n    })\n\n\n    // Cancel the request if TanStack Query signals to abort\n    signal?.addEventListener('abort', () => {\n      source.cancel('Query was cancelled by TanStack Query')\n    })\n\n\n    return promise\n  },\n})\nUsing XMLHttpRequest\ntsx\nconst query = useQuery({\n  queryKey: ['todos'],\n  queryFn: ({ signal }) => {\n    return new Promise((resolve, reject) => {\n      var oReq = new XMLHttpRequest()\n      oReq.addEventListener('load', () => {\n        resolve(JSON.parse(oReq.responseText))\n      })\n      signal?.addEventListener('abort', () => {\n        oReq.abort()\n        reject()\n      })\n      oReq.open('GET', '/todos')\n      oReq.send()\n    })\n  },\n})\nUsing graphql-request\n\nAn AbortSignal can be set in the client request method.\n\ntsx\nconst client = new GraphQLClient(endpoint)\n\n\nconst query = useQuery({\n  queryKey: ['todos'],\n  queryFn: ({ signal }) => {\n    client.request({ document: query, signal })\n  },\n})\nUsing graphql-request with version lower than v4.0.0\n\nAn AbortSignal can be set in the GraphQLClient constructor.\n\ntsx\nconst query = useQuery({\n  queryKey: ['todos'],\n  queryFn: ({ signal }) => {\n    const client = new GraphQLClient(endpoint, {\n      signal,\n    })\n    return client.request(query, variables)\n  },\n})\nManual Cancellation\n\nYou might want to cancel a query manually. For example, if the request takes a long time to finish, you can allow the user to click a cancel button to stop the request. To do this, you just need to call queryClient.cancelQueries({ queryKey }), which will cancel the query and revert it back to its previous state. If you have consumed the signal passed to the query function, TanStack Query will additionally also cancel the Promise.\n\nts\nconst query = useQuery({\n  queryKey: ['todos'],\n  queryFn: async ({ signal }) => {\n    const resp = await fetch('/todos', { signal })\n    return resp.json()\n  },\n})\n\n\nconst queryClient = useQueryClient()\n\n\nfunction onButtonClick() {\n  queryClient.cancelQueries({ queryKey: ['todos'] })\n}"
  },
  {
    "title": "Optimistic Updates | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/optimistic-updates",
    "html": "Optimistic Updates\n\nReact Query provides two ways to optimistically update your UI before a mutation has completed. You can either use the onMutate option to update your cache directly, or leverage the returned variables to update your UI from the useMutation result.\n\nVia the UI\n\nThis is the simpler variant, as it doesn't interact with the cache directly.\n\ntsx\nconst { isPending, submittedAt, variables, mutate, isError } = useMutation({\n    mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),\n    // make sure to _return_ the Promise from the query invalidation\n    // so that the mutation stays in `pending` state until the refetch is finished\n    onSettled: async () => {\n      return await queryClient.invalidateQueries({ queryKey: ['todos'] })\n    },\n  })\n\nyou will then have access to addTodoMutation.variables, which contain the added todo. In your UI list, where the query is rendered, you can append another item to the list while the mutation is pending:\n\ntsx\n<ul>\n  {todoQuery.items.map((todo) => (\n    <li key={todo.id}>{todo.text}</li>\n  ))}\n  {isPending && (\n    <li style={{ opacity: 0.5 }}>\n      {variables}\n    </li>\n  )}\n</ul>\n\nWe're rendering a temporary item with a different opacity as long as the mutation is pending. Once it completes, the item will automatically no longer be rendered. Given that the refetch succeeded, we should see the item as a \"normal item\" in our list.\n\nIf the mutation errors, the item will also disappear. But we could continue to show it, if we want, by checking for the isError state of the mutation. variables are not cleared when the mutation errors, so we can still access them, maybe even show a retry button:\n\ntsx\n{isError && (\n  <li\n    style={{ color: 'red' }}\n  >\n    {variables}\n    <button onClick={() => mutate(variables)}>\n      Retry\n    </button>\n  </li>\n)}\nIf the mutation and the query don't live in the same component\n\nThis approach works very well if the mutation and the query live in the same component, However, you also get access to all mutations in other components via the dedicated useMutationState hook. It is best combined with a mutationKey:\n\ntsx\n// somewhere in your app\nconst { mutate } = useMutation({\n  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),\n  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),\n  mutationKey: ['addTodo']\n})\n\n\n// access variables somewhere else\nconst variables = useMutationState<string>({\n  filters: { mutationKey: ['addTodo'], status: 'pending' },\n  select: (mutation) => mutation.state.variables\n})\n\nvariables will be an Array, because there might be multiple mutations running at the same time. If we need a unique key for the items, we can also select mutation.state.submittedAt. This will even make displaying concurrent optimistic updates a breeze.\n\nVia the cache\n\nWhen you optimistically update your state before performing a mutation, there is a chance that the mutation will fail. In most of these failure cases, you can just trigger a refetch for your optimistic queries to revert them to their true server state. In some circumstances though, refetching may not work correctly and the mutation error could represent some type of server issue that won't make it possible to refetch. In this event, you can instead choose to roll back your update.\n\nTo do this, useMutation's onMutate handler option allows you to return a value that will later be passed to both onError and onSettled handlers as the last argument. In most cases, it is most useful to pass a rollback function.\n\nUpdating a list of todos when adding a new todo\ntsx\nconst queryClient = useQueryClient()\n\n\nuseMutation({\n  mutationFn: updateTodo,\n  // When mutate is called:\n  onMutate: async (newTodo) => {\n    // Cancel any outgoing refetches\n    // (so they don't overwrite our optimistic update)\n    await queryClient.cancelQueries({ queryKey: ['todos'] })\n\n\n    // Snapshot the previous value\n    const previousTodos = queryClient.getQueryData(['todos'])\n\n\n    // Optimistically update to the new value\n    queryClient.setQueryData(['todos'], (old) => [...old, newTodo])\n\n\n    // Return a context object with the snapshotted value\n    return { previousTodos }\n  },\n  // If the mutation fails,\n  // use the context returned from onMutate to roll back\n  onError: (err, newTodo, context) => {\n    queryClient.setQueryData(['todos'], context.previousTodos)\n  },\n  // Always refetch after error or success:\n  onSettled: () => {\n    queryClient.invalidateQueries({ queryKey: ['todos'] })\n  },\n})\nUpdating a single todo\ntsx\nuseMutation({\n  mutationFn: updateTodo,\n  // When mutate is called:\n  onMutate: async (newTodo) => {\n    // Cancel any outgoing refetches\n    // (so they don't overwrite our optimistic update)\n    await queryClient.cancelQueries({ queryKey: ['todos', newTodo.id] })\n\n\n    // Snapshot the previous value\n    const previousTodo = queryClient.getQueryData(['todos', newTodo.id])\n\n\n    // Optimistically update to the new value\n    queryClient.setQueryData(['todos', newTodo.id], newTodo)\n\n\n    // Return a context with the previous and new todo\n    return { previousTodo, newTodo }\n  },\n  // If the mutation fails, use the context we returned above\n  onError: (err, newTodo, context) => {\n    queryClient.setQueryData(\n      ['todos', context.newTodo.id],\n      context.previousTodo,\n    )\n  },\n  // Always refetch after error or success:\n  onSettled: (newTodo) => {\n    queryClient.invalidateQueries({ queryKey: ['todos', newTodo.id] })\n  },\n})\n\nYou can also use the onSettled function in place of the separate onError and onSuccess handlers if you wish:\n\ntsx\nuseMutation({\n  mutationFn: updateTodo,\n  // ...\n  onSettled: (newTodo, error, variables, context) => {\n    if (error) {\n      // do something\n    }\n  },\n})\nWhen to use what\n\nIf you only have one place where the optimistic result should be shown, using variables and updating the UI directly is the approach that requires less code and is generally easier to reason about. For example, you don't need to handle rollbacks at all.\n\nHowever, if you have multiple places on the screen that would require to know about the update, manipulating the cache directly will take care of this for you automatically.\n"
  },
  {
    "title": "Updates from Mutation Responses | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/updates-from-mutation-responses",
    "html": "Updates from Mutation Responses\n\nWhen dealing with mutations that update objects on the server, it's common for the new object to be automatically returned in the response of the mutation. Instead of refetching any queries for that item and wasting a network call for data we already have, we can take advantage of the object returned by the mutation function and update the existing query with the new data immediately using the Query Client's setQueryData method:\n\ntsx\nconst queryClient = useQueryClient()\n\n\nconst mutation = useMutation({\n  mutationFn: editTodo,\n  onSuccess: data => {\n    queryClient.setQueryData(['todo', { id: 5 }], data)\n  }\n})\n\n\nmutation.mutate({\n  id: 5,\n  name: 'Do the laundry',\n})\n\n\n// The query below will be updated with the response from the\n// successful mutation\nconst { status, data, error } = useQuery({\n  queryKey: ['todo', { id: 5 }],\n  queryFn: fetchTodoById,\n})\n\nYou might want to tie the onSuccess logic into a reusable mutation, for that you can create a custom hook like this:\n\ntsx\nconst useMutateTodo = () => {\n  const queryClient = useQueryClient()\n\n\n  return useMutation({\n    mutationFn: editTodo,\n    // Notice the second argument is the variables object that the `mutate` function receives\n    onSuccess: (data, variables) => {\n      queryClient.setQueryData(['todo', { id: variables.id }], data)\n    },\n  })\n}\nImmutability\n\nUpdates via setQueryData must be performed in an immutable way. DO NOT attempt to write directly to the cache by mutating data (that you retrieved from the cache) in place. It might work at first but can lead to subtle bugs along the way.\n\ntsx\nqueryClient.setQueryData(\n  ['posts', { id }],\n  (oldData) => {\n    if (oldData) {\n      // âŒ do not try this\n      oldData.title = 'my new post title'\n    }\n    return oldData\n  })\n\n\nqueryClient.setQueryData(\n  ['posts', { id }],\n  // âœ… this is the way\n  (oldData) => oldData ? {\n    ...oldData,\n    title: 'my new post title'\n  } : oldData\n)"
  },
  {
    "title": "Query Invalidation | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/query-invalidation",
    "html": "Query Invalidation\n\nWaiting for queries to become stale before they are fetched again doesn't always work, especially when you know for a fact that a query's data is out of date because of something the user has done. For that purpose, the QueryClient has an invalidateQueries method that lets you intelligently mark queries as stale and potentially refetch them too!\n\ntsx\n// Invalidate every query in the cache\nqueryClient.invalidateQueries()\n// Invalidate every query with a key that starts with `todos`\nqueryClient.invalidateQueries({ queryKey: ['todos'] })\n\nNote: Where other libraries that use normalized caches would attempt to update local queries with the new data either imperatively or via schema inference, TanStack Query gives you the tools to avoid the manual labor that comes with maintaining normalized caches and instead prescribes targeted invalidation, background-refetching and ultimately atomic updates.\n\nWhen a query is invalidated with invalidateQueries, two things happen:\n\nIt is marked as stale. This stale state overrides any staleTime configurations being used in useQuery or related hooks\nIf the query is currently being rendered via useQuery or related hooks, it will also be refetched in the background\nQuery Matching with invalidateQueries\n\nWhen using APIs like invalidateQueries and removeQueries (and others that support partial query matching), you can match multiple queries by their prefix, or get really specific and match an exact query. For information on the types of filters you can use, please see Query Filters.\n\nIn this example, we can use the todos prefix to invalidate any queries that start with todos in their query key:\n\ntsx\nimport { useQuery, useQueryClient } from '@tanstack/vue-query'\n\n\n// Get QueryClient from the context\nconst queryClient = useQueryClient()\n\n\nqueryClient.invalidateQueries({ queryKey: ['todos'] })\n\n\n// Both queries below will be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos'],\n  queryFn: fetchTodoList,\n})\nconst todoListQuery = useQuery({\n  queryKey: ['todos', { page: 1 }],\n  queryFn: fetchTodoList,\n})\n\nYou can even invalidate queries with specific variables by passing a more specific query key to the invalidateQueries method:\n\ntsx\nqueryClient.invalidateQueries({\n  queryKey: ['todos', { type: 'done' }],\n})\n\n\n// The query below will be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos', { type: 'done' }],\n  queryFn: fetchTodoList,\n})\n\n\n// However, the following query below will NOT be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos'],\n  queryFn: fetchTodoList,\n})\n\nThe invalidateQueries API is very flexible, so even if you want to only invalidate todos queries that don't have any more variables or subkeys, you can pass an exact: true option to the invalidateQueries method:\n\ntsx\nqueryClient.invalidateQueries({\n  queryKey: ['todos'],\n  exact: true,\n})\n\n\n// The query below will be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos'],\n  queryFn: fetchTodoList,\n})\n\n\n// However, the following query below will NOT be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos', { type: 'done' }],\n  queryFn: fetchTodoList,\n})\n\nIf you find yourself wanting even more granularity, you can pass a predicate function to the invalidateQueries method. This function will receive each Query instance from the query cache and allow you to return true or false for whether you want to invalidate that query:\n\ntsx\nqueryClient.invalidateQueries({\n  predicate: (query) =>\n    query.queryKey[0] === 'todos' && query.queryKey[1]?.version >= 10,\n})\n\n\n// The query below will be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos', { version: 20 }],\n  queryFn: fetchTodoList,\n})\n\n\n// The query below will be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos', { version: 10 }],\n  queryFn: fetchTodoList,\n})\n\n\n// However, the following query below will NOT be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos', { version: 5 }],\n  queryFn: fetchTodoList,\n})"
  },
  {
    "title": "Invalidations from Mutations | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/invalidations-from-mutations",
    "html": "Invalidations from Mutations\n\nInvalidating queries is only half the battle. Knowing when to invalidate them is the other half. Usually when a mutation in your app succeeds, it's VERY likely that there are related queries in your application that need to be invalidated and possibly refetched to account for the new changes from your mutation.\n\nFor example, assume we have a mutation to post a new todo:\n\ntsx\nconst mutation = useMutation({ mutationFn: postTodo })\n\nWhen a successful postTodo mutation happens, we likely want all todos queries to get invalidated and possibly refetched to show the new todo item. To do this, you can use useMutation's onSuccess options and the client's invalidateQueries function:\n\ntsx\nimport { useMutation, useQueryClient } from '@tanstack/vue-query'\n\n\nconst queryClient = useQueryClient()\n\n\n// When this mutation succeeds, invalidate any queries with the `todos` or `reminders` query key\nconst mutation = useMutation({\n  mutationFn: addTodo,\n  onSuccess: () => {\n    queryClient.invalidateQueries({ queryKey: ['todos'] })\n    queryClient.invalidateQueries({ queryKey: ['reminders'] })\n  },\n})\n\nYou can wire up your invalidations to happen using any of the callbacks available in the useMutation hook\n"
  },
  {
    "title": "Mutations | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/mutations",
    "html": "Mutations\n\nUnlike queries, mutations are typically used to create/update/delete data or perform server side-effects. For this purpose, TanStack Query exports a useMutation hook.\n\nHere's an example of a mutation that adds a new todo to the server:\n\nvue\n<script setup>\nimport { useMutation } from '@tanstack/vue-query'\n\n\nconst { isPending, isError, error, isSuccess, mutate } = useMutation({\n  mutationFn: (newTodo) => axios.post('/todos', newTodo),\n})\n\n\nfunction addTodo() {\n  mutate({ id: new Date(), title: 'Do Laundry' })\n}\n</script>\n\n\n<template>\n  <span v-if=\"isPending\">Adding todo...</span>\n  <span v-else-if=\"isError\">An error occurred: {{ error.message }}</span>\n  <span v-else-if=\"isSuccess\">Todo added!</span>\n  <button @click=\"addTodo\">Create Todo</button>\n</template>\n\nA mutation can only be in one of the following states at any given moment:\n\nisIdle or status === 'idle' - The mutation is currently idle or in a fresh/reset state\nisPending or status === 'pending' - The mutation is currently running\nisError or status === 'error' - The mutation encountered an error\nisSuccess or status === 'success' - The mutation was successful and mutation data is available\n\nBeyond those primary states, more information is available depending on the state of the mutation:\n\nerror - If the mutation is in an error state, the error is available via the error property.\ndata - If the mutation is in a success state, the data is available via the data property.\n\nIn the example above, you also saw that you can pass variables to your mutations function by calling the mutate function with a single variable or object.\n\nEven with just variables, mutations aren't all that special, but when used with the onSuccess option, the Query Client's invalidateQueries method and the Query Client's setQueryData method, mutations become a very powerful tool.\n\nResetting Mutation State\n\nIt's sometimes the case that you need to clear the error or data of a mutation request. To do this, you can use the reset function to handle this:\n\nvue\n<script>\nimport { useMutation } from '@tanstack/vue-query'\n\n\nconst { error, mutate, reset } = useMutation({\n  mutationFn: (newTodo) => axios.post('/todos', newTodo),\n})\n\n\nfunction addTodo() {\n  mutate({ id: new Date(), title: 'Do Laundry' })\n}\n</script>\n\n\n<template>\n  <span v-else-if=\"error\">\n    <span>An error occurred: {{ error.message }}</span>\n    <button @click=\"reset\">Reset error</button>\n  </span>\n  <button @click=\"addTodo\">Create Todo</button>\n</template>\nMutation Side Effects\n\nuseMutation comes with some helper options that allow quick and easy side-effects at any stage during the mutation lifecycle. These come in handy for both invalidating and refetching queries after mutations and even optimistic updates\n\ntsx\nuseMutation({\n  mutationFn: addTodo,\n  onMutate: (variables) => {\n    // A mutation is about to happen!\n\n\n    // Optionally return a context containing data to use when for example rolling back\n    return { id: 1 }\n  },\n  onError: (error, variables, context) => {\n    // An error happened!\n    console.log(`rolling back optimistic update with id ${context.id}`)\n  },\n  onSuccess: (data, variables, context) => {\n    // Boom baby!\n  },\n  onSettled: (data, error, variables, context) => {\n    // Error or success... doesn't matter!\n  },\n})\n\nWhen returning a promise in any of the callback functions it will first be awaited before the next callback is called:\n\ntsx\nuseMutation({\n  mutationFn: addTodo,\n  onSuccess: async () => {\n    console.log(\"I'm first!\")\n  },\n  onSettled: async () => {\n    console.log(\"I'm second!\")\n  },\n})\n\nYou might find that you want to trigger additional callbacks beyond the ones defined on useMutation when calling mutate. This can be used to trigger component-specific side effects. To do that, you can provide any of the same callback options to the mutate function after your mutation variable. Supported options include: onSuccess, onError and onSettled. Please keep in mind that those additional callbacks won't run if your component unmounts before the mutation finishes.\n\ntsx\nuseMutation({\n  mutationFn: addTodo,\n  onSuccess: (data, variables, context) => {\n    // I will fire first\n  },\n  onError: (error, variables, context) => {\n    // I will fire first\n  },\n  onSettled: (data, error, variables, context) => {\n    // I will fire first\n  },\n})\n\n\nmutate(todo, {\n  onSuccess: (data, variables, context) => {\n    // I will fire second!\n  },\n  onError: (error, variables, context) => {\n    // I will fire second!\n  },\n  onSettled: (data, error, variables, context) => {\n    // I will fire second!\n  },\n})\nConsecutive mutations\n\nThere is a slight difference in handling onSuccess, onError and onSettled callbacks when it comes to consecutive mutations. When passed to the mutate function, they will be fired up only once and only if the component is still mounted. This is due to the fact that mutation observer is removed and resubscribed every time when the mutate function is called. On the contrary, useMutation handlers execute for each mutate call.\n\nBe aware that most likely, mutationFn passed to useMutation is asynchronous. In that case, the order in which mutations are fulfilled may differ from the order of mutate function calls.\n\ntsx\nuseMutation({\n  mutationFn: addTodo,\n  onSuccess: (data, error, variables, context) => {\n    // Will be called 3 times\n  },\n})\n\n\n[('Todo 1', 'Todo 2', 'Todo 3')].forEach((todo) => {\n  mutate(todo, {\n    onSuccess: (data, error, variables, context) => {\n      // Will execute only once, for the last mutation (Todo 3),\n      // regardless which mutation resolves first\n    },\n  })\n})\nPromises\n\nUse mutateAsync instead of mutate to get a promise which will resolve on success or throw on an error. This can for example be used to compose side effects.\n\ntsx\nconst mutation = useMutation({ mutationFn: addTodo })\n\n\ntry {\n  const todo = await mutation.mutateAsync(todo)\n  console.log(todo)\n} catch (error) {\n  console.error(error)\n} finally {\n  console.log('done')\n}\nRetry\n\nBy default TanStack Query will not retry a mutation on error, but it is possible with the retry option:\n\ntsx\nconst mutation = useMutation({\n  mutationFn: addTodo,\n  retry: 3,\n})\n\nIf mutations fail because the device is offline, they will be retried in the same order when the device reconnects.\n\nPersist mutations\n\nMutations can be persisted to storage if needed and resumed at a later point. This can be done with the hydration functions:\n\ntsx\nconst queryClient = new QueryClient()\n\n\n// Define the \"addTodo\" mutation\nqueryClient.setMutationDefaults(['addTodo'], {\n  mutationFn: addTodo,\n  onMutate: async (variables) => {\n    // Cancel current queries for the todos list\n    await queryClient.cancelQueries({ queryKey: ['todos'] })\n\n\n    // Create optimistic todo\n    const optimisticTodo = { id: uuid(), title: variables.title }\n\n\n    // Add optimistic todo to todos list\n    queryClient.setQueryData(['todos'], (old) => [...old, optimisticTodo])\n\n\n    // Return context with the optimistic todo\n    return { optimisticTodo }\n  },\n  onSuccess: (result, variables, context) => {\n    // Replace optimistic todo in the todos list with the result\n    queryClient.setQueryData(['todos'], (old) =>\n      old.map((todo) =>\n        todo.id === context.optimisticTodo.id ? result : todo,\n      ),\n    )\n  },\n  onError: (error, variables, context) => {\n    // Remove optimistic todo from the todos list\n    queryClient.setQueryData(['todos'], (old) =>\n      old.filter((todo) => todo.id !== context.optimisticTodo.id),\n    )\n  },\n  retry: 3,\n})\n\n\n// Start mutation in some component:\nconst mutation = useMutation({ mutationKey: ['addTodo'] })\nmutation.mutate({ title: 'title' })\n\n\n// If the mutation has been paused because the device is for example offline,\n// Then the paused mutation can be dehydrated when the application quits:\nconst state = dehydrate(queryClient)\n\n\n// The mutation can then be hydrated again when the application is started:\nhydrate(queryClient, state)\n\n\n// Resume the paused mutations:\nqueryClient.resumePausedMutations()\nPersisting Offline mutations\n\nIf you persist offline mutations with the persistQueryClient plugin, mutations cannot be resumed when the page is reloaded unless you provide a default mutation function.\n\nThis is a technical limitation. When persisting to an external storage, only the state of mutations is persisted, as functions cannot be serialized. After hydration, the component that triggers the mutation might not be mounted, so calling resumePausedMutations might yield an error: No mutationFn found.\n\njs\nconst client = new QueryClient({\n  defaultOptions: {\n    queries: {\n      gcTime: 1000 * 60 * 60 * 24, // 24 hours\n    },\n  },\n})\n\n\n// we need a default mutation function so that paused mutations can resume after a page reload\nqueryClient.setMutationDefaults({\n  mutationKey: ['todos'],\n  mutationFn: ({ id, data }) => {\n    return api.updateTodo(id, data)\n  },\n})\n\n\nconst vueQueryOptions: VueQueryPluginOptions = {\n  queryClient: client,\n  clientPersister: (queryClient) => {\n    return persistQueryClient({\n      queryClient,\n      persister: createSyncStoragePersister({ storage: localStorage }),\n    })\n  },\n  clientPersisterOnSuccess: (queryClient) => {\n    queryClient.resumePausedMutations()\n  },\n}\n\n\ncreateApp(App).use(VueQueryPlugin, vueQueryOptions).mount('#app')\n\nWe also have an extensive offline example that covers both queries and mutations.\n"
  },
  {
    "title": "Prefetching | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/prefetching",
    "html": "Prefetching\n\nIf you're lucky enough, you may know enough about what your users will do to be able to prefetch the data they need before it's needed! If this is the case, you can use the prefetchQuery method to prefetch the results of a query to be placed into the cache:\n\ntsx\nconst prefetchTodos = async () => {\n  // The results of this query will be cached like a normal query\n  await queryClient.prefetchQuery({\n    queryKey: ['todos'],\n    queryFn: fetchTodos,\n  })\n}\nIf fresh data for this query is already in the cache, the data will not be fetched\nIf a staleTime is passed eg. prefetchQuery({ queryKey: ['todos'], queryFn: fn, staleTime: 5000 }) and the data is older than the specified staleTime, the query will be fetched\nIf no instances of useQuery appear for a prefetched query, it will be deleted and garbage collected after the time specified in gcTime.\nPrefetching Infinite Queries\n\nInfinite Queries can be prefetched like regular Queries. Per default, only the first page of the Query will be prefetched and will be stored under the given QueryKey. If you want to prefetch more than one page, you can use the pages option, in which case you also have to provide a getNextPageParam function:\n\ntsx\nconst prefetchTodos = async () => {\n  // The results of this query will be cached like a normal query\n  await queryClient.prefetchInfiniteQuery({\n    queryKey: ['projects'],\n    queryFn: fetchProjects,\n    initialPageParam: 0,\n    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n    pages: 3, // prefetch the first 3 pages\n  })\n}\n\nThe above code will try to prefetch 3 pages in order, and getNextPageParam will be executed for each page to determine the next page to prefetch. If getNextPageParam returns undefined, the prefetching will stop.\n"
  },
  {
    "title": "Placeholder Query Data | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/placeholder-query-data",
    "html": "Placeholder Query Data\nWhat is placeholder data?\n\nPlaceholder data allows a query to behave as if it already has data, similar to the initialData option, but the data is not persisted to the cache. This comes in handy for situations where you have enough partial (or fake) data to render the query successfully while the actual data is fetched in the background.\n\nExample: An individual blog post query could pull \"preview\" data from a parent list of blog posts that only include title and a small snippet of the post body. You would not want to persist this partial data to the query result of the individual query, but it is useful for showing the content layout as quickly as possible while the actual query finishes to fetch the entire object.\n\nThere are a few ways to supply placeholder data for a query to the cache before you need it:\n\nDeclaratively:\nProvide placeholderData to a query to prepopulate its cache if empty\nImperatively:\nPrefetch or fetch the data using queryClient and the placeholderData option\n\nWhen we use placeholderData, our Query will not be in a pending state - it will start out as being in success state, because we have data to display - even if that data is just \"placeholder\" data. To distinguish it from \"real\" data, we will also have the isPlaceholderData flag set to true on the Query result.\n\nPlaceholder Data as a Value\ntsx\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  placeholderData: placeholderTodos,\n})\nPlaceholder Data as a Function\n\nplaceholderData can also be a function, where you can get access to the data and Query meta information of a \"previous\" successful Query. This is useful for situations where you want to use the data from one query as the placeholder data for another query. When the QueryKey changes, e.g. from ['todos', 1] to ['todos', 2], we can keep displaying \"old\" data instead of having to show a loading spinner while data is transitioning from one Query to the next. For more information, see Paginated Queries.\n\ntsx\nconst result = useQuery({\n  queryKey: ['todos', id],\n  queryFn: () => fetch(`/todos/${id}`),\n  placeholderData: (previousData, previousQuery) => previousData,\n})\nPlaceholder Data from Cache\n\nIn some circumstances, you may be able to provide the placeholder data for a query from the cached result of another. A good example of this would be searching the cached data from a blog post list query for a preview version of the post, then using that as the placeholder data for your individual post query:\n\ntsx\nconst result = useQuery({\n  queryKey: ['blogPost', blogPostId],\n  queryFn: () => fetch(`/blogPosts/${blogPostId}`),\n  placeholderData: () => {\n    // Use the smaller/preview version of the blogPost from the 'blogPosts'\n    // query as the placeholder data for this blogPost query\n    return queryClient\n      .getQueryData(['blogPosts'])\n      ?.find((d) => d.id === blogPostId)\n  },\n})"
  },
  {
    "title": "Initial Query Data | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/initial-query-data",
    "html": "Initial Query Data\n\nThere are many ways to supply initial data for a query to the cache before you need it:\n\nDeclaratively:\nProvide initialData to a query to prepopulate its cache if empty\nImperatively:\nPrefetch the data using queryClient.prefetchQuery\nManually place the data into the cache using queryClient.setQueryData\nUsing initialData to prepopulate a query\n\nThere may be times when you already have the initial data for a query available in your app and can simply provide it directly to your query. If and when this is the case, you can use the config.initialData option to set the initial data for a query and skip the initial loading state!\n\nIMPORTANT: initialData is persisted to the cache, so it is not recommended to provide placeholder, partial or incomplete data to this option and instead use placeholderData\n\ntsx\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n})\nstaleTime and initialDataUpdatedAt\n\nBy default, initialData is treated as totally fresh, as if it were just fetched. This also means that it will affect how it is interpreted by the staleTime option.\n\nIf you configure your query observer with initialData, and no staleTime (the default staleTime: 0), the query will immediately refetch when it mounts:\n\ntsx\n// Will show initialTodos immediately, but also immediately refetch todos after mount\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n})\n\nIf you configure your query observer with initialData and a staleTime of 1000 ms, the data will be considered fresh for that same amount of time, as if it was just fetched from your query function.\n\ntsx\n// Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n  staleTime: 1000,\n})\n\nSo what if your initialData isn't totally fresh? That leaves us with the last configuration that is actually the most accurate and uses an option called initialDataUpdatedAt. This option allows you to pass a numeric JS timestamp in milliseconds of when the initialData itself was last updated, e.g. what Date.now() provides. Take note that if you have a unix timestamp, you'll need to convert it to a JS timestamp by multiplying it by 1000.\n\ntsx\n// Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n  staleTime: 60 * 1000, // 1 minute\n  // This could be 10 seconds ago or 10 minutes ago\n  initialDataUpdatedAt: initialTodosUpdatedTimestamp, // eg. 1608412420052\n})\n\nThis option allows the staleTime to be used for its original purpose, determining how fresh the data needs to be, while also allowing the data to be refetched on mount if the initialData is older than the staleTime. In the example above, our data needs to be fresh within 1 minute, and we can hint to the query when the initialData was last updated so the query can decide for itself whether the data needs to be refetched again or not.\n\nIf you would rather treat your data as prefetched data, we recommend that you use the prefetchQuery or fetchQuery APIs to populate the cache beforehand, thus letting you configure your staleTime independently from your initialData\n\nInitial Data Function\n\nIf the process for accessing a query's initial data is intensive or just not something you want to perform on every render, you can pass a function as the initialData value. This function will be executed only once when the query is initialized, saving you precious memory and/or CPU:\n\ntsx\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: () => getExpensiveTodos(),\n})\nInitial Data from Cache\n\nIn some circumstances, you may be able to provide the initial data for a query from the cached result of another. A good example of this would be searching the cached data from a todos list query for an individual todo item, then using that as the initial data for your individual todo query:\n\ntsx\nconst result = useQuery({\n  queryKey: ['todo', todoId],\n  queryFn: () => fetch('/todos'),\n  initialData: () => {\n    // Use a todo from the 'todos' query as the initial data for this todo query\n    return queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId)\n  },\n})\nInitial Data from the cache with initialDataUpdatedAt\n\nGetting initial data from the cache means the source query you're using to look up the initial data from is likely old, but initialData. Instead of using an artificial staleTime to keep your query from refetching immediately, it's suggested that you pass the source query's dataUpdatedAt to initialDataUpdatedAt. This provides the query instance with all the information it needs to determine if and when the query needs to be refetched, regardless of initial data being provided.\n\ntsx\nconst result = useQuery({\n  queryKey: ['todos', todoId],\n  queryFn: () => fetch(`/todos/${todoId}`),\n  initialData: () =>\n    queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId),\n  initialDataUpdatedAt: () =>\n    queryClient.getQueryState(['todos'])?.dataUpdatedAt,\n})\nConditional Initial Data from Cache\n\nIf the source query you're using to look up the initial data from is old, you may not want to use the cached data at all and just fetch from the server. To make this decision easier, you can use the queryClient.getQueryState method instead to get more information about the source query, including a state.dataUpdatedAt timestamp you can use to decide if the query is \"fresh\" enough for your needs:\n\ntsx\nconst result = useQuery({\n  queryKey: ['todo', todoId],\n  queryFn: () => fetch(`/todos/${todoId}`),\n  initialData: () => {\n    // Get the query state\n    const state = queryClient.getQueryState(['todos'])\n\n\n    // If the query exists and has data that is no older than 10 seconds...\n    if (state && Date.now() - state.dataUpdatedAt <= 10 * 1000) {\n      // return the individual todo\n      return state.data.find((d) => d.id === todoId)\n    }\n\n\n    // Otherwise, return undefined and let it fetch from a hard loading state!\n  },\n})"
  },
  {
    "title": "Infinite Queries | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/infinite-queries",
    "html": "Infinite Queries\n\nRendering lists that can additively \"load more\" data onto an existing set of data or \"infinite scroll\" is also a very common UI pattern. TanStack Query supports a useful version of useQuery called useInfiniteQuery for querying these types of lists.\n\nWhen using useInfiniteQuery, you'll notice a few things are different:\n\ndata is now an object containing infinite query data:\ndata.pages array containing the fetched pages\ndata.pageParams array containing the page params used to fetch the pages\nThe fetchNextPage and fetchPreviousPage functions are now available (fetchNextPage is required)\nThe initialPageParam option is now available (and required) to specify the initial page param\nThe getNextPageParam and getPreviousPageParam options are available for both determining if there is more data to load and the information to fetch it. This information is supplied as an additional parameter in the query function\nA hasNextPage boolean is now available and is true if getNextPageParam returns a value other than null or undefined\nA hasPreviousPage boolean is now available and is true if getPreviousPageParam returns a value other than null or undefined\nThe isFetchingNextPage and isFetchingPreviousPage booleans are now available to distinguish between a background refresh state and a loading more state\n\nNote: Options initialData or placeholderData need to conform to the same structure of an object with data.pages and data.pageParams properties.\n\nExample\n\nLet's assume we have an API that returns pages of projects 3 at a time based on a cursor index along with a cursor that can be used to fetch the next group of projects:\n\ntsx\nfetch('/api/projects?cursor=0')\n// { data: [...], nextCursor: 3}\nfetch('/api/projects?cursor=3')\n// { data: [...], nextCursor: 6}\nfetch('/api/projects?cursor=6')\n// { data: [...], nextCursor: 9}\nfetch('/api/projects?cursor=9')\n// { data: [...] }\n\nWith this information, we can create a \"Load More\" UI by:\n\nWaiting for useInfiniteQuery to request the first group of data by default\nReturning the information for the next query in getNextPageParam\nCalling fetchNextPage function\nvue\n<script setup>\nimport { useInfiniteQuery } from '@tanstack/vue-query'\n\n\nconst fetchProjects = async ({ pageParam = 0 }) => {\n  const res = await fetch('/api/projects?cursor=' + pageParam)\n  return res.json()\n}\n\n\nconst {\n  data,\n  error,\n  fetchNextPage,\n  hasNextPage,\n  isFetching,\n  isFetchingNextPage,\n  isPending,\n  isError,\n} = useInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n})\n</script>\n\n\n<template>\n  <span v-if=\"isPending\">Loading...</span>\n  <span v-else-if=\"isError\">Error: {{ error.message }}</span>\n  <div v-else-if=\"data\">\n    <span v-if=\"isFetching && !isFetchingNextPage\">Fetching...</span>\n    <ul v-for=\"(group, index) in data.pages\" :key=\"index\">\n      <li v-for=\"project in group.projects\" :key=\"project.id\">\n        {{ project.name }}\n      </li>\n    </ul>\n    <button\n      @click=\"() => fetchNextPage()\"\n      :disabled=\"!hasNextPage || isFetchingNextPage\"\n    >\n      <span v-if=\"isFetchingNextPage\">Loading more...</span>\n      <span v-else-if=\"hasNextPage\">Load More</span>\n      <span v-else>Nothing more to load</span>\n    </button>\n  </div>\n</template>\n\nIt's essential to understand that calling fetchNextPage while an ongoing fetch is in progress runs the risk of overwriting data refreshes happening in the background. This situation becomes particularly critical when rendering a list and triggering fetchNextPage simultaneously.\n\nRemember, there can only be a single ongoing fetch for an InfiniteQuery. A single cache entry is shared for all pages, attempting to fetch twice simultaneously might lead to data overwrites.\n\nIf you intend to enable simultaneous fetching, you can utilize the { cancelRefetch: false } option (default: true) within fetchNextPage.\n\nTo ensure a seamless querying process without conflicts, it's highly recommended to verify that the query is not in an isFetching state, especially if the user won't directly control that call.\n\njsx\n<List\n  onEndReached={() => !isFetching && fetchNextPage()}\n/>\nWhat happens when an infinite query needs to be refetched?\n\nWhen an infinite query becomes stale and needs to be refetched, each group is fetched sequentially, starting from the first one. This ensures that even if the underlying data is mutated, we're not using stale cursors and potentially getting duplicates or skipping records. If an infinite query's results are ever removed from the queryCache, the pagination restarts at the initial state with only the initial group being requested.\n\nWhat if I want to implement a bi-directional infinite list?\n\nBi-directional lists can be implemented by using the getPreviousPageParam, fetchPreviousPage, hasPreviousPage and isFetchingPreviousPage properties and functions.\n\ntsx\nuseInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  initialPageParam: 0,\n  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,\n})\nWhat if I want to show the pages in reversed order?\n\nSometimes you may want to show the pages in reversed order. If this is case, you can use the select option:\n\ntsx\nuseInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  select: (data) => ({\n    pages: [...data.pages].reverse(),\n    pageParams: [...data.pageParams].reverse(),\n  }),\n})\nWhat if I want to manually update the infinite query? Manually removing first page:\ntsx\nqueryClient.setQueryData(['projects'], (data) => ({\n  pages: data.pages.slice(1),\n  pageParams: data.pageParams.slice(1),\n}))\nManually removing a single value from an individual page:\ntsx\nconst newPagesArray =\n  oldPagesArray?.pages.map((page) =>\n    page.filter((val) => val.id !== updatedId),\n  ) ?? []\n\n\nqueryClient.setQueryData(['projects'], (data) => ({\n  pages: newPagesArray,\n  pageParams: data.pageParams,\n}))\nKeep only the first page:\ntsx\nqueryClient.setQueryData(['projects'], (data) => ({\n  pages: data.pages.slice(0,1),\n  pageParams: data.pageParams.slice(0,1),\n}))\n\nMake sure to always keep the same data structure of pages and pageParams!\n\nWhat if I want to limit the number of pages?\n\nIn some use cases you may want to limit the number of pages stored in the query data to improve the performance and UX:\n\nwhen the user can load a large number of pages (memory usage)\nwhen you have to refetch an infinite query that contains dozens of pages (network usage: all the pages are sequentially fetched)\n\nThe solution is to use a \"Limited Infinite Query\". This is made possible by using the maxPages option in conjunction with getNextPageParam and getPreviousPageParam to allow fetching pages when needed in both directions.\n\nIn the following example only 3 pages are kept in the query data pages array. If a refetch is needed, only 3 pages will be refetched sequentially.\n\ntsx\nuseInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  initialPageParam: 0,\n  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,\n  maxPages: 3,\n})\nWhat if my API doesn't return a cursor?\n\nIf your API doesn't return a cursor, you can use the pageParam as a cursor. Because getNextPageParam and getPreviousPageParam also get the pageParamof the current page, you can use it to calculate the next / previous page param.\n\ntsx\nreturn useInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  initialPageParam: 0,\n  getNextPageParam: (lastPage, allPages, lastPageParam) => {\n    if (lastPage.length === 0) {\n        return undefined\n    }\n    return lastPageParam + 1\n  },\n  getPreviousPageParam: (firstPage, allPages, firstPageParam) => {\n    if (firstPageParam <= 1) {\n        return undefined\n    }\n    return firstPageParam - 1\n  },\n})"
  },
  {
    "title": "Paginated / Lagged Queries | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/paginated-queries",
    "html": "Paginated / Lagged Queries\n\nRendering paginated data is a very common UI pattern and in TanStack Query, it \"just works\" by including the page information in the query key:\n\ntsx\nconst result = useQuery({\n  queryKey: ['projects', page],\n  queryFn: fetchProjects\n})\n\nHowever, if you run this simple example, you might notice something strange:\n\nThe UI jumps in and out of the success and pending states because each new page is treated like a brand new query.\n\nThis experience is not optimal and unfortunately is how many tools today insist on working. But not TanStack Query! As you may have guessed, TanStack Query comes with an awesome feature called placeholderData that allows us to get around this.\n\nBetter Paginated Queries with placeholderData\n\nConsider the following example where we would ideally want to increment a pageIndex (or cursor) for a query. If we were to use useQuery, it would still technically work fine, but the UI would jump in and out of the success and pending states as different queries are created and destroyed for each page or cursor. By setting placeholderData to (previousData) => previousData or keepPreviousData function exported from TanStack Query, we get a few new things:\n\nThe data from the last successful fetch is available while new data is being requested, even though the query key has changed.\nWhen the new data arrives, the previous data is seamlessly swapped to show the new data.\nisPlaceholderData is made available to know what data the query is currently providing you\nvue\n<script setup lang=\"ts\">\nimport { ref, Ref } from 'vue'\nimport { useQuery } from '@tanstack/vue-query'\n\n\nconst fetcher = (page: Ref<number>) =>\n  fetch(\n    `https://jsonplaceholder.typicode.com/posts?_page=${page.value}&_limit=10`,\n  ).then((response) => response.json())\n\n\nconst page = ref(1)\nconst { isPending, isError, data, error, isFetching, isPreviousData } =\n  useQuery({\n    queryKey: ['projects', page],\n    queryFn: () => fetcher(page),\n    keepPreviousData: true,\n  })\nconst prevPage = () => {\n  page.value = Math.max(page.value - 1, 1)\n}\nconst nextPage = () => {\n  if (!isPreviousData.value) {\n    page.value = page.value + 1\n  }\n}\n</script>\n\n\n<template>\n  <h1>Posts</h1>\n  <p>Current Page: {{ page }} | Previous data: {{ isPreviousData }}</p>\n  <button @click=\"prevPage\">Prev Page</button>\n  <button @click=\"nextPage\">Next Page</button>\n  <div v-if=\"isPending\">Loading...</div>\n  <div v-else-if=\"isError\">An error has occurred: {{ error }}</div>\n  <div v-else-if=\"data\">\n    <ul>\n      <li v-for=\"item in data\" :key=\"item.id\">\n        {{ item.title }}\n      </li>\n    </ul>\n  </div>\n</template>\nLagging Infinite Query results with placeholderData\n\nWhile not as common, the placeholderData option also works flawlessly with the useInfiniteQuery hook, so you can seamlessly allow your users to continue to see cached data while infinite query keys change over time.\n"
  },
  {
    "title": "Query Retries | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/query-retries",
    "html": "Query Retries\n\nWhen a useQuery query fails (the query function throws an error), TanStack Query will automatically retry the query if that query's request has not reached the max number of consecutive retries (defaults to 3) or a function is provided to determine if a retry is allowed.\n\nYou can configure retries both on a global level and an individual query level.\n\nSetting retry = false will disable retries.\nSetting retry = 6 will retry failing requests 6 times before showing the final error thrown by the function.\nSetting retry = true will infinitely retry failing requests.\nSetting retry = (failureCount, error) => ... allows for custom logic based on why the request failed.\n\nOn the server, retries default to 0 to make server rendering as fast as possible.\n\ntsx\nimport { useQuery } from '@tanstack/vue-query'\n\n\n// Make a specific query retry a certain number of times\nconst result = useQuery({\n  queryKey: ['todos', 1],\n  queryFn: fetchTodoListPage,\n  retry: 10, // Will retry failed requests 10 times before displaying an error\n})\n\nInfo: Contents of the error property will be part of failureReason response property of useQuery until the last retry attempt. So in above example any error contents will be part of failureReason property for first 9 retry attempts (Overall 10 attempts) and finally they will be part of error after last attempt if error persists after all retry attempts.\n\nRetry Delay\n\nBy default, retries in TanStack Query do not happen immediately after a request fails. As is standard, a back-off delay is gradually applied to each retry attempt.\n\nThe default retryDelay is set to double (starting at 1000ms) with each attempt, but not exceed 30 seconds:\n\nts\nimport { VueQueryPlugin } from '@tanstack/vue-query'\n\n\nconst vueQueryPluginOptions = {\n  queryClientConfig: {\n    defaultOptions: {\n      queries: {\n        retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),\n      },\n    },\n  },\n}\napp.use(VueQueryPlugin, vueQueryPluginOptions)\n\nThough it is not recommended, you can obviously override the retryDelay function/integer in both the Plugin and individual query options. If set to an integer instead of a function the delay will always be the same amount of time:\n\ntsx\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: fetchTodoList,\n  retryDelay: 1000, // Will always wait 1000ms to retry, regardless of how many retries\n})"
  },
  {
    "title": "Disabling/Pausing Queries | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/disabling-queries",
    "html": "Disabling/Pausing Queries\n\nIf you ever want to disable a query from automatically running, you can use the enabled = false option.\n\nWhen enabled is false:\n\nIf the query has cached data, then the query will be initialized in the status === 'success' or isSuccess state.\nIf the query does not have cached data, then the query will start in the status === 'pending' and fetchStatus === 'idle' state.\nThe query will not automatically fetch on mount.\nThe query will not automatically refetch in the background.\nThe query will ignore query client invalidateQueries and refetchQueries calls that would normally result in the query refetching.\nrefetch returned from useQuery can be used to manually trigger the query to fetch.\nvue\n<script setup>\nimport { useQuery } from '@tanstack/vue-query'\n\n\nconst { isLoading, isError, data, error, refetch, isFetching } =\n  useQuery({\n    queryKey: ['todos'],\n    queryFn: fetchTodoList,\n    enabled: false,\n  })\n</script>\n\n\n<template>\n  <button @click=\"refetch\">Fetch Todos</button>\n  <span v-if=\"isIdle\">Not ready...</span>\n  <span v-else-if=\"isError\">Error: {{ error.message }}</span>\n  <div v-else-if=\"data\">\n    <span v-if=\"isFetching\">Fetching...</span>\n    <ul>\n      <li v-for=\"todo in data\" :key=\"todo.id\">{{ todo.title }}</li>\n    </ul>\n  </div>\n</template>\n\nPermanently disabling a query opts out of many great features that TanStack Query has to offer (like background refetches), and it's also not the idiomatic way. It takes you from the declarative approach (defining dependencies when your query should run) into an imperative mode (fetch whenever I click here). It is also not possible to pass parameters to refetch. Oftentimes, all you want is a lazy query that defers the initial fetch:\n\nLazy Queries\n\nThe enabled option can not only be used to permanently disable a query, but also to enable / disable it at a later time. A good example would be a filter form where you only want to fire off the first request once the user has entered a filter value:\n\nvue\n<script setup>\nimport { useQuery } from '@tanstack/vue-query'\n\n\nconst filter = ref('')\nconst isEnabled = computed(() => !!filter.value)\nconst { data } = useQuery({\n  queryKey: ['todos', filter],\n  queryFn: () => fetchTodos(filter),\n  // â¬‡ï¸ disabled as long as the filter is empty\n  enabled: isEnabled,\n})\n</script>\n\n\n<template>\n  <span v-if=\"data\">Filter was set and data is here!</span>\n</template>\nisLoading (Previously: isInitialLoading)\n\nLazy queries will be in status: 'pending' right from the start because pending means that there is no data yet. This is technically true, however, since we are not currently fetching any data (as the query is not enabled), it also means you likely cannot use this flag to show a loading spinner.\n\nIf you are using disabled or lazy queries, you can use the isLoading flag instead. It's a derived flag that is computed from:\n\nisPending && isFetching\n\nso it will only be true if the query is currently fetching for the first time.\n"
  },
  {
    "title": "Window Focus Refetching | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/window-focus-refetching",
    "html": "Window Focus Refetching\n\nIf a user leaves your application and returns and the query data is stale, TanStack Query automatically requests fresh data for you in the background. You can disable this globally or per-query using the refetchOnWindowFocus option:\n\nDisabling Globally\njs\nconst vueQueryPluginOptions: VueQueryPluginOptions = {\n  queryClientConfig: {\n    defaultOptions: {\n      queries: {\n        refetchOnWindowFocus: false,\n      },\n    },\n  },\n}\napp.use(VueQueryPlugin, vueQueryPluginOptions)\nDisabling Per-Query\ntsx\nuseQuery({\n  queryKey: ['todos'],\n  queryFn: fetchTodos,\n  refetchOnWindowFocus: false,\n})\nCustom Window Focus Event\n\nIn rare circumstances, you may want to manage your own window focus events that trigger TanStack Query to revalidate. To do this, TanStack Query provides a focusManager.setEventListener function that supplies you the callback that should be fired when the window is focused and allows you to set up your own events. When calling focusManager.setEventListener, the previously set handler is removed (which in most cases will be the default handler) and your new handler is used instead. For example, this is the default handler:\n\ntsx\nfocusManager.setEventListener((handleFocus) => {\n  // Listen to visibilitychange\n  if (typeof window !== 'undefined' && window.addEventListener) {\n    window.addEventListener('visibilitychange', () => handleFocus(), false)\n    return () => {\n      // Be sure to unsubscribe if a new handler is set\n      window.removeEventListener('visibilitychange', () => handleFocus())\n    }\n  }\n})\nManaging focus state\ntsx\nimport { focusManager } from '@tanstack/vue-query'\n\n\n// Override the default focus state\nfocusManager.setFocused(true)\n\n\n// Fallback to the default focus check\nfocusManager.setFocused(undefined)"
  },
  {
    "title": "Background Fetching Indicators | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/background-fetching-indicators",
    "html": "Background Fetching Indicators\n\nA query's status === 'pending' state is sufficient enough to show the initial hard-loading state for a query, but sometimes you may want to display an additional indicator that a query is refetching in the background. To do this, queries also supply you with an isFetching boolean that you can use to show that it's in a fetching state, regardless of the state of the status variable:\n\nvue\n<script setup>\nimport { useQuery } from '@tanstack/vue-query'\n\n\nconst { isPending, isFetching, isError, data, error } = useQuery({\n  queryKey: ['todos'],\n  queryFn: getTodos,\n})\n</script>\n\n\n<template>\n  <div v-if=\"isFetching\">Refreshing...</div>\n  <span v-if=\"isPending\">Loading...</span>\n  <span v-else-if=\"isError\">Error: {{ error.message }}</span>\n  <!-- We can assume by this point that `isSuccess === true` -->\n  <ul v-else-if=\"data\">\n    <li v-for=\"todo in data\" :key=\"todo.id\">{{ todo.title }}</li>\n  </ul>\n</template>\nDisplaying Global Background Fetching Loading State\n\nIn addition to individual query loading states, if you would like to show a global loading indicator when any queries are fetching (including in the background), you can use the useIsFetching hook:\n\nvue\n<script setup>\nimport { useIsFetching } from '@tanstack/vue-query'\n\n\nconst isFetching = useIsFetching()\n</script>\n\n\n<template>\n  <div v-if=\"isFetching\">Queries are fetching in the background...</div>\n</template>"
  },
  {
    "title": "Dependent Queries | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/dependent-queries",
    "html": "Dependent Queries\nuseQuery dependent Query\n\nDependent (or serial) queries depend on previous ones to finish before they can execute. To achieve this, it's as easy as using the enabled option to tell a query when it is ready to run:\n\njs\n// Get the user\nconst { data: user } = useQuery({\n  queryKey: ['user', email],\n  queryFn: () => getUserByEmail(email.value),\n})\n\n\nconst userId = computed(() => user.value?.id)\nconst enabled = computed(() => !!user.value?.id)\n\n\n// Then get the user's projects\nconst { isIdle, data: projects } = useQuery({\n  queryKey: ['projects', userId],\n  queryFn: () => getProjectsByUser(userId.value),\n  enabled, // The query will not execute until `enabled == true`\n})\n\nThe projects query will start in:\n\ntsx\nstatus: 'pending'\nisPending: true\nfetchStatus: 'idle'\n\nAs soon as the user is available, the projects query will be enabled and will then transition to:\n\ntsx\nstatus: 'pending'\nisPending: true\nfetchStatus: 'fetching'\n\nOnce we have the projects, it will go to:\n\ntsx\nstatus: 'success'\nisPending: false\nfetchStatus: 'idle'\nuseQueries dependent Query\n\nDynamic parallel query - useQueries can depend on a previous query also, here's how to achieve this:\n\ntsx\n// Get the users ids\nconst { data: userIds } = useQuery({\n  queryKey: ['users'],\n  queryFn: getUsersData,\n  select: (users) => users.map((user) => user.id),\n})\n\n\n// Then get the users messages\nconst usersMessages = useQueries({\n  queries: userIds\n    ? userIds.map((id) => {\n        return {\n          queryKey: ['messages', id],\n          queryFn: () => getMessagesByUsers(id),\n        }\n      })\n    : [], // if users is undefined, an empty array will be returned\n})\n\nNote that useQueries return an array of query results\n\nA note about performance\n\nDependent queries by definition constitutes a form of request waterfall, which hurts performance. If we pretend both queries take the same amount of time, doing them serially instead of in parallel always takes twice as much time, which is especially hurtful when it happens on a client that has high latency. If you can, it's always better to restructure the backend APIs so that both queries can be fetched in parallel, though that might not always be practically feasible.\n\nIn the example above, instead of first fetching getUserByEmail to be able to getProjectsByUser, introducing a new getProjectsByUserEmail query would flatten the waterfall.\n"
  },
  {
    "title": "Parallel Queries | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/parallel-queries",
    "html": "Parallel Queries\n\n\"Parallel\" queries are queries that are executed in parallel, or at the same time so as to maximize fetching concurrency.\n\nManual Parallel Queries\n\nWhen the number of parallel queries does not change, there is no extra effort to use parallel queries. Just use any number of TanStack Query's useQuery and useInfiniteQuery hooks side-by-side!\n\nvue\n<script setup lang=\"ts\">\n// The following queries will execute in parallel\nconst usersQuery = useQuery({ queryKey: ['users'], queryFn: fetchUsers })\nconst teamsQuery = useQuery({ queryKey: ['teams'], queryFn: fetchTeams })\nconst projectsQuery = useQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n})\n</script>\nDynamic Parallel Queries with useQueries\n\nIf the number of queries you need to execute is changing from render to render, you cannot use manual querying since that would violate the rules of hooks. Instead, TanStack Query provides a useQueries hook, which you can use to dynamically execute as many queries in parallel as you'd like.\n\nuseQueries accepts an options object with a queries key whose value is an array of query objects. It returns an array of query results:\n\njs\nconst users = computed(...)\nconst queries = computed(() => users.value.map(user => {\n    return {\n      queryKey: ['user', user.id],\n      queryFn: () => fetchUserById(user.id),\n    }\n  })\n);\nconst userQueries = useQueries({queries: queries})"
  },
  {
    "title": "Network Mode | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/network-mode",
    "html": "Network Mode\n\nTanStack Query provides three different network modes to distinguish how Queries and Mutations should behave if you have no network connection. This mode can be set for each Query / Mutation individually, or globally via the query / mutation defaults.\n\nSince TanStack Query is most often used for data fetching in combination with data fetching libraries, the default network mode is online.\n\nNetwork Mode: online\n\nIn this mode, Queries and Mutations will not fire unless you have network connection. This is the default mode. If a fetch is initiated for a query, it will always stay in the state (pending, error, success) it is in if the fetch cannot be made because there is no network connection. However, a fetchStatus is exposed additionally. This can be either:\n\nfetching: The queryFn is really executing - a request is in-flight.\npaused: The query is not executing - it is paused until you have connection again\nidle: The query is not fetching and not paused\n\nThe flags isFetching and isPaused are derived from this state and exposed for convenience.\n\nKeep in mind that it might not be enough to check for pending state to show a loading spinner. Queries can be in state: 'pending', but fetchStatus: 'paused' if they are mounting for the first time, and you have no network connection.\n\nIf a query runs because you are online, but you go offline while the fetch is still happening, TanStack Query will also pause the retry mechanism. Paused queries will then continue to run once you re-gain network connection. This is independent of refetchOnReconnect (which also defaults to true in this mode), because it is not a refetch, but rather a continue. If the query has been cancelled in the meantime, it will not continue.\n\nNetwork Mode: always\n\nIn this mode, TanStack Query will always fetch and ignore the online / offline state. This is likely the mode you want to choose if you use TanStack Query in an environment where you don't need an active network connection for your Queries to work - e.g. if you just read from AsyncStorage, or if you just want to return Promise.resolve(5) from your queryFn.\n\nQueries will never be paused because you have no network connection.\nRetries will also not pause - your Query will go to error state if it fails.\nrefetchOnReconnect defaults to false in this mode, because reconnecting to the network is not a good indicator anymore that stale queries should be refetched. You can still turn it on if you want.\nNetwork Mode: offlineFirst\n\nThis mode is the middle ground between the first two options, where TanStack Query will run the queryFn once, but then pause retries. This is very handy if you have a serviceWorker that intercepts a request for caching like in an offline-first PWA, or if you use HTTP caching via the Cache-Control header.\n\nIn those situations, the first fetch might succeed because it comes from an offline storage / cache. However, if there is a cache miss, the network request will go out and fail, in which case this mode behaves like an online query - pausing retries.\n\nDevtools\n\nThe TanStack Query Devtools will show Queries in a paused state if they would be fetching, but there is no network connection. There is also a toggle button to Mock offline behavior. Please note that this button will not actually mess with your network connection (you can do that in the browser devtools), but it will set the OnlineManager in an offline state.\n\nSignature\nnetworkMode: 'online' | 'always' | 'offlineFirst'\noptional\ndefaults to 'online'"
  },
  {
    "title": "Query Functions | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/query-functions",
    "html": "Query Functions\n\nA query function can be literally any function that returns a promise. The promise that is returned should either resolve the data or throw an error.\n\nAll of the following are valid query function configurations:\n\ntsx\nuseQuery({ queryKey: ['todos'], queryFn: fetchAllTodos })\nuseQuery({ queryKey: ['todos', todoId], queryFn: () => fetchTodoById(todoId) })\nuseQuery({\n  queryKey: ['todos', todoId],\n  queryFn: async () => {\n    const data = await fetchTodoById(todoId)\n    return data\n  },\n})\nuseQuery({\n  queryKey: ['todos', todoId],\n  queryFn: ({ queryKey }) => fetchTodoById(queryKey[1]),\n})\nHandling and Throwing Errors\n\nFor TanStack Query to determine a query has errored, the query function must throw or return a rejected Promise. Any error that is thrown in the query function will be persisted on the error state of the query.\n\ntsx\nconst { error } = useQuery({\n  queryKey: ['todos', todoId],\n  queryFn: async () => {\n    if (somethingGoesWrong) {\n      throw new Error('Oh no!')\n    }\n    if (somethingElseGoesWrong) {\n      return Promise.reject(new Error('Oh no!'))\n    }\n\n\n    return data\n  },\n})\nUsage with fetch and other clients that do not throw by default\n\nWhile most utilities like axios or graphql-request automatically throw errors for unsuccessful HTTP calls, some utilities like fetch do not throw errors by default. If that's the case, you'll need to throw them on your own. Here is a simple way to do that with the popular fetch API:\n\ntsx\nuseQuery({\n  queryKey: ['todos', todoId],\n  queryFn: async () => {\n    const response = await fetch('/todos/' + todoId)\n    if (!response.ok) {\n      throw new Error('Network response was not ok')\n    }\n    return response.json()\n  },\n})\nQuery Function Variables\n\nQuery keys are not just for uniquely identifying the data you are fetching, but are also conveniently passed into your query function as part of the QueryFunctionContext. While not always necessary, this makes it possible to extract your query functions if needed:\n\njs\nconst result = useQuery({\n  queryKey: ['todos', { status, page }],\n  queryFn: fetchTodoList,\n})\n\n\n// Access the key, status and page variables in your query function!\nfunction fetchTodoList({ queryKey }) {\n  const [_key, { status, page }] = queryKey\n  return new Promise()\n}\nQueryFunctionContext\n\nThe QueryFunctionContext is the object passed to each query function. It consists of:\n\nqueryKey: QueryKey: Query Keys\nsignal?: AbortSignal\nAbortSignal instance provided by TanStack Query\nCan be used for Query Cancellation\nmeta: Record<string, unknown> | undefined\nan optional field you can fill with additional information about your query\n\nAdditionally, Infinite Queries get the following options passed:\n\npageParam: TPageParam\nthe page parameter used to fetch the current page\ndirection: 'forward' | 'backward'\nthe direction of the current page fetch"
  },
  {
    "title": "Query Keys | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/query-keys",
    "html": "Query Keys\n\nAt its core, TanStack Query manages query caching for you based on query keys. Query keys have to be an Array at the top level, and can be as simple as an Array with a single string, or as complex as an array of many strings and nested objects. As long as the query key is serializable, and unique to the query's data, you can use it!\n\nSimple Query Keys\n\nThe simplest form of a key is an array with constants values. This format is useful for:\n\nGeneric List/Index resources\nNon-hierarchical resources\ntsx\n// A list of todos\nuseQuery({ queryKey: ['todos'], ... })\n\n\n// Something else, whatever!\nuseQuery({ queryKey: ['something', 'special'], ... })\nArray Keys with variables\n\nWhen a query needs more information to uniquely describe its data, you can use an array with a string and any number of serializable objects to describe it. This is useful for:\n\nHierarchical or nested resources\nIt's common to pass an ID, index, or other primitive to uniquely identify the item\nQueries with additional parameters\nIt's common to pass an object of additional options\ntsx\n// An individual todo\nuseQuery({ queryKey: ['todo', 5], ... })\n\n\n// An individual todo in a \"preview\" format\nuseQuery({ queryKey: ['todo', 5, { preview: true }], ...})\n\n\n// A list of todos that are \"done\"\nuseQuery({ queryKey: ['todos', { type: 'done' }], ... })\nQuery Keys are hashed deterministically!\n\nThis means that no matter the order of keys in objects, all of the following queries are considered equal:\n\ntsx\nuseQuery({ queryKey: ['todos', { status, page }], ... })\nuseQuery({ queryKey: ['todos', { page, status }], ...})\nuseQuery({ queryKey: ['todos', { page, status, other: undefined }], ... })\n\nThe following query keys, however, are not equal. Array item order matters!\n\ntsx\nuseQuery({ queryKey: ['todos', status, page], ... })\nuseQuery({ queryKey: ['todos', page, status], ...})\nuseQuery({ queryKey: ['todos', undefined, page, status], ...})\nIf your query function depends on a variable, include it in your query key\n\nSince query keys uniquely describe the data they are fetching, they should include any variables you use in your query function that change. For example:\n\njs\nfunction useTodos(todoId) {\n  const queryKey = ['todos', todoId]\n  return useQuery(queryKey, () => fetchTodoById(todoId.value))\n}\n\nNote that query keys act as dependencies for your query functions. Adding dependent variables to your query key will ensure that queries are cached independently, and that any time a variable changes, queries will be refetched automatically (depending on your staleTime settings). See the exhaustive-deps section for more information and examples.\n\nFurther reading\n\nFor tips on organizing Query Keys in larger applications, have a look at Effective React Query Keys and check the Query Key Factory Package from the Community Resources.\n"
  },
  {
    "title": "Queries | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/queries",
    "html": "Queries\nQuery Basics\n\nA query is a declarative dependency on an asynchronous source of data that is tied to a unique key. A query can be used with any Promise based method (including GET and POST methods) to fetch data from a server. If your method modifies data on the server, we recommend using Mutations instead.\n\nTo subscribe to a query in your components or custom hooks, call the useQuery hook with at least:\n\nA unique key for the query\nA function that returns a promise that:\nResolves the data, or\nThrows an error\nts\nimport { useQuery } from '@tanstack/vue-query'\n\n\nconst result = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })\n\nThe unique key you provide is used internally for refetching, caching, and sharing your queries throughout your application.\n\nThe query result returned by useQuery contains all of the information about the query that you'll need for templating and any other usage of the data:\n\ntsx\nconst result = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })\n\nThe result object contains a few very important states you'll need to be aware of to be productive. A query can only be in one of the following states at any given moment:\n\nisPending or status === 'pending' - The query has no data yet\nisError or status === 'error' - The query encountered an error\nisSuccess or status === 'success' - The query was successful and data is available\n\nBeyond those primary states, more information is available depending on the state of the query:\n\nerror - If the query is in an isError state, the error is available via the error property.\ndata - If the query is in an isSuccess state, the data is available via the data property.\nisFetching - In any state, if the query is fetching at any time (including background refetching) isFetching will be true.\n\nFor most queries, it's usually sufficient to check for the isPending state, then the isError state, then finally, assume that the data is available and render the successful state:\n\nvue\n<script setup>\nimport { useQuery } from '@tanstack/vue-query'\n\n\nconst { isPending, isError, data, error } = useQuery({\n  queryKey: ['todos'],\n  queryFn: fetchTodoList,\n})\n</script>\n\n\n<template>\n  <span v-if=\"isPending\">Loading...</span>\n  <span v-else-if=\"isError\">Error: {{ error.message }}</span>\n  <!-- We can assume by this point that `isSuccess === true` -->\n  <ul v-else-if=\"data\">\n    <li v-for=\"todo in data\" :key=\"todo.id\">{{ todo.title }}</li>\n  </ul>\n</template>\n\nIf booleans aren't your thing, you can always use the status state as well:\n\nvue\n<script setup>\nimport { useQuery } from '@tanstack/vue-query'\n\n\nconst { status, data, error } = useQuery({\n  queryKey: ['todos'],\n  queryFn: fetchTodoList,\n})\n</script>\n\n\n<template>\n  <span v-if=\"status === 'pending'\">Loading...</span>\n  <span v-else-if=\"status === 'error'\">Error: {{ error.message }}</span>\n  <!-- also status === 'success', but \"else\" logic works, too -->\n  <ul v-else-if=\"data\">\n    <li v-for=\"todo in data\" :key=\"todo.id\">{{ todo.title }}</li>\n  </ul>\n</template>\n\nTypeScript will also narrow the type of data correctly if you've checked for pending and error before accessing it.\n\nFetchStatus\n\nIn addition to the status field, you will also get an additional fetchStatus property with the following options:\n\nfetchStatus === 'fetching' - The query is currently fetching.\nfetchStatus === 'paused' - The query wanted to fetch, but it is paused. Read more about this in the Network Mode guide.\nfetchStatus === 'idle' - The query is not doing anything at the moment.\nWhy two different states?\n\nBackground refetches and stale-while-revalidate logic make all combinations for status and fetchStatus possible. For example:\n\na query in success status will usually be in idle fetchStatus, but it could also be in fetching if a background refetch is happening.\na query that mounts and has no data will usually be in pending status and fetching fetchStatus, but it could also be paused if there is no network connection.\n\nSo keep in mind that a query can be in pending state without actually fetching data. As a rule of thumb:\n\nThe status gives information about the data: Do we have any or not?\nThe fetchStatus gives information about the queryFn: Is it running or not?"
  },
  {
    "title": "Important Defaults | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/guides/important-defaults",
    "html": "Important Defaults\n\nOut of the box, TanStack Query is configured with aggressive but sane defaults. Sometimes these defaults can catch new users off guard or make learning/debugging difficult if they are unknown by the user. Keep them in mind as you continue to learn and use TanStack Query:\n\nQuery instances via useQuery or useInfiniteQuery by default consider cached data as stale.\n\nTo change this behavior, you can configure your queries both globally and per-query using the staleTime option. Specifying a longer staleTime means queries will not refetch their data as often\n\nStale queries are refetched automatically in the background when:\nNew instances of the query mount\nThe window is refocused\nThe network is reconnected\nThe query is optionally configured with a refetch interval\n\nTo change this functionality, you can use options like refetchOnMount, refetchOnWindowFocus, refetchOnReconnect and refetchInterval.\n\nQuery results that have no more active instances of useQuery, useInfiniteQuery or query observers are labeled as \"inactive\" and remain in the cache in case they are used again at a later time.\n\nBy default, \"inactive\" queries are garbage collected after 5 minutes.\n\nTo change this, you can alter the default gcTime for queries to something other than 1000 * 60 * 5 milliseconds.\n\nQueries that fail are silently retried 3 times, with exponential backoff delay before capturing and displaying an error to the UI.\n\nTo change this, you can alter the default retry and retryDelay options for queries to something other than 3 and the default exponential backoff function.\n\nQuery results by default are structurally shared to detect if data has actually changed and if not, the data reference remains unchanged to better help with value stabilization with regards to useMemo and useCallback. If this concept sounds foreign, then don't worry about it! 99.9% of the time you will not need to disable this and it makes your app more performant at zero cost to you.\n\nStructural sharing only works with JSON-compatible values, any other value types will always be considered as changed. If you are seeing performance issues because of large responses for example, you can disable this feature with the config.structuralSharing flag. If you are dealing with non-JSON compatible values in your query responses and still want to detect if data has changed or not, you can provide your own custom function as config.structuralSharing to compute a value from the old and new responses, retaining references as required.\n"
  },
  {
    "title": "GraphQL | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/graphql",
    "html": "GraphQL\n\nBecause Vue Query's fetching mechanisms are agnostically built on Promises, you can use Vue Query with literally any asynchronous data fetching client, including GraphQL!\n\nKeep in mind that Vue Query does not support normalized caching. While a vast majority of users do not actually need a normalized cache or even benefit from it as much as they believe they do, there may be very rare circumstances that may warrant it so be sure to check with us first to make sure it's truly something you need!\n"
  },
  {
    "title": "TypeScript | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/typescript",
    "html": "TypeScript\n\nVue Query is now written in TypeScript to make sure the library and your projects are type-safe!\n\nThings to keep in mind:\n\nTypes currently require using TypeScript v4.7 or greater\nChanges to types in this repository are considered non-breaking and are usually released as patch semver changes (otherwise every type enhancement would be a major version!).\nIt is highly recommended that you lock your vue-query package version to a specific patch release and upgrade with the expectation that types may be fixed or upgraded between any release\nThe non-type-related public API of Vue Query still follows semver very strictly.\nType Inference\n\nTypes in Vue Query generally flow through very well so that you don't have to provide type annotations for yourself\n\ntsx\nconst { data } = useQuery({\n  //    ^? const data: Ref<number> | Ref<undefined>\n  queryKey: ['test'],\n  queryFn: () => Promise.resolve(5),\n})\n\ntypescript playground\n\ntsx\nconst { data } = useQuery({\n  //      ^? const data: Ref<string> | Ref<undefined>\n  queryKey: ['test'],\n  queryFn: () => Promise.resolve(5),\n  select: (data) => data.toString(),\n})\n\ntypescript playground\n\nThis works best if your queryFn has a well-defined returned type. Keep in mind that most data fetching libraries return any per default, so make sure to extract it to a properly typed function:\n\ntsx\nconst fetchGroups = (): Promise<Group[]> =>\n  axios.get('/groups').then((response) => response.data)\n\n\nconst { data } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })\n//      ^? const data: Ref<Group[]> | Ref<undefined>\n\ntypescript playground\n\nType Narrowing\n\nVue Query uses a discriminated union type for the query result, discriminated by the status field and the derived status boolean flags. This will allow you to check for e.g. success status to make data defined:\n\ntsx\nconst { data, isSuccess } = reactive(\n  useQuery({\n    queryKey: ['test'],\n    queryFn: () => Promise.resolve(5),\n  }),\n)\n\n\nif (isSuccess) {\n  data\n  // ^? const data: number\n}\n\ntypescript playground\n\nTyping the error field\n\nThe type for error defaults to Error, because that is what most users expect.\n\ntsx\nconst { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })\n//      ^? const error: Error\n\ntypescript playground\n\ntsx\nconst { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })\n//      ^? const error: Ref<unknown>\n\n\nif (error.value instanceof Error) {\n  error.value\n  //     ^? const error: Error\n}\n\ntypescript playground\n\ntsx\nconst { error } = useQuery<Group[], string>(['groups'], fetchGroups)\n//      ^? const error: string | null\ntsx\nimport axios from 'axios'\n\n\nconst { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })\n//      ^? const error: Error | null\n\n\nif (axios.isAxiosError(error)) {\n  error\n  // ^? const error: AxiosError\n}\n\ntypescript playground\n\ntsx\nimport '@tanstack/react-query';\n\n\ndeclare module '@tanstack/react-query' {\n  interface Register {\n    defaultError: AxiosError\n  }\n}\n\n\nconst { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })\n//      ^? const error: AxiosError | null\nTyping meta Registering global Meta\n\nSimilarly to registering a global error type you can also register a global Meta type. This ensures the optional meta field on queries and mutations stays consistent and is type-safe.\n\nts\nimport '@tanstack/react-query';\n\n\ndeclare module '@tanstack/react-query' {\n  interface Register {\n    queryMeta: MyMeta,\n    mutationMeta: MyMeta\n  }\n}\nTyping Query Options\n\nIf you inline query options into useQuery, you'll get automatic type inference. However, you might want to extract the query options into a separate function to share them between useQuery and e.g. prefetchQuery. In that case, you'd lose type inference. To get it back, you can use queryOptions helper:\n\nts\nimport { queryOptions } from '@tanstack/react-query'\n\n\nfunction groupOptions() {\n  return queryOptions({\n    queryKey: ['groups'],\n    queryFn: fetchGroups,\n    staleTime: 5 * 1000,\n  })\n}\n\n\nuseQuery(groupOptions())\nqueryClient.prefetchQuery(groupOptions())\n\nFurther, the queryKey returned from queryOptions knows about the queryFn associated with it, and we can leverage that type information to make functions like queryClient.getQueryData aware of those types as well:\n\nts\nfunction groupOptions() {\n  return queryOptions({\n    queryKey: ['groups'],\n    queryFn: fetchGroups,\n    staleTime: 5 * 1000,\n  })\n}\n\n\nconst data = queryClient.getQueryData(groupOptions().queryKey)\n//     ^? const data: Group[] | undefined\n\nWithout queryOptions, the type of data would be unknown, unless we'd pass a generic to it:\n\nts\nconst data = queryClient.getQueryData<Group[]>(['groups'])\nFurther Reading\n\nFor tips and tricks around type inference, have a look at Vue Query and TypeScript from the Community Resources. To find out how to get the best possible type-safety, you can read Type-safe Vue Query.\n"
  },
  {
    "title": "Devtools | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/devtools",
    "html": "Devtools\n\nWave your hands in the air and shout hooray because Vue Query comes with dedicated devtools! ðŸ¥³\n\nWhen you begin your Vue Query journey, you'll want these devtools by your side. They help visualize all of the inner workings of Vue Query and will likely save you hours of debugging if you find yourself in a pinch!\n\nThe only thing you need to do is to install the official Vue Devtools.\n\nVue Query will seamlessly integrate with the official devtools, adding custom inspector and timeline events. Devtool code will be treeshaken from production bundles by default.\n\nComponent based Devtools (Vue 3)\n\nYou can embeed devtools component into your page by using dedicated package.\nComponent based devtools are using the same framework-agnostic implementation, have more features and are updated more frequently.\n\nThe devtools component is a separate package that you need to install:\n\nbash\n$ npm i @tanstack/vue-query-devtools\n# or\n$ pnpm add @tanstack/vue-query-devtools\n# or\n$ yarn add @tanstack/vue-query-devtools\n\nBy default, Vue Query Devtools are only included in bundles when process.env.NODE_ENV === 'development', so you don't need to worry about excluding them during a production build.\n\nDevtools will be mounted as a fixed, floating element in your app and provide a toggle in the corner of the screen to show and hide the devtools. This toggle state will be stored and remembered in localStorage across reloads.\n\nPlace the following code as high in your Vue app as you can. The closer it is to the root of the page, the better it will work!\n\nvue\n<script setup>\nimport { VueQueryDevtools } from '@tanstack/vue-query-devtools'\n</script>\n\n\n<template>\n  <h1>The app!</h1>\n  <VueQueryDevtools />\n</template>\nOptions\ninitialIsOpen: Boolean\nSet this true if you want the dev tools to default to being open\nbuttonPosition?: \"top-left\" | \"top-right\" | \"bottom-left\" | \"bottom-right\"\nDefaults to bottom-left\nThe position of the React Query logo to open and close the devtools panel\nposition?: \"top\" | \"bottom\" | \"left\" | \"right\"\nDefaults to bottom\nThe position of the React Query devtools panel\nclient?: QueryClient,\nUse this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.\nerrorTypes?: { name: string; initializer: (query: Query) => TError}\nUse this to predefine some errors that can be triggered on your queries. Initializer will be called (with the specific query) when that error is toggled on from the UI. It must return an Error.\nstyleNonce?: string\nUse this to pass a nonce to the style tag that is added to the document head. This is useful if you are using a Content Security Policy (CSP) nonce to allow inline styles."
  },
  {
    "title": "Quick Start | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/quick-start",
    "html": "Quick Start\n\nThis code snippet very briefly illustrates the 3 core concepts of Vue Query:\n\nQueries\nMutations\nQuery Invalidation\n\nIf you're looking for a fully functioning example, please have a look at our basic codesandbox example\n\nvue\n<script setup>\nimport { useQueryClient, useQuery, useMutation } from '@tanstack/vue-query'\n\n\n// Access QueryClient instance\nconst queryClient = useQueryClient()\n\n\n// Query\nconst { isPending, isError, data, error } = useQuery({\n  queryKey: ['todos'],\n  queryFn: getTodos,\n})\n\n\n// Mutation\nconst mutation = useMutation({\n  mutationFn: postTodo,\n  onSuccess: () => {\n    // Invalidate and refetch\n    queryClient.invalidateQueries({ queryKey: ['todos'] })\n  },\n})\n\n\nfunction onButtonClick() {\n  mutation.mutate({\n    id: Date.now(),\n    title: 'Do Laundry',\n  })\n}\n</script>\n\n\n<template>\n  <span v-if=\"isPending\">Loading...</span>\n  <span v-else-if=\"isError\">Error: {{ error.message }}</span>\n  <!-- We can assume by this point that `isSuccess === true` -->\n  <ul v-else>\n    <li v-for=\"todo in data\" :key=\"todo.id\">{{ todo.title }}</li>\n  </ul>\n  <button @click=\"onButtonClick\">Add Todo</button>\n</template>\n\nThese three concepts make up most of the core functionality of Vue Query. The next sections of the documentation will go over each of these core concepts in great detail.\n"
  },
  {
    "title": "Installation | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/installation",
    "html": "Installation\n\nYou can install Vue Query via NPM.\n\nv5 is currently available as a release-candidate. We don't anticipate any major API changes from here on out. We encourage you to try it out and report any issues you find.\n\nNPM\nbash\n$ npm i @tanstack/vue-query\n# or\n$ pnpm add @tanstack/vue-query\n# or\n$ yarn add @tanstack/vue-query\n\nWanna give it a spin before you download? Try out the basic example!\n\nVue Query is compatible with Vue 2.x and 3.x\n\nIf you are using Vue 2.6, make sure to also setup @vue/composition-api\n\nVue Query Initialization\n\nBefore using Vue Query, you need to initialize it using VueQueryPlugin\n\ntsx\nimport { VueQueryPlugin } from \"@tanstack/vue-query\";\n\n\napp.use(VueQueryPlugin)\nUse of Composition API with <script setup>\n\nAll examples in our documentation use <script setup> syntax.\n\nVue 2 users can also use that syntax using this plugin. Please check the plugin documentation for installation details.\n\nIf you are not a fan of <script setup> syntax, you can easily translate all the examples into normal Composition API syntax by moving the code under setup() function and returning the values used in the template.\n\nvue\n<script setup>\nimport { useQuery } from \"@tanstack/vue-query\";\n\n\nconst { isPending, isFetching, isError, data, error } = useQuery({\n  queryKey: ['todos'],\n  queryFn: getTodos,\n})\n</script>\n\n\n<template>...</template>"
  },
  {
    "title": "Overview | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/vue/overview",
    "html": "Overview\n\nTanStack Query (FKA Vue Query) is often described as the missing data-fetching library for web applications, but in more technical terms, it makes fetching, caching, synchronizing and updating server state in your web applications a breeze.\n\nMotivation\n\nMost core web frameworks do not come with an opinionated way of fetching or updating data in a holistic way. Because of this developers end up building either meta-frameworks which encapsulate strict opinions about data-fetching, or they invent their own ways of fetching data. This usually means cobbling together component-based state and side-effects, or using more general purpose state management libraries to store and provide asynchronous data throughout their apps.\n\nWhile most traditional state management libraries are great for working with client state, they are not so great at working with async or server state. This is because server state is totally different. For starters, server state:\n\nIs persisted remotely in a location you do not control or own\nRequires asynchronous APIs for fetching and updating\nImplies shared ownership and can be changed by other people without your knowledge\nCan potentially become \"out of date\" in your applications if you're not careful\n\nOnce you grasp the nature of server state in your application, even more challenges will arise as you go, for example:\n\nCaching... (possibly the hardest thing to do in programming)\nDeduping multiple requests for the same data into a single request\nUpdating \"out of date\" data in the background\nKnowing when data is \"out of date\"\nReflecting updates to data as quickly as possible\nPerformance optimizations like pagination and lazy loading data\nManaging memory and garbage collection of server state\nMemoizing query results with structural sharing\n\nIf you're not overwhelmed by that list, then that must mean that you've probably solved all of your server state problems already and deserve an award. However, if you are like a vast majority of people, you either have yet to tackle all or most of these challenges and we're only scratching the surface!\n\nVue Query is hands down one of the best libraries for managing server state. It works amazingly well out-of-the-box, with zero-config, and can be customized to your liking as your application grows.\n\nVue Query allows you to defeat and overcome the tricky challenges and hurdles of server state and control your app data before it starts to control you.\n\nOn a more technical note, Vue Query will likely:\n\nHelp you remove many lines of complicated and misunderstood code from your application and replace with just a handful of lines of Vue Query logic.\nMake your application more maintainable and easier to build new features without worrying about wiring up new server state data sources\nHave a direct impact on your end-users by making your application feel faster and more responsive than ever before.\nPotentially help you save on bandwidth and increase memory performance\nYou talked me into it, so what now?\nLearn Vue Query at your own pace with our amazingly thorough Walkthrough Guide and API Reference"
  }
]
