[
  {
    "title": "Vercel KV ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/drivers/vercel-kv",
    "html": "Vercel KV\n\nStore data in a Vercel KV Store.\n\nVercel KV driver is in beta. Please check Vercel KV Limits and unjs/unstorage#218 for known issues and possible workarounds.\nimport { createStorage } from \"unstorage\";\n\nimport vercelKVDriver from \"unstorage/drivers/vercel-kv\";\n\n\n\nconst storage = createStorage({\n\n  driver: vercelKVDriver({\n\n    // url: \"https://<your-project-slug>.kv.vercel-storage.com\", // KV_REST_API_URL\n\n    // token: \"<your secret token>\", // KV_REST_API_TOKEN\n\n    // base: \"test\",\n\n    // env: \"KV\",\n\n    // ttl: 60, // in seconds\n\n  }),\n\n});\n\nCopy to clipboard\n\nTo use, you will need to install @vercel/kv dependency in your project:\n\n{\n\n  \"dependencies\": {\n\n    \"@vercel/kv\": \"latest\"\n\n  }\n\n}\n\nCopy to clipboard\n\nNote: For driver options type support, you might need to install @upstash/redis dev dependency as well.\n\nOptions:\n\nurl: Rest API URL to use for connecting to your Vercel KV store. Default is KV_REST_API_URL.\ntoken: Rest API Token to use for connecting to your Vercel KV store. Default is KV_REST_API_TOKEN.\nbase: optional Prefix to use for all keys. Can be used for namespacing.\nenv: optional Flag to customzize environment variable prefix (Default is KV). Set to false to disable env inference for url and token options.\n\nSee @upstash/redis for all available options."
  },
  {
    "title": "Session Storage ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/drivers/session-storage",
    "html": "Session Storage\n\nStore data in sessionStorage.\n\nimport { createStorage } from \"unstorage\";\n\nimport sessionStorageDriver from \"unstorage/drivers/session-storage\";\n\n\n\nconst storage = createStorage({\n\n  driver: sessionStorageDriver({ base: \"app:\" }),\n\n});\n\nCopy to clipboard\n\nOptions:\n\nbase: Add ${base}: to all keys to avoid collision\nsessionStorage: Optionally provide sessionStorage object\nwindow: Optionally provide window object"
  },
  {
    "title": "PlanetScale ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/drivers/planetscale",
    "html": "PlanetScale\n\nStores data in PlanetScale\n\nThis driver stores KV information in a Planetscale DB with columns of id, value, created_at and updated_at.\n\nTo use, you will need to install @planetscale/database in your project:\n\n{\n\n  \"dependencies\": {\n\n    \"@planetscale/database\": \"^1.5.0\"\n\n  }\n\n}\n\nCopy to clipboard\n\nThen you can create a table to store your data by running the following query in your Planetscale database, where is the name of the table you want to use:\n\ncreate table <storage> (\n id varchar(255) not null primary key,\n value longtext,\n created_at timestamp default current_timestamp,\n updated_at timestamp default current_timestamp on update current_timestamp\n);\n\nCopy to clipboard\n\nYou can then configure the driver like this:\n\nimport { createStorage } from \"unstorage\";\n\nimport planetscaleDriver from \"unstorage/drivers/planetscale\";\n\n\n\nconst storage = createStorage({\n\n  driver: planetscaleDriver({\n\n    // This should certainly not be inlined in your code but loaded via runtime config\n\n    // or environment variables depending on your framework/project.\n\n    url: \"mysql://xxxxxxxxx:************@xxxxxxxxxx.us-east-3.psdb.cloud/my-database?sslaccept=strict\",\n\n    // table: 'storage'\n\n  }),\n\n});\n\nCopy to clipboard\n\nOptions:\n\nurl (required): You can find your URL in the Planetscale dashboard.\nstorage: The name of the table to read from. It defaults to storage.\nboostCache: Whether to enable cached queries: see docs."
  },
  {
    "title": "Redis ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/drivers/redis",
    "html": "Redis\n\nStore data in a Redis storage using ioredis.\n\nUsage with single Redis instance:\n\nimport { createStorage } from \"unstorage\";\n\nimport redisDriver from \"unstorage/drivers/redis\";\n\n\n\nconst storage = createStorage({\n\n  driver: redisDriver({\n\n    base: \"unstorage\",\n\n    host: 'HOSTNAME',\n\n    tls: true as any,\n\n    port: 6380,\n\n    password: 'REDIS_PASSWORD'\n\n  }),\n\n});\n\nCopy to clipboard\n\nUsage with Redis cluster (e.g. AWS ElastiCache or Azure Redis Cache):\n\n‚ö†Ô∏è If you connect to a cluster, you have to use hastags as prefix to avoid the redis error CROSSSLOT Keys in request don't hash to the same slot. This means, the prefix has to be surrounded by curly braces, which forces the keys into the same hash slot.\n\nconst storage = createStorage({\n\n  driver: redisDriver({\n\n    base: \"{unstorage}\",\n\n    cluster: [\n\n      {\n\n        port: 6380,\n\n        host: \"HOSTNAME\",\n\n      },\n\n    ],\n\n    clusterOptions: {\n\n      redisOptions: {\n\n        tls: { servername: \"HOSTNAME\" },\n\n        password: \"REDIS_PASSWORD\",\n\n      },\n\n    },\n\n  }),\n\n});\n\nCopy to clipboard\n\nOptions:\n\nbase: Optional prefix to use for all keys. Can be used for namespacing. Has to be used as hastag prefix for redis cluster mode.\nurl: Url to use for connecting to redis. Takes precedence over host option. Has the format redis://<REDIS_USER>:<REDIS_PASSWORD>@<REDIS_HOST>:<REDIS_PORT>\ncluster: List of redis nodes to use for cluster mode. Takes precedence over url and host options.\nclusterOptions: Options to use for cluster mode.\nttl: Default TTL for all items in seconds.\n\nSee ioredis for all available options.\n\nlazyConnect option is enabled by default so that connection happens on first redis operation.\n\nTransaction options:\n\nttl: Supported for setItem(key, value, { ttl: number /* seconds */ })"
  },
  {
    "title": "Overlay ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/drivers/overlay",
    "html": "Overlay\n\nThis is a special driver that creates a multi-layer overlay driver.\n\nAll write operations happen on the top level layer while values are read from all layers.\n\nWhen removing a key, a special value __OVERLAY_REMOVED__ will be set on the top level layer internally.\n\nIn the example below, we create an in-memory overlay on top of fs. No changes will be actually written to the disk when setting new keys.\n\nimport { createStorage } from \"unstorage\";\n\nimport overlay from \"unstorage/drivers/overlay\";\n\nimport memory from \"unstorage/drivers/memory\";\n\nimport fs from \"unstorage/drivers/fs\";\n\n\n\nconst storage = createStorage({\n\n  driver: overlay({\n\n    layers: [memory(), fs({ base: \"./data\" })],\n\n  }),\n\n});\n\nCopy to clipboard"
  },
  {
    "title": "Netlify Blobs ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/drivers/netlify-blobs",
    "html": "Netlify Blobs\n\nStore data in a Netlify Blobs store. This is supported in both edge and Node.js runtimes, as well at during builds.\n\nNetlify Blobs are in beta.\nimport { createStorage } from \"unstorage\";\n\nimport netlifyBlobsDriver from \"unstorage/drivers/netlify-blobs\";\n\n\n\nconst storage = createStorage({\n\n  driver: netlifyBlobsDriver({\n\n    name: \"blob-store-name\",\n\n  }),\n\n});\n\nCopy to clipboard\n\nYou can create a deploy-scoped store by settings deployScoped option to true. This will mean that the deploy only has access to its own store. The store is managed alongside the deploy, with the same deploy previews, deletes, and rollbacks.\n\nimport { createStorage } from \"unstorage\";\n\nimport netlifyBlobsDriver from \"unstorage/drivers/netlify-blobs\";\n\n\n\nconst storage = createStorage({\n\n  driver: netlifyBlobsDriver({\n\n    deployScoped: true,\n\n  }),\n\n});\n\nCopy to clipboard\n\nTo use, you will need to install @netlify/blobs as dependency or devDependency in your project:\n\n{\n\n  \"devDependencies\": {\n\n    \"@netlify/blobs\": \"*\"\n\n  }\n\n}\n\nCopy to clipboard\n\nOptions:\n\nname - The name of the store to use. It is created if needed. This is required except for deploy-scoped stores.\ndeployScoped - If set to true, the store is scoped to the deploy. This means that it is only available from that deploy, and will be deleted or rolled-back alongside it.\nsiteID - Required during builds, where it is available as constants.SITE_ID. At runtime this is set automatically.\ntoken - Required during builds, where it is available as constants.NETLIFY_API_TOKEN. At runtime this is set automatically.\n\nAdvanced options:\n\nThese are not normally needed, but are available for advanced use cases or for use in unit tests.\n\napiURL\nedgeURL"
  },
  {
    "title": "MongoDB ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/drivers/mongodb",
    "html": "MongoDB\n\nStore data in MongoDB using Node.js mongodb package\n\nThis driver stores KV information in a MongoDB collection with a separate document for each key value pair.\n\nTo use it, you will need to install mongodb in your project:\n\nnpm i mongodb\n\nCopy to clipboard\n\nUsage:\n\nimport { createStorage } from \"unstorage\";\n\nimport mongodbDriver from \"unstorage/drivers/mongodb\";\n\n\n\nconst storage = createStorage({\n\n  driver: mongodbDriver({\n\n    connectionString: \"CONNECTION_STRING\",\n\n    databaseName: \"test\",\n\n    collectionName: \"test\",\n\n  }),\n\n});\n\nCopy to clipboard\n\nAuthentication:\n\nThe driver supports the following authentication methods:\n\nconnectionString: The MongoDB connection string. This is the only way to authenticate.\n\nOptions:\n\nconnectionString (required): The connection string to use to connect to the MongoDB database. It should be in the format mongodb://<username>:<password>@<host>:<port>/<database>.\ndatabaseName: The name of the database to use. Defaults to unstorage.\ncollectionName: The name of the collection to use. Defaults to unstorage."
  },
  {
    "title": "Memory ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/drivers/memory",
    "html": "Memory\n\nKeeps data in memory using Map.\n\nBy default it is mounted to top level so it is unlikely you need to mount it again.\n\nimport { createStorage } from \"unstorage\";\n\nimport memoryDriver from \"unstorage/drivers/memory\";\n\n\n\nconst storage = createStorage({\n\n  driver: memoryDriver(),\n\n});\n\nCopy to clipboard"
  },
  {
    "title": "LRU Cache ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/drivers/lru-cache",
    "html": "LRU Cache\n\nKeeps cached data in memory using LRU Cache.\n\nSee lru-cache for supported options.\n\nBy default max setting is set to 1000 items.\n\nA default behavior for sizeCalculation option is implemented based on buffer size of both key and value.\n\nimport { createStorage } from \"unstorage\";\n\nimport lruCacheDriver from \"unstorage/drivers/lru-cache\";\n\n\n\nconst storage = createStorage({\n\n  driver: lruCacheDriver(),\n\n});\n\nCopy to clipboard"
  },
  {
    "title": "Local Storage ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/drivers/localstorage",
    "html": "Local Storage\n\nStore data in localStorage.\n\nimport { createStorage } from \"unstorage\";\n\nimport localStorageDriver from \"unstorage/drivers/localstorage\";\n\n\n\nconst storage = createStorage({\n\n  driver: localStorageDriver({ base: \"app:\" }),\n\n});\n\nCopy to clipboard\n\nOptions:\n\nbase: Add ${base}: to all keys to avoid collision\nlocalStorage: Optionally provide localStorage object\nwindow: Optionally provide window object"
  },
  {
    "title": "IndexedDB ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/drivers/indexedb",
    "html": "IndexedDB\n\nStore data in IndexedDB using idb-keyval.\n\nTo use it, you will need to install idb-keyval in your project:\n\nnpm i idb-keyval\n\nCopy to clipboard\n\nUsage:\n\nimport { createStorage } from \"unstorage\";\n\nimport indexedDbDriver from \"unstorage/drivers/indexedb\";\n\n\n\nconst storage = createStorage({\n\n  driver: indexedDbDriver({ base: \"app:\" }),\n\n});\n\nCopy to clipboard\n\nOptions:\n\nbase: Add ${base}: to all keys to avoid collision\ndbName: Custom name for database. Defaults to keyval-store\nstoreName: Custom name for store. Defaults to keyval\nIndexedDB is a browser database. avoid using this preset on server environments."
  },
  {
    "title": "GitHub ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/drivers/github",
    "html": "GitHub\n\nMap files from a remote github repository (readonly).\n\nThis driver fetches all possible keys once and keep it in cache for 10 minutes. Due to GitHub rate limit, it is highly recommanded to provide a token. It only applies to fetching keys.\n\nimport { createStorage } from \"unstorage\";\n\nimport githubDriver from \"unstorage/drivers/github\";\n\n\n\nconst storage = createStorage({\n\n  driver: githubDriver({\n\n    repo: \"nuxt/nuxt\",\n\n    branch: \"main\",\n\n    dir: \"/docs\",\n\n  }),\n\n});\n\nCopy to clipboard\n\nOptions:\n\nrepo: Github repository. Format is username/repo or org/repo (required)\ntoken: Github API token. (recommended)\nbranch: Target branch. Default is main\ndir: Use a directory as driver root.\nttl: Filenames cache revalidate time. Default is 600 seconds (10 minutes)\napiURL: Github API domain. Default is https://api.github.com\ncdnURL: Github RAW CDN Url. Default is https://raw.githubusercontent.com"
  },
  {
    "title": "HTTP ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/drivers/http",
    "html": "HTTP\n\nUse a remote HTTP/HTTPS endpoint as data storage. Supports built-in http server methods.\n\nThis driver implements meta for each key including mtime (last modified time) and status from HTTP headers by making a HEAD request.\n\nimport { createStorage } from \"unstorage\";\n\nimport httpDriver from \"unstorage/drivers/http\";\n\n\n\nconst storage = createStorage({\n\n  driver: httpDriver({ base: \"http://cdn.com\" }),\n\n});\n\nCopy to clipboard\n\nOptions:\n\nbase: Base URL for urls (required)\nheaders: Custom headers to send on all requests\n\nSupported HTTP Methods:\n\ngetItem: Maps to http GET. Returns deserialized value if response is ok\nhasItem: Maps to http HEAD. Returns true if response is ok (200)\nsetItem: Maps to http PUT. Sends serialized value using body\nremoveItem: Maps to DELETE\nclear: Not supported\n\nTransaction Options:\n\nheaders: Custom headers to be sent on each operation (getItem, setItem, etc)"
  },
  {
    "title": "CloudFlare R2 (binding) ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/drivers/cloudflare-r2-binding",
    "html": "CloudFlare R2 (binding)\nThis is an experimental driver! This driver only works in a cloudflare worker environment and cannot be used in other runtime environments such as Node.js (r2-http driver is coming soon)\n\nStore data in Cloudflare R2 buckets and access from worker bindings.\n\nYou need to create and assign a R2 bucket. See R2 Bindings for more information.\n\nimport { createStorage } from \"unstorage\";\n\nimport cloudflareR2BindingDriver from \"unstorage/drivers/cloudflare-r2-binding\";\n\n\n\n// Using binding name to be picked from globalThis\n\nconst storage = createStorage({\n\n  driver: cloudflareR2BindingDriver({ binding: \"MY_BUCKET\" }),\n\n});\n\n\n\n// Directly setting binding\n\nconst storage = createStorage({\n\n  driver: cloudflareR2BindingDriver({ binding: globalThis.MY_BUCKET }),\n\n});\n\nCopy to clipboard\n\nOptions:\n\nbinding: Bucket binding or name.\nbase: Prefix all keys with base."
  },
  {
    "title": "Node.js Filesystem ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/drivers/fs",
    "html": "Node.js Filesystem\n\nMaps data to the real filesystem using directory structure for nested keys. Supports watching using chokidar.\n\nThis driver implements meta for each key including mtime (last modified time), atime (last access time), and size (file size) using fs.stat.\n\nimport { createStorage } from \"unstorage\";\n\nimport fsDriver from \"unstorage/drivers/fs\";\n\n\n\nconst storage = createStorage({\n\n  driver: fsDriver({ base: \"./tmp\" }),\n\n});\n\nCopy to clipboard\n\nOptions:\n\nbase: Base directory to isolate operations on this directory\nignore: Ignore patterns for watch\nwatchOptions: Additional chokidar options.\nNode.js Filesystem (Lite)\n\nThis driver uses pure Node.js API without extra dependencies.\n\nimport { createStorage } from \"unstorage\";\n\nimport fsLiteDriver from \"unstorage/drivers/fs-lite\";\n\n\n\nconst storage = createStorage({\n\n  driver: fsLiteDriver({ base: \"./tmp\" }),\n\n});\n\nCopy to clipboard\n\nOptions:\n\nbase: Base directory to isolate operations on this directory\nignore: Optional callback function (path: string) => boolean"
  },
  {
    "title": "CloudFlare KV (binding) ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/drivers/cloudflare-kv-binding",
    "html": "CloudFlare KV (binding)\n\nStore data in Cloudflare KV and access from worker bindings.\n\nNote: This driver only works in a cloudflare worker environment, use cloudflare-kv-http for other environments.\n\nYou need to create and assign a KV. See KV Bindings for more information.\n\nimport { createStorage } from \"unstorage\";\n\nimport cloudflareKVBindingDriver from \"unstorage/drivers/cloudflare-kv-binding\";\n\n\n\n// Using binding name to be picked from globalThis\n\nconst storage = createStorage({\n\n  driver: cloudflareKVBindingDriver({ binding: \"STORAGE\" }),\n\n});\n\n\n\n// Directly setting binding\n\nconst storage = createStorage({\n\n  driver: cloudflareKVBindingDriver({ binding: globalThis.STORAGE }),\n\n});\n\n\n\n// Using from Durable Objects and Workers using Modules Syntax\n\nconst storage = createStorage({\n\n  driver: cloudflareKVBindingDriver({ binding: this.env.STORAGE }),\n\n});\n\n\n\n// Using outside of Cloudflare Workers (like Node.js)\n\n// Use cloudflare-kv-http\n\nCopy to clipboard\n\nOptions:\n\nbinding: KV binding or name of namespace. Default is STORAGE.\nbase: Adds prefix to all stored keys"
  },
  {
    "title": "Cloudflare KV (http) ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/drivers/cloudflare-kv-http",
    "html": "Cloudflare KV (http)\n\nStore data in Cloudflare KV using the Cloudflare API v4.\n\nYou need to create a KV namespace. See KV Bindings for more information.\n\nNote: This driver uses native fetch and works universally! For using directly in a cloudflare worker environment, please use cloudflare-kv-binding driver for best performance!\n\nimport { createStorage } from \"unstorage\";\n\nimport cloudflareKVHTTPDriver from \"unstorage/drivers/cloudflare-kv-http\";\n\n\n\n// Using `apiToken`\n\nconst storage = createStorage({\n\n  driver: cloudflareKVHTTPDriver({\n\n    accountId: \"my-account-id\",\n\n    namespaceId: \"my-kv-namespace-id\",\n\n    apiToken: \"supersecret-api-token\",\n\n  }),\n\n});\n\n\n\n// Using `email` and `apiKey`\n\nconst storage = createStorage({\n\n  driver: cloudflareKVHTTPDriver({\n\n    accountId: \"my-account-id\",\n\n    namespaceId: \"my-kv-namespace-id\",\n\n    email: \"me@example.com\",\n\n    apiKey: \"my-api-key\",\n\n  }),\n\n});\n\n\n\n// Using `userServiceKey`\n\nconst storage = createStorage({\n\n  driver: cloudflareKVHTTPDriver({\n\n    accountId: \"my-account-id\",\n\n    namespaceId: \"my-kv-namespace-id\",\n\n    userServiceKey: \"v1.0-my-service-key\",\n\n  }),\n\n});\n\nCopy to clipboard\n\nOptions:\n\naccountId: Cloudflare account ID.\nnamespaceId: The ID of the KV namespace to target. Note: be sure to use the namespace's ID, and not the name or binding used in a worker environment.\napiToken: API Token generated from the User Profile 'API Tokens' page.\nemail: Email address associated with your account. May be used along with apiKey to authenticate in place of apiToken.\napiKey: API key generated on the \"My Account\" page of the Cloudflare console. May be used along with email to authenticate in place of apiToken.\nuserServiceKey: A special Cloudflare API key good for a restricted set of endpoints. Always begins with \"v1.0-\", may vary in length. May be used to authenticate in place of apiToken or apiKey and email.\napiURL: Custom API URL. Default is https://api.cloudflare.com.\nbase: Adds prefix to all stored keys\n\nSupported methods:\n\ngetItem: Maps to Read key-value pair GET accounts/:account_identifier/storage/kv/namespaces/:namespace_identifier/values/:key_name\nhasItem: Maps to Read key-value pair GET accounts/:account_identifier/storage/kv/namespaces/:namespace_identifier/values/:key_name. Returns true if <parsed response body>.success is true.\nsetItem: Maps to Write key-value pair PUT accounts/:account_identifier/storage/kv/namespaces/:namespace_identifier/values/:key_name\nremoveItem: Maps to Delete key-value pair DELETE accounts/:account_identifier/storage/kv/namespaces/:namespace_identifier/values/:key_name\ngetKeys: Maps to List a Namespace's Keys GET accounts/:account_identifier/storage/kv/namespaces/:namespace_identifier/keys\nclear: Maps to Delete key-value pair DELETE accounts/:account_identifier/storage/kv/namespaces/:namespace_identifier/bulk"
  },
  {
    "title": "Capacitor Preferences ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/drivers/capacitor-preferences",
    "html": "Capacitor Preferences\n\nStores data via Capacitor Preferences API on mobile devices or the local storage on the web.\n\nTo use this driver, you need to install and sync @capacitor/preferences inside your capacitor project:\n\nnpm\nYarn\npnpm\nnpm install @capacitor/preferences\n\nnpx cap sync\n\nCopy to clipboard\n\nUsage:\n\nimport { createStorage } from \"unstorage\";\n\nimport capacitorPreferences from \"unstorage/drivers/capacitor-preferences\";\n\n\n\nconst storage = createStorage({\n\n  driver: capacitorPreferences({\n\n    base: \"test\",\n\n  }),\n\n});\n\nCopy to clipboard\n\nOptions:\n\nbase: Add ${base}: to all keys to avoid collision"
  },
  {
    "title": "Azure Table Storage ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/drivers/azure-storage-table",
    "html": "Azure Table Storage\n\n‚ö†Ô∏è This driver is currently not compatible with edge workers like Cloudflare Workers or Vercel Edge Functions. There may be a http based driver in the future.\n\nStore data in a Azure table storage data-tables.\n\nThis driver stores KV information in a Azure table storage. The same partition key is used for all keys and the field unstorageValue is used to store the value.\n\nTo use it, you will need to install @azure/data-table and @azure/identity in your project:\n\nnpm i @azure/data-table @azure/identity\n\nCopy to clipboard\n\nPlease make sure that the table you want to use exists in your storage account.\n\nimport { createStorage } from \"unstorage\";\n\nimport azureStorageTableDriver from \"unstorage/drivers/azure-storage-table\";\n\n\n\nconst storage = createStorage({\n\n  driver: azureStorageTableDriver({\n\n    accountName: \"myazurestorageaccount\",\n\n  }),\n\n});\n\nCopy to clipboard\n\nAuthentication:\n\nThe driver supports the following authentication methods:\n\nDefaultAzureCredential: This is the recommended way to authenticate. It will use managed identity or environment variables to authenticate the request. It will also work in a local environment by trying to use Azure CLI or Azure PowerShell to authenticate.\n‚ö†Ô∏è Make sure that your Managed Identity or personal account has the Storage Table Data Contributor role assigned to it, even if you already are Contributor or Owner on the storage account.\nAzureNamedKeyCredential (only available in Node.js runtime): This will use the accountName and accountKey to authenticate the request.\nAzureSASCredential: This will use the accountName and sasToken to authenticate the request.\nconnection string (only available in Node.js runtime): This will use the connectionString to authenticate the request. This is not recommended as it will expose your account key in plain text.\n\nOptions:\n\naccountName (required): The name of your storage account.\ntableName: The name of the table to use. Defaults to unstorage.\npartitionKey: The partition key to use. Defaults to unstorage.\naccountKey: The account key to use for authentication. This is only required if you are using AzureNamedKeyCredential."
  },
  {
    "title": "Azure Blob Storage ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/drivers/azure-storage-block",
    "html": "Azure Blob Storage\n\nStore data in a Azure blob storage storage-blob.\n\nThis driver stores KV information in a Azure blob storage blob. The same container is used for all entries. Each entry is stored in a separate blob with the key as the blob name and the value as the blob content.\n\nTo use it, you will need to install @azure/storage-blob and @azure/identity in your project:\n\nnpm i @azure/storage-blob @azure/identity\n\nCopy to clipboard\n\nPlease make sure that the container you want to use exists in your storage account.\n\nimport { createStorage } from \"unstorage\";\n\nimport azureStorageBlobDriver from \"unstorage/drivers/azure-storage-blob\";\n\n\n\nconst storage = createStorage({\n\n  driver: azureStorageBlobDriver({\n\n    accountName: \"myazurestorageaccount\",\n\n  }),\n\n});\n\nCopy to clipboard\n\nAuthentication:\n\nThe driver supports the following authentication methods:\n\nDefaultAzureCredential: This is the recommended way to authenticate. It will use managed identity or environment variables to authenticate the request. It will also work in a local environment by trying to use Azure CLI or Azure PowerShell to authenticate.\n‚ö†Ô∏è Make sure that your Managed Identity or personal account has the Storage Blob Data Contributor role assigned to it, even if you already are Contributor or Owner on the storage account.\nAzureNamedKeyCredential (only available in Node.js runtime): This will use the accountName and accountKey to authenticate the request.\nAzureSASCredential: This will use the accountName and sasToken to authenticate the request.\nconnection string (only available in Node.js runtime): This will use the connectionString to authenticate the request. This is not recommended as it will expose your account key in plain text.\n\nOptions:\n\naccountName (required): The name of your storage account.\ncontainerName: The name of the blob container to use. Defaults to unstorage.\naccountKey: The account key to use for authentication. This is only required if you are using AzureNamedKeyCredential.\nsasKey: The SAS token to use for authentication. This is only required if you are using AzureSASCredential.\nconnectionString: The storage accounts' connection string. accountKey and sasKey take precedence."
  },
  {
    "title": "Azure Key Vault ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/drivers/azure-key-vault",
    "html": "Azure Key Vault\n\nStore data in a Azure Key Vault secrets.\n\nThis driver stores KV information in Azure Key Vault secrets by using the key as secret id and the value as secret content. Please be aware that key vault secrets don't have the fastest access time and are not designed for high throughput. You also have to disable purge protection for your key vault to be able to delete secrets. This implementation deletes and purges a secret when it is deleted to avoid conflicts with soft delete.\n\n‚ö†Ô∏è Be aware that this driver stores the keys of your key:value pairs in an encoded way in Key Vault to avoid conflicts with naming requirements for secrets. This means that you will not be able to access manually (outside of unstorage) created secrets inside your Key Vault, as long as they are not encoded in the same way.\n\nTo use it, you will need to install @azure/keyvault-secrets and @azure/identity in your project:\n\nnpm i @azure/keyvault-secrets @azure/identity\n\nCopy to clipboard\n\nUsage:\n\nimport { createStorage } from \"unstorage\";\n\nimport azureKeyVault from \"unstorage/drivers/azure-key-vault\";\n\n\n\nconst storage = createStorage({\n\n  driver: azureKeyVault({\n\n    vaultName: \"testunstoragevault\",\n\n  }),\n\n});\n\nCopy to clipboard\n\nAuthentication:\n\nThe driver supports the following authentication methods:\n\nDefaultAzureCredential: This is the recommended way to authenticate. It will use managed identity or environment variables to authenticate the request. It will also work in a local environment by trying to use Azure CLI or Azure PowerShell to authenticate.\n\n‚ö†Ô∏è Make sure that your Managed Identity or personal account has either the Key Vault Secrets Officer (or Key Vault Secrets User for read-only) RBAC role assigned or is a member of an access policy that grants Get, List, Set, Delete and Purge secret permissions.\n\nOptions:\n\nvaultName (required): The name of the key vault to use.\nserviceVersion: Version of the Azure Key Vault service to use. Defaults to 7.3.\npageSize: The number of entries to retrieve per request. Impacts getKeys() and clear() performance. Maximum value is 25."
  },
  {
    "title": "Azure Cosmos DB ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/drivers/azure-cosmos",
    "html": "Azure Cosmos DB\n\nStore data in Azure Cosmos DB NoSQL API documents.\n\nThis driver stores KV information in a NoSQL API Cosmos DB collection as documents. It uses the id field as the key and adds value and modified fields to the document.\n\nTo use it, you will need to install @azure/cosmos and @azure/identity in your project:\n\nnpm i @azure/cosmos @azure/identity\n\nCopy to clipboard\n\nUsage:\n\nimport { createStorage } from \"unstorage\";\n\nimport azureCosmos from \"unstorage/drivers/azure-cosmos\";\n\n\n\nconst storage = createStorage({\n\n  driver: azureCosmos({\n\n    endpoint: \"ENDPOINT\",\n\n    accountKey: \"ACCOUNT_KEY\",\n\n  }),\n\n});\n\nCopy to clipboard\n\nAuthentication:\n\nDefaultAzureCredential: This is the recommended way to authenticate. It will use managed identity or environment variables to authenticate the request. It will also work in a local environment by trying to use Azure CLI or Azure PowerShell to authenticate.\n‚ö†Ô∏è Make sure that your Managed Identity or personal account has at least Cosmos DB Built-in Data Contributor role assigned to it. If you already are Contributor or Owner on the resource it should also be enough, but does not accomplish a model of least privilege.\naccountKey: CosmosDB account key. If not provided, the driver will use the DefaultAzureCredential (recommended).\n\nOptions:\n\nendpoint (required): CosmosDB endpoint in the format of https://<account>.documents.azure.com:443/.\naccountKey: CosmosDB account key. If not provided, the driver will use the DefaultAzureCredential (recommended).\ndatabaseName: The name of the database to use. Defaults to unstorage.\ncontainerName: The name of the container to use. Defaults to unstorage."
  },
  {
    "title": "Azure App Configuration ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/drivers/azure-app-configuration",
    "html": "Azure App Configuration\n\nStore data in the key value store of Azure App Configuration.\n\nThis driver uses the configuration store as a key value store. It uses the key as the name and the value as content. You can also use labels to differentiate between different environments (dev, prod, etc.) and use prefixes to differentiate between different applications (app01, app02, etc.).\n\nTo use it, you will need to install @azure/app-configuration and @azure/identity in your project:\n\nnpm i @azure/app-configuration @azure/identity\n\nCopy to clipboard\n\nUsage:\n\nimport { createStorage } from \"unstorage\";\n\nimport azureAppConfiguration from \"unstorage/drivers/azure-app-configuration\";\n\n\n\nconst storage = createStorage({\n\n  driver: azureAppConfiguration({\n\n    appConfigName: \"unstoragetest\",\n\n    label: \"dev\",\n\n    prefix: \"app01\",\n\n  }),\n\n});\n\nCopy to clipboard\n\nAuthentication:\n\nThe driver supports the following authentication methods:\n\nDefaultAzureCredential: This is the recommended way to authenticate. It will use managed identity or environment variables to authenticate the request. It will also work in a local environment by trying to use Azure CLI or Azure PowerShell to authenticate.\n‚ö†Ô∏è Make sure that your Managed Identity or personal account has the App Configuration Data Owner role assigned to it, even if you already are Contributor or Owner on the app configuration resource.\nconnectionString: The app configuration connection string. Not recommended for use in production.\n\nOptions:\n\nappConfigName: The name of the app configuration resource.\nendpoint: The endpoint of the app configuration resource.\nconnectionString: The connection string of the app configuration resource.\nprefix: Optional prefix for keys. This can be used to isolate keys from different applications in the same Azure App Configuration instance. E.g. \"app01\" results in keys like \"app01:foo\" and \"app01:bar\".\nlabel: Optional label for keys. If not provided, all keys will be created and listed without labels. This can be used to isolate keys from different environments in the same Azure App Configuration instance. E.g. \"dev\" results in keys like \"foo\" and \"bar\" with the label \"dev\"."
  },
  {
    "title": "Custom Driver ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/custom-driver",
    "html": "Custom Driver\n\nIt is possible to extend unstorage by creating a custom driver.\n\nExplore src/drivers to inspire how to implement them. Methods can\n\nimport { createStorage, defineDriver } from \"unstorage\";\n\n\n\nconst myStorageDriver = defineDriver((options) => {\n\n  return {\n\n    name: \"my-custom-driver\",\n\n    options,\n\n    async hasItem(key, _opts) {},\n\n    async getItem(key, _opts) {},\n\n    async setItem(key, value, _opts) {},\n\n    async removeItem(key, _opts) {},\n\n    async getKeys(base, _opts) {},\n\n    async clear(base, _opts) {},\n\n    async dispose() {},\n\n    async watch(callback) {},\n\n  };\n\n});\n\n\n\nconst storage = createStorage({\n\n  driver: myStorageDriver(),\n\n});\n\nCopy to clipboard\n\nSome important notes:\n\nKeys should be normalized following foo:bar convention\nRemove any open watcher and handlers in dispose()\nReturning a promise is optional, you can return a direct value (see memory driver)\nYou don't have acces to the mount base\nValue returned by getItem can be a serializable object or string\nWhen setting watch method, unstorage default handler will be disabled. You are responsible to emit event on getItem, setItem and removeItem. ::"
  },
  {
    "title": "HTTP Server ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/http-server",
    "html": "HTTP Server\n\nWe can expose unstorage instance to an http server to allow remote connections.\n\nRequest url is mapped to key and method/body mapped to function. See below for supported http methods.\n\nStorage Server\n\nProgrammatic usage of creating an HTTP server exposing methods to communicate with the storage instance:\n\nserver.js\nimport { listen } from \"listhen\";\n\nimport { createStorage } from \"unstorage\";\n\nimport { createStorageServer } from \"unstorage/server\";\n\n\n\nconst storage = createStorage();\n\nconst storageServer = createStorageServer(storage, {\n\n  authorize(req) {\n\n    // req: { key, type, event }\n\n    if (req.type === \"read\" && req.key.startsWith(\"private:\")) {\n\n      throw new Error(\"Unauthorized Read\");\n\n    }\n\n  },\n\n});\n\n\n\n// Alternatively we can use `storageServer.handle` as a middleware\n\nawait listen(storageServer.handle);\n\nCopy to clipboard\n\nThe storageServer is an h3 instance. Checkout also listhen for an elegant HTTP listener.\n\nüõ°Ô∏è Security Note: Make sure to always implement authorize in order to protect server when it is exposed to a production environemnt.\nStorage Client\n\nYou can use the http driver to easily connect to the server.\n\nimport { createStorage } from \"unstorage\";\n\nimport httpDriver from \"unstorage/drivers/http\";\n\n\n\nconst client = createStorage({\n\n  driver: httpDriver({\n\n    base: \"SERVER_ENDPOINT\",\n\n  }),\n\n});\n\nconst keys = await client.getKeys();\n\nCopy to clipboard\nHTTP Methods\nGET: Maps to storage.getItem or storage.getKeys when path ending with / or /:\nHEAD: Maps to storage.hasItem. Returns 404 if not found.\nPUT: Maps to storage.setItem. Value is read from body and returns OK if operation succeeded.\nDELETE: Maps to storage.removeItem or storage.clear when path ending with / or /:. Returns OK if operation succeeded.\nWhen passing accept: application/octet-stream for GET and SET operations, the server switches to binary mode via getItemRaw and setItemRaw."
  },
  {
    "title": "Usage ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/usage",
    "html": "Usage\n\nDiscover how to use unstorage in your project.\n\nInstallation\n\nInstall unstorage npm package:\n\nnpm\nYarn\npnpm\nnpm install unstorage\n\nCopy to clipboard\nUsage\nmy-storage.js\nimport { createStorage } from \"unstorage\";\n\n\n\nconst storage = createStorage(/* opts */);\n\n\n\nawait storage.getItem(\"foo:bar\"); // or storage.getItem('/foo/bar')\n\nCopy to clipboard\n\nOptions:\n\ndriver: Default driver, using memory if not provided\nInterface\nhasItem(key, opts?)\n\nChecks if storage contains a key. Resolves to either true or false.\n\nawait storage.hasItem(\"foo:bar\");\n\nCopy to clipboard\ngetItem(key, opts?)\n\nGets the value of a key in storage. Resolves to either a javascript primitive value or undefined.\n\nawait storage.getItem(\"foo:bar\");\n\nCopy to clipboard\ngetItems(items, opts)\n\n(Experimental) Gets the value of a multiple keys in storage in parallel.\n\nEach item in array can be either a string or an object with{ key, options? } format.\n\nReturned value is a Promise resolving to an array of objects with { key, value } format.\n\ngetItemRaw(key, opts?)\n\nNote: This is an experimental feature. Please check unjs/unstorage#142 for more information.\n\nGets the value of a key in storage in raw format.\n\n// Value can be a Buffer, Array or Driver's raw format\n\nconst value = await storage.getItemRaw(\"foo:bar.bin\");\n\nCopy to clipboard\nsetItem(key, value, opts?)\n\nAdd/Update a value to the storage.\n\nIf the value is not a string, it will be stringified.\n\nIf value is undefined, it is same as calling removeItem(key).\n\nawait storage.setItem(\"foo:bar\", \"baz\");\n\nCopy to clipboard\nsetItems(items, opts)\n\n(Experimental) Add/Update items in parallel to the storage.\n\nEach item in items array should be in { key, value, options? } format.\n\nReturned value is a Promise resolving to an array of objects with { key, value } format.\n\nsetItemRaw(key, value, opts?)\n\nNote: This is an experimental feature. Please check unjs/unstorage#142 for more information.\n\nAdd/Update a value to the storage in raw format.\n\nIf value is undefined, it is same as calling removeItem(key).\n\nawait storage.setItemRaw(\"data/test.bin\", new Uint8Array([1, 2, 3]));\n\nCopy to clipboard\nremoveItem(key, opts = { removeMeta = false })\n\nRemove a value (and it's meta) from storage.\n\nawait storage.removeItem(\"foo:bar\", { removeMeta: true });\n\n// same as await storage.removeItem(\"foo:bar\", true);\n\nCopy to clipboard\ngetMeta(key, opts = { nativeOnly? })\n\nGet metadata object for a specific key.\n\nThis data is fetched from two sources:\n\nDriver native meta (like file creation time)\nCustom meta set by storage.setMeta (overrides driver native meta)\nawait storage.getMeta(\"foo:bar\"); // For fs driver returns an object like { mtime, atime, size }\n\nCopy to clipboard\nsetMeta(key, opts?)\n\nSet custom meta for a specific key by adding a $ suffix.\n\nawait storage.setMeta(\"foo:bar\", { flag: 1 });\n\n// Same as storage.setItem('foo:bar$', { flag: 1 })\n\nCopy to clipboard\nremoveMeta(key, opts?)\n\nRemove meta for a specific key by adding a $ suffix.\n\nawait storage.removeMeta(\"foo:bar\");\n\n// Same as storage.removeItem('foo:bar$')\n\nCopy to clipboard\ngetKeys(base?, opts?)\n\nGet all keys. Returns an array of strings.\n\nMeta keys (ending with $) will be filtered.\n\nIf a base is provided, only keys starting with the base will be returned also only mounts starting with base will be queried. Keys still have a full path.\n\nawait storage.getKeys();\n\nCopy to clipboard\nclear(base?, opts?)\n\nRemoves all stored key/values. If a base is provided, only mounts matching base will be cleared.\n\nawait storage.clear();\n\nCopy to clipboard\ndispose()\n\nDisposes all mounted storages to ensure there are no open-handles left. Call it before exiting process.\n\nNote: Dispose also clears in-memory data.\n\nawait storage.dispose();\n\nCopy to clipboard\nmount(mountpoint, driver)\n\nBy default, everything is stored in memory. We can mount additional storage space in a Unix-like fashion.\n\nWhen operating with a key that starts with mountpoint, instead of default storage, mounted driver will be called.\n\nIn addition to base, you can set readOnly and noClear to disable write and clear operations.\n\nimport { createStorage } from \"unstorage\";\n\nimport fsDriver from \"unstorage/drivers/fs\";\n\n\n\n// Create a storage container with default memory storage\n\nconst storage = createStorage({});\n\n\n\nstorage.mount(\"/output\", fsDriver({ base: \"./output\" }));\n\n\n\n//  Writes to ./output/test file\n\nawait storage.setItem(\"/output/test\", \"works\");\n\n\n\n// Adds value to in-memory storage\n\nawait storage.setItem(\"/foo\", \"bar\");\n\nCopy to clipboard\nunmount(mountpoint, dispose = true)\n\nUnregisters a mountpoint. Has no effect if mountpoint is not found or is root.\n\nawait storage.unmount(\"/output\");\n\nCopy to clipboard\nwatch(callback)\n\nStarts watching on all mountpoints. If driver does not supports watching, only emits even when storage.* methods are called.\n\nconst unwatch = await storage.watch((event, key) => {});\n\n// to stop this watcher\n\nawait unwatch();\n\nCopy to clipboard\nunwatch()\n\nStop all watchers on all mountpoints.\n\nawait storage.unwatch();\n\nCopy to clipboard\ngetMount(key)\n\nGets the mount point (driver and base) for a specific key in storage.\n\nstorage.mount(\"cache\" /* ... */);\n\nstorage.mount(\"cache:routes\" /* ... */);\n\n\n\nstorage.getMount(\"cache:routes:foo:bar\");\n\n// => { base: \"cache:routes:\", driver: \"...\" }\n\nCopy to clipboard\ngetMounts(base?, { parents: boolean }?)\n\nGets the mount points on a specific base.\n\nstorage.mount(\"cache\" /* ... */);\n\nstorage.mount(\"cache:sub\" /* ... */);\n\n\n\nstorage.getMounts(\"cache:sub\");\n\n// => [{ base: \"cache:sub\", driver }]\n\n\n\nstorage.getMounts(\"cache:\");\n\n// => [{ base: \"cache:sub\", driver }, { base: \"cache:\", driver }]\n\n\n\nstorage.getMounts(\"\");\n\nstorage.getMounts(\"cache:sub\", { parents: true });\n\n// => [{ base: \"cache:sub\", driver }, { base: \"cache:\", driver }, { base: \"\", driver }]\n\nCopy to clipboard\nGeneric Types\n\nType getItem return value:\n\nawait storage.getItem<string>(\"k\"); // => <string>\n\n\n\nawait storage.getItemRaw<Buffer>(\"k\"); // => <Buffer>\n\nCopy to clipboard\n\nType check setItem parameters:\n\nstorage.setItem<string>(\"k\", \"val\"); // check ok\n\nstorage.setItemRaw<string>(\"k\", \"val\"); // check ok\n\n\n\nstorage.setItem<string>(\"k\", 123); // ts error\n\nstorage.setItemRaw<string>(\"k\", 123); // ts error\n\nCopy to clipboard\n\nTyped storage instance:\n\nconst storage = createStorage<string>();\n\n\n\nawait storage.getItem(\"k\"); // => <string>\n\n\n\nstorage.setItem(\"k\", \"val\"); // Check ok\n\nstorage.setItem(\"k\", 123); // TS error\n\nCopy to clipboard\nForward references use inheritance instead of overriding types.\nconst storage = createStorage<string>();\n\n\n\nstorage.setItem<number>(\"k\", 123); // TS error: <number> is not compatible with <string>\n\nCopy to clipboard\n\nTyping a sub set using prefixStorage:\n\nconst storage = createStorage();\n\n\n\nconst htmlStorage = prefixStorage<string>(storage, \"assets:html\");\n\n\n\nawait htmlStorage.getItem(\"foo.html\"); // => <string>\n\n\n\ntype Post = {\n\n  title: string;\n\n  content: string;\n\n};\n\n\n\nconst postStorage = prefixStorage<Post>(storage, \"assets:posts\");\n\n\n\nawait postStorage.getItem(\"foo.json\"); // => <Post>\n\nCopy to clipboard\n\nIn strict mode, will also return the undefined type to help you handle the case when miss getItem.\n\n\"use strict\";\n\n\n\nawait storage.getItem<string>(\"k\"); // => <string | null>\n\nCopy to clipboard"
  },
  {
    "title": "Extra Utilities ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/utils",
    "html": "Extra Utilities\n\nUnstorage exposes several utilities. You can individually import them and add only needed bytes to your bundle.\n\nNamespace\n\nCreate a namespaced instance of main storage. All operations are virtually prefixed. Useful to create shorcuts and limit access.\n\nprefixStorage(storage, prefix)\n\nimport { createStorage, prefixStorage } from \"unstorage\";\n\n\n\nconst storage = createStorage();\n\nconst assetsStorage = prefixStorage(storage, \"assets\");\n\n\n\n// Same as storage.setItem('assets:x', 'hello!')\n\nawait assetsStorage.setItem(\"x\", \"hello!\");\n\nCopy to clipboard\nSnapshots\nsnapshot(storage, base?)\n\nTake a snapshot from all keys in specified base into a plain javascript object (string: string). Base is removed from keys.\n\nimport { snapshot } from \"unstorage\";\n\n\n\nconst data = await snapshot(storage, \"/etc\");\n\nCopy to clipboard\nrestoreSnapshot(storage, data, base?)\n\nRestore a snapshot created by snapshot().\n\nawait restoreSnapshot(storage, { \"foo:bar\": \"baz\" }, \"/etc2\");\n\nCopy to clipboard"
  },
  {
    "title": "Introduction ¬∑ Unstorage",
    "url": "https://unstorage.unjs.io/",
    "html": "Introduction\n\nUnstorage provides an async Key-Value storage API with conventional features like multi driver mounting, watching and working with metadata, dozens of built-in drivers and a tiny core.\n\nWhy?\n\nWe usually choose one or more storage backends based on our use-cases such as filesystem, a database or LocalStorage for browsers. It soon starts to be create troubles for supporting and combining more than one or switching between them. For JavaScript library authors, this usually means they have to decide how many platforms they support and implement storage for each.\n\nFeatures\nDesigned for all environments: Browser, NodeJS, and Workers\nLots of Built-in drivers\nAsynchronous API\nUnix-style driver mounting to combine storages\nDefault in-memory storage\nTree-shakable utils and tiny core\nAuto JSON value serialization and deserialization\nBinary and raw value support\nState snapshots and hydration\nStorage watcher\nHTTP Storage with built-in server"
  }
]
